<h1>Smart pipelines</h1>
<p>ECMAScript Stage-0 Proposal. Living Document. J. S. Choi, 2018-02.</p>
<nav><details>
<summary><strong>Table of Contents</strong></summary>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="#motivation">Motivation</a>
<ul>
<li><a href="#core-proposal">Core Proposal</a>
<ul>
<li><a href="#whatwg-fetch-standard-core-proposal-only">WHATWG Fetch Standard (Core Proposal only)</a></li>
<li><a href="#jquery-core-proposal-only">jQuery (Core Proposal only)</a></li>
<li><a href="#underscorejs-core-proposal-only">Underscore.js (Core Proposal only)</a></li>
<li><a href="#lodash-core-proposal-only">Lodash (Core Proposal only)</a></li>
</ul>
</li>
<li><a href="#additional-feature-bp">Additional Feature BP</a></li>
<li><a href="#additional-feature-pp">Additional Feature PP</a>
<ul>
<li><a href="#whatwg-fetch-standard-core-proposal--additional-feature-bppp">WHATWG Fetch Standard (Core Proposal + Additional Feature BP+PP)</a></li>
<li><a href="#jquery-core-proposal--additional-feature-bppp">jQuery (Core Proposal + Additional Feature BP+PP)</a></li>
<li><a href="#underscorejs-core-proposal--additional-feature-bppp">Underscore.js (Core Proposal + Additional Feature BP+PP)</a></li>
<li><a href="#lodash-core-proposal--additional-feature-bppp">Lodash (Core Proposal + Additional Feature BP+PP)</a></li>
</ul>
</li>
<li><a href="#additional-feature-tc">Additional Feature TC</a></li>
<li><a href="#additional-feature-pf">Additional Feature PF</a>
<ul>
<li><a href="#ramda-core-proposal--additional-feature-bppf">Ramda (Core Proposal + Additional Feature BP+PF)</a></li>
<li><a href="#whatwg-streams-standard-core-proposal--additional-features-bppppf">WHATWG Streams Standard (Core Proposal + Additional Features BP+PP+PF)</a></li>
</ul>
</li>
<li><a href="#additional-feature-np">Additional Feature NP</a>
<ul>
<li><a href="#lodash-core-proposal--additional-features-bppppfnp">Lodash (Core Proposal + Additional Features BP+PP+PF+NP)</a></li>
<li><a href="#ramda-core-proposal--additional-features-bppfnp">Ramda (Core Proposal + Additional Features BP+PF+NP)</a></li>
<li><a href="#whatwg-streams-standard-core-proposal--additional-features-bppppfnp">WHATWG Streams Standard (Core Proposal + Additional Features BP+PP+PF+NP)</a></li>
</ul>
</li>
<li><a href="#additional-feature-tf">Additional Feature TF</a></li>
</ul>
</li>
<li><a href="#goals">Goals</a>
<ul>
<li><a href="#dont-break-my-code">“Don’t break my code.”</a>
<ul>
<li><a href="#backward-compatibility">Backward compatibility</a></li>
<li><a href="#zero-runtime-cost">Zero runtime cost</a></li>
<li><a href="#forward-compatibility">Forward compatibility</a></li>
</ul>
</li>
<li><a href="#dont-shoot-me-in-the-foot">“Don’t shoot me in the foot.”</a>
<ul>
<li><a href="#simple-scoping">Simple scoping</a></li>
<li><a href="#static-analyzability">Static analyzability</a></li>
</ul>
</li>
<li><a href="#dont-make-me-overthink">“Don’t make me overthink.”</a>
<ul>
<li><a href="#syntactic-locality">Syntactic locality</a></li>
<li><a href="#expressive-versatility">Expressive versatility</a></li>
<li><a href="#cyclomatic-simplicity">Cyclomatic simplicity</a></li>
</ul>
</li>
<li><a href="#make-my-code-easier-to-read">“Make my code easier to read.”</a>
<ul>
<li><a href="#untangled-flow">Untangled flow</a></li>
<li><a href="#distinguishable-punctuators">Distinguishable punctuators</a></li>
<li><a href="#terse-parentheses">Terse parentheses</a></li>
<li><a href="#terse-variables">Terse variables</a></li>
<li><a href="#terse-function-calls">Terse function calls</a></li>
<li><a href="#terse-composition">Terse composition</a></li>
<li><a href="#terse-partial-application">Terse partial application</a></li>
<li><a href="#terse-method-extraction">Terse method extraction</a></li>
</ul>
</li>
<li><a href="#other-goals">Other Goals</a>
<ul>
<li><a href="#conceptual-generality">Conceptual generality</a></li>
<li><a href="#human-writability">Human writability</a></li>
<li><a href="#novice-learnability">Novice learnability</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#relations-to-other-work">Relations to other work</a>
<ul>
<li><a href="#pipelines-in-other-programming-languages">Pipelines in other programming languages</a></li>
<li><a href="#topic-references-in-other-programming-languages">Topic references in other programming languages</a></li>
<li><a href="#function-binding">Function binding</a></li>
<li><a href="#function-composition">Function composition</a></li>
<li><a href="#partial-function-application">Partial function application</a></li>
<li><a href="#pattern-matching">Pattern matching</a></li>
<li><a href="#block-parameters">Block parameters</a>
<ul>
<li><a href="#topic-metaprogramming-references">Topic metaprogramming references</a></li>
</ul>
</li>
<li><a href="#do-expressions"><code>do</code> expressions</a></li>
<li><a href="#private-class-fields-class-decorators-nullish-coalescing-and-optional-chaining">Private class fields, class decorators, nullish coalescing, and optional chaining</a></li>
<li><a href="#alternative-pipeline-babel-plugin">Alternative pipeline Babel plugin</a></li>
<li><a href="#alternative-pipeline-proposals">Alternative pipeline proposals</a></li>
</ul>
</li>
<li><a href="#appendices">Appendices</a>
<ul>
<li><a href="#smart-body-syntax">Smart body syntax</a>
<ul>
<li><a href="#bare-style">Bare style</a>
<ul>
<li><a href="#bare-function-call">Bare function call</a></li>
<li><a href="#bare-async-function-call">Bare async function call</a></li>
<li><a href="#bare-constructor-call">Bare constructor call</a></li>
</ul>
</li>
<li><a href="#topic-style">Topic style</a></li>
<li><a href="#practical-consequences">Practical consequences</a></li>
</ul>
</li>
<li><a href="#operator-precedence-and-associativity">Operator precedence and associativity</a></li>
<li><a href="#explanation-of-nomenclature">Explanation of nomenclature</a></li>
</ul>
</li>
<li><a href="#term-rewriting">Term rewriting</a>
<ul>
<li><a href="#core-proposal-1">Core Proposal</a>
<ul>
<li><a href="#term-rewriting-with-autogenerated-variables">Term rewriting with autogenerated variables</a></li>
<li><a href="#term-rewriting-with-single-dummy-variable">Term rewriting with single dummy variable</a></li>
</ul>
</li>
<li><a href="#additional-feature%C2%A0np">Additional Feature NP</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
</details></nav>
<hr />
<p>This document is an <strong>explainer for</strong> the <a href="https://jschoi.org/18/es-smart-pipelines/spec"><strong>formal specification</strong> of a proposed
<strong>smart pipeline operator <code>|&gt;</code></strong></a> in
<strong>JavaScript</strong>, along with several other additional features. The specification
is divided into <strong>one Stage-0 Core Proposal</strong> plus <strong>five</strong> mutually
independent-but-compatible <strong>Additional Features</strong>:</p>
<p>|Name                     | Status  | Features                                                               | Purpose                                                                                                         |
| ----------------------- | ------- | ---------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
|<a href="#core-proposal">Core Proposal</a>        | Stage 0 | Infix pipelines <code>… \|&gt; …</code><br>Lexical topic <code>#</code>                         | <strong>Unary</strong> function/expression <strong>application</strong>                                                                   |
|<a href="#additional-feature-bp">Additional Feature BP</a>| None    | Block pipeline bodies <code>… \|&gt; {…}</code>                                      | Application of <strong>block expressions</strong>                                                                            |
|<a href="#additional-feature-pp">Additional Feature PP</a>| None    | Prefix pipelines <code>\|&gt; …</code>                                               | Application <strong>within blocks</strong>                                                                                   |
|<a href="#additional-feature-pf">Additional Feature PF</a>| None    | Pipeline functions <code>+&gt;</code>                                              | <strong>Partial</strong> function/expression <strong>application</strong><br>Function/expression <strong>composition</strong><br><strong>Method extraction</strong> |
|<a href="#additional-feature-tc">Additional Feature TC</a>| None    | Topical <code>catch</code> blocks                                                 | Application to <strong>caught errors</strong>                                                                                |
|<a href="#additional-feature-np">Additional Feature NP</a>| None    | N-ary pipelines <code>(…, …) \|&gt; …</code><br>Lexical topics <code>##</code>, <code>###</code>, and <code>...</code>| <strong>N-ary</strong> function/expression <strong>application</strong>                                                                   |
|<a href="#additional-feature-tf">Additional Feature TF</a>| None    | Topical <code>for</code> / <code>for await</code> loops                                      | Application within <strong>iteration loops</strong>                                                                          |</p>
<p>The <strong>Core Proposal</strong> is currently at <strong>Stage 0</strong> of the <a href="https://tc39.github.io/process-document/">TC39 process</a> and is planned to be presented, along with a <a href="https://github.com/tc39/proposal-pipeline-operator/wiki#proposal-1-f-sharp-only">competing
proposal</a>, to TC39 by <a href="https://github.com/littledan">Daniel “<strong>littledan</strong>” Ehrenberg of
Igalia</a>. The Core Proposal is a <strong>variant</strong> of the <a href="https://github.com/tc39/proposal-pipeline-operator/blob/37119110d40226476f7af302a778bc981f606cee/README.md">first
pipeline-operator proposal</a> also championed by Ehrenberg; this variant is
listed as <a href="https://github.com/tc39/proposal-pipeline-operator/wiki#proposal-4-smart-mix"><strong>Proposal 4: Smart Mix</strong> in the pipe-proposal wiki</a>. The variant resulted from <a href="https://github.com/tc39/proposal-pipeline-operator/issues?q=placeholder">previous discussions in the previous
pipeline-operator proposal</a>,
discussions which culminated in an <a href="https://github.com/tc39/proposal-pipeline-operator/issues/89#issuecomment-363853394">invitation by Ehrenberg to try writing a
specification draft</a>. A <strong>prototype Babel plugin</strong> will
also be written soon.</p>
<p>The <strong>Additional Features</strong> are <strong>not part of the Stage-0 Core Proposal</strong>. They
are included to illustrate possible <strong>separate follow-up proposals</strong> for the case
in which the Core Proposal advances past Stage 1. Together, the Core Proposal
and the Additional Features demonstrate a <strong>unified vision</strong> of a future in
which composition, partial application, method extraction, and error handling
are all tersely expressible with the same simple pipeline/topic concept.</p>
<p>You can take part in discussions on the <strong><a href="https://github.com/tc39/proposal-pipeline-operator/issues">GitHub issue tracker</a></strong>. When you
file an issue, please note in it that you are talking <strong>specifically</strong> about
<strong><a href="https://github.com/tc39/proposal-pipeline-operator/wiki#proposal-4-smart-mix">“Proposal 4: Smart Mix”</a></strong>.</p>
<p><strong>This specification uses <code>#</code></strong> as its <a href="#nomenclature">topic reference</a>. However,
this is <strong>not set</strong> in stone. In particular, <strong><code>@</code> or <code>?</code></strong> could also be used.
<strong>Bikeshedding discussions</strong> over what characters to use for the topic token has
been occurring on GitHub at <a href="https://github.com/tc39/proposal-pipeline-operator/issues/91">tc39/proposal-pipeline-operator
issue #91</a>.</p>
<h1>Motivation</h1>
<p>This section gives a brief overview of the motivations behind the smart pipeline
operator’s Core Proposal, as well the Additional Features listed above.
<strong>Examples from real-world libraries</strong> are juxtaposed with their original
versions. The original versions have been lightly edited (e.g., breaking up
lines, removing semicolons), in order to fit their horizontal widths into this
table. <strong>Examples that use Additional Features</strong> are included <strong>only to
illustrate</strong> the power of the pipeline/topic concept and are always simply
<strong>rewritable</strong> into forms that use <strong>only the Core Proposal</strong>.</p>
<h2>Core Proposal</h2>
<p>The Core Proposal is <a href="https://jschoi.org/18/es-smart-pipelines/spec"><strong>formally specified in a separate draft
specification</strong></a>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<p>The binary “smart” pipeline operator <code>|&gt;</code> proposed here would provide a
<strong><a href="#dont-break-my-code">backwards- and forwards-compatible</a></strong> style of
<strong>chaining nested expressions</strong> into a readable, <strong>left-to-right</strong> manner.</p>
<p>Using a <strong><a href="#zero-runtime-cost">zero-cost abstraction</a></strong>, <strong>nested</strong> data
transformations become <a href="#untangled-flow"><strong>untangled</strong> into <strong>short steps</strong></a>.</p>
<td>
<pre><code class="language-js">new User.Message(
  capitalize(
    doubledSay(
      await promise
        ??: throw new TypeError(
          `Invalid value from ${promise}`)
    ), ', '
  ) + '!'
)
</code></pre>
<p><strong>Nested, deeply composed</strong> expressions occur often in JavaScript. They occur
whenever any single value must be processed by a <strong>series of data
transformations</strong>, whether they be <strong>operations, functions, or constructors</strong>.
Unfortunately, these deeply nested expressions often result in <strong>messy
spaghetti</strong> code, due to their mixing of <strong>prefix, infix, and postfix</strong>
expressions together. Writing such code requires many nested <strong>levels of
indentation</strong> and parentheses. Reading such code requires checking <strong>both the
left and right of each subexpression</strong> to understand its data flow.</p>
<tr>
<td>
<pre><code class="language-js">promise
|&gt; await #
|&gt; # ??: throw new TypeError(
    `Invalid value from ${promise}`)
|&gt; doubleSay(#, ', ')
|&gt; capitalize
|&gt; # + '!'
|&gt; new User.Message
|&gt; await stream.write
</code></pre>
<p>With smart pipelines, the code above becomes <strong>terser</strong> and, literally, more
<strong>straightforward</strong>. Prefix, infix, and postfix expressions would be less
tangled together in threads of spaghetti. Instead, data values would be <strong>piped
from left to right</strong> through a <strong>single flat thread of postfix expressions</strong>,
with a <a href="#untangled-flow"><strong>single</strong> level of <strong>indentation</strong></a> and <a href="#terse-parentheses"><strong>four fewer</strong>
pairs of <strong>parentheses</strong></a>  – essentially forming a <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">reverse
Polish notation</a>.</p>
<p>The resulting code’s <a href="#make-my-code-easier-to-read"><strong>terseness</strong> and <strong>flatness</strong></a> may be both easier for the JavaScript developer to <strong>read</strong> and to
<strong>edit</strong>. This uniform postfix notation preserves locality between related code;
the reader may <strong>follow the flow</strong> of data more easily through this <a href="#untangled-flow">single
flattened thread of postfix operations</a>. And the developer may
<a href="#human-writability">more easily <strong>add or remove operations</strong></a> at the beginning,
end, or middle of the thread, <strong>without changing</strong> the <strong>indentation</strong> of
unrelated lines.</p>
<td>
<pre><code class="language-js">await stream.write(
  new User.Message(
    capitalize(
      doubledSay(
        await promise
          ??: throw new TypeError(
            `Invalid value from ${promise}`)
      ), ', '
    ) + '!'
  )
)
</code></pre>
<p>Compared with the pipeline version, the original code requires <strong>additional
indentation and grouping</strong> on each step. This requires four more levels of
indentation and four more pairs of parentheses.</p>
<p>In addition, much related code is here separated by unrelated code. Rather than
a <strong>uniform</strong> postfix chain, operations appear <strong>either before</strong> the previous
step’s expression (<code>await stream.write(…)</code>,<code>new User.Message(…)</code>,
<code>capitalize(…)</code>, <code>doubledSay(…)</code>, <code>await …</code>) but also <strong>after</strong> (<code>… ??: throw new TypeError()</code>, <code>… + '!'</code>). An additional argument to function calls (such as
<code>,</code> in <code>doubledSay(…, ', ')</code>) is also separated from its function calls,
forming another easy-to-miss “postfix” argument.</p>
<tr>
<td>
<p>Each postfix expression in a pipeline (called a <strong><a href="https://jschoi.org/18/es-smart-pipelines/spec#prod-PipelineBody">pipeline body</a></strong>) is in its
own <strong>inner lexical scope</strong>, within which a special topic reference <code>#</code> is
defined. This <code>#</code> is a reference to the <strong><a href="https://jschoi.org/18/es-smart-pipelines/spec#sec-lexical-topics">lexical topic</a></strong> of the pipeline
(<code>#</code> itself is a <strong>topic reference</strong>). When the <a href="https://jschoi.org/18/es-smart-pipelines/spec#prod-PipelineHead">pipeline’s <strong>head</strong></a> (the expression at its left-hand side) is <strong>evaluated</strong>, it then becomes
the pipeline’s lexical topic. A <strong>new lexical environment</strong> is created, within
which <code>#</code> is immutably <strong>bound to the topic</strong>, and with which the pipeline’s
body is then evaluated, using that <strong>topic binding</strong>. In the end, the whole
pipeline expression’s value is the end result into which the pipeline body
evaluated with the topic binding.</p>
<pre><code class="language-js">5 |&gt; do {
  # = 50;
  # + 1
}
// 🚫 Reference Error:
// Cannot assign to topic reference.
</code></pre>
<p>The topic binding is immutable, established only once per lexical environment.
It is an error to attempt to assign a value to it using <code>=</code>, whether inside or
outside a pipeline body.</p>
<td>
<tr>
<td>
<p>For instance, the chained pipeline:</p>
<pre><code class="language-js">5 |&gt; # - 3
|&gt; -#
|&gt; # * 2
|&gt; Math.max(#, 0);
</code></pre>
<td>
<p>…is equivalent to the tangled nested expression:</p>
<pre><code class="language-js">Math.max(
  -(5 - 3) * 2,
  0
)
</code></pre>
<tr>
<td>
<p>The syntax is <a href="#term-rewriting"><strong>statically term rewritable</strong> into already valid code</a> in this way, with <a href="#zero-runtime-cost">theoretically <strong>zero runtime cost</strong></a>.</p>
<p>Similar use cases appear <strong>numerous times</strong> in JavaScript code, whenever any value
is transformed by <strong><a href="#expressive-versatility">expressions of any type</a></strong>:
function calls, property calls, method calls, object constructions, arithmetic
operations, logical operations, bitwise operations, <code>typeof</code>, <code>instanceof</code>,
<code>await</code>, <code>yield</code> and <code>yield *</code>, and <code>throw</code> expressions.</p>
<tr>
<td>
<pre><code class="language-js">promise
|&gt; await #
|&gt; # ??: throw new TypeError()
|&gt; doubleSay(#, ', ')
|&gt; capitalize
|&gt; # + '!'
|&gt; new User.Message
|&gt; await stream.write
</code></pre>
<p>Note that, in the example above, it is <strong>not necessary</strong> to include
<strong>parentheses</strong> for <code>capitalize</code> or <code>new User.Message</code>; they were <strong>tacitly
implied</strong>, respectively forming a <strong>tacit unary function call</strong> and a <strong>tacit
unary constructor call</strong>. In other words, the example above is equivalent to
the version below.</p>
<td>
<pre><code class="language-js">await stream.write(
  new User.Message(
    capitalize(
      doubledSay(
        await promise
          ??: throw new TypeError(
            `Invalid value from ${promise}`)
      ), ', '
    ) + '!'
  )
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">promise
|&gt; await #
|&gt; # ??: throw new TypeError(
    `Invalid value from ${#}`)
|&gt; doubleSay(#, ', ')
|&gt; capitalize(#)
|&gt; # + '!'
|&gt; new User.Message(#)
|&gt; await stream.write(#)
</code></pre>
<p>This version is equivalent to the version above, except that the <code>capitalize</code>
and <code>new User.Message</code> pipeline bodies explicitly include optional topic
references <code>#</code>, making the expressions slightly wordier than necessary.</p>
<td>
<pre><code class="language-js">await stream.write(
  new User.Message(
    capitalize(
      doubledSay(
        await promise
          ??: throw new TypeError(
            `Invalid value from ${promise}`)
      ), ', '
    ) + '!'
  )
)
</code></pre>
<tr>
<td>
<p>Being able to automatically detect this <strong>“<a href="#bare-style">bare style</a>”</strong> is the <a href="#smart-body-syntax"><strong>smart</strong>
part of the “smart pipeline operator”</a>. The styles of
<a href="https://en.wikipedia.org/wiki/Functional_programming"><strong>functional</strong> programming</a>, <a href="https://en.wikipedia.org/wiki/Dataflow_programming"><strong>dataflow</strong>
programming</a>, and <a href="https://en.wikipedia.org/wiki/Tacit_programming"><strong>tacit</strong> programming</a> may particularly benefit from bare pipelines and their <a href="#terse-function-application">terse
function application</a>.</p>
<td>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; # + 2
|&gt; # * 3
|&gt; -#
|&gt; g(#, x)
|&gt; o.unaryMethod
|&gt; await asyncFunction
|&gt; await o.asyncMethod
|&gt; new Constructor
</code></pre>
<p>This pipeline is a very flat expression, with only one level of indentation, and
with each transformation step on its own line.</p>
<p>Note that <code>… |&gt; f</code> is a bare unary function call. This is the same as <code>… |&gt; f(#)</code>,
but the topic reference <code>#</code> is unnecessary; it is invisibly, tacitly implied.</p>
<p>This is the <a href="#smart-body-syntax"><strong>smart</strong> part of the smart pipeline operator</a>,
which can distinguish between two syntax styles (<strong><a href="#bare-style">bare style</a></strong> vs. <strong><a href="#topic-style">topic
style</a></strong>) by using a simple rule: <strong>bare</strong> style uses only <strong>identifiers,
dots, <code>new</code></strong>, and <strong>await</strong> – and <strong>never parentheses, brackets, braces</strong>, or
<strong>other operators</strong>. And <strong>topic</strong> style <strong>always</strong> contains at least one
<strong>topic reference</strong>. For more information, see the reference below about the
<strong><a href="#smart-body-syntax">smart body syntax</a></strong>.</p>
<td>
<pre><code class="language-js">new Constructor(
  await o.asyncMethod(
    await asyncFunction(
      o.unaryMethod(
        g(
          -(f(value) + 2)
            * 3,
          x
        )
      )
    )
  )
)
</code></pre>
<p>In contrast to the version with pipes, this code is deeply nested, not flat.</p>
<p>The expression has two levels of indentation instead of one.
Reading its data flow requires checking both the beginning and end of each
expression, and each step expression gradually increases in size.</p>
<p>Inserting or removing any step of the data flow also requires changes to the
indentation of any previous steps’ lines.</p>
<tr>
<td>
<pre><code class="language-js">value |&gt; x + 50 |&gt; f |&gt; g(x, 2)
// 🚫 Syntax Error:
// Pipeline body `|&gt; x + 50`
// binds topic but contains no topic reference.
// 🚫 Syntax Error:
// Pipeline body `|&gt; f(x, 2)`
// binds topic but contains no topic reference.
</code></pre>
<p>In order to fulfill the <a href="#goals">goal</a> of <a href="#dont-shoot-me-in-the-foot">“don’t shoot me in the foot”</a>,
when a <strong>pipeline is in <a href="#topic-style">topic style</a></strong> but its <strong>body has no topic reference</strong>,
that is an <strong><a href="#static-early-errors">early error</a></strong>. Such a degenerate pipeline has a very good
chance of actually being an accidental bug. (Note that the bare-style pipeline
body <code>|&gt; f</code> is <em>not</em> an error. The <a href="#bare-style">bare style</a> is not supposed to contain any
topic references <code>#</code>.)</p>
<td>
<tr>
<td>
<pre><code class="language-js">function doubleSay (str, separator) {
  return `${str}${separator}${string}`
}

function capitalize (str) {
  return str[0].toUpperCase()
    + str.substring(1)
}

promise
|&gt; await #
|&gt; # ??: throw new TypeError()
|&gt; doubleSay(#, ', ')
|&gt; capitalize |&gt; # + '!'
|&gt; new User.Message
|&gt; await stream.write
</code></pre>
<p>This pipeline is also relatively flat, with only one level of indentation, and
with each transformation step on its own line.</p>
<p>(<code>… |&gt; capitalize</code> is a bare unary function call equivalent to <code>… |&gt; capitalize(#)</code>.
Similarly, <code>… |&gt; new User.Message</code> is a bare unary constructor call, abbreviated
from <code>… |&gt; new User.Message(#)</code>.)</p>
<td>
<pre><code class="language-js">function doubleSay (str, separator) {
  return `${str}${separator}${str}`
}

function capitalize (str) {
  return str[0].toUpperCase()
    + str.substring(1)
}

await stream.write(
  new User.Message(
    capitalizedString(
      doubledSay(
        await promise
          ??: throw new TypeError()
      ), ', '
    ) + '!'
  )
)
</code></pre>
<p>This deeply nested expression has four levels of indentation instead of two.
Reading its data flow requires checking both the beginning of each expression
(<code>new User.Message</code>, <code>capitalizedString</code>, <code>doubledSay</code>, <code>await promise</code> and
end of each expression (<code>??: throw new TypeError()</code>, <code>, ', '</code>, <code>+ '!'</code>)).</p>
<tr>
<td>
<pre><code class="language-js">… |&gt; f(#, #)
… |&gt; [#, # * 2, # * 3]
</code></pre>
<p>The topic reference may be used multiple times in a pipeline body. Each use
refers to the same value (wherever the topic reference is not overridden by
another, inner pipeline’s topic scope). Because it is bound to the result of the
topic, the topic is still only ever evaluated once.</p>
<td>
<pre><code class="language-js">do {
  const $ = …;
  f($, $)
}
do {
  const $ = …;
  [$, $ * 2, $ * 3]
}
</code></pre>
<p>This is equivalent to storing the topic value in a unique variable, then using
that variable multiple times in an expression. <a href="#do-expressions"><code>do</code> expressions</a> are used
here to remain equivalent to the pipeline versions, which are themselves
expressions that are embeddable in other expressions.</p>
<tr>
<td>
<pre><code class="language-js">promise
|&gt; await #
|&gt; # ??: throw new TypeError()
|&gt; `${#}, ${#}`
|&gt; #[0].toUpperCase() + #.substring(1)
|&gt; # + '!'
|&gt; new User.Message
</code></pre>
<p>When tiny functions are only used once, and when their bodies would be obvious and
self-documenting in meaning, then they might be ritual boilerplate that a developer
may prefer to inline: trading off self-documentation for localization of code.</p>
<td>
<pre><code class="language-js">new User.Message(do {
  const value = do {
    const value = await promise
      ??: throw new TypeError();
    `${value}, ${value}`
  }
  value[0].toUpperCase()
    + value.substring(1)
} + '!')
</code></pre>
<p>Inlining these functions directly into nested expressions using <code>do</code> is
less successful than inlining the functions with the pipeline, both in
writability and in readability.</p>
<tr>
<td>
<pre><code class="language-js">promise
|&gt; await #
|&gt; # ??: throw new TypeError()
|&gt; `${#}, ${#}`
|&gt; #[0].toUpperCase() + #.substring(1)
|&gt; # + '!'
|&gt; new User.Message
</code></pre>
<td>
<pre><code class="language-js">do {
  const promiseValue = await promise
    ??: throw new TypeError();
  const doubledValue =
    `${promiseValue}, ${promiseValue}`;
  const capitalizedValue
    = doubledValue[0].toUpperCase()
      + doubledValue.substring(1);
  const exclaimedValue
    = capitalizedValue + '!';
  new User.Message(exclaimedValue)
}
</code></pre>
<p>Using a sequence of variables instead has both advantages and disadvantages. The
variable names may be self-documenting. But they also are verbose. They visually
distract from the crucial data transformations (overemphasizing the expressions’
nouns over their verbs), and it is easy to typo their names.</p>
<tr>
<td>
<pre><code class="language-js">promise
|&gt; await #
|&gt; # ??: throw new TypeError()
|&gt; normalize
|&gt; `${#}, ${#}`
|&gt; #[0].toUpperCase() + #.substring(1)
|&gt; # + '!'
|&gt; new User.Message
</code></pre>
<p>With a pipeline, there are no unnecessary variable identifiers. Inserting a new
step in between two steps (or deleting a step) only touches one new line. Here,
a call of a function <code>normalize</code> was inserted between the second and third steps.</p>
<td>
<pre><code class="language-js">do {
  const promiseValue = await promise
    ??: throw new TypeError();
  const normalizedValue = normalize();
  const doubledValue =
    `${normalizedValue}, ${normalizedValue}`;
  const capitalizedValue
    = doubledValue[0].toUpperCase()
      + doubledValue.substring(1);
  const exclaimedValue
    = capitalizedValue + '!';
  new User.Message(exclaimedValue)
}
</code></pre>
<p>This code underwent a similar insertion of <code>normalize</code>. With a series of
variables, inserting a new step in between two other steps (or deleting a step)
requires editing the variable names in the following step.</p>
<tr>
<td>
<p>As with any other expression, a pipeline in <a href="#topic-style">topic style</a> may use a <a href="#do-expressions"><code>do</code>
block</a> as its body, as long as the <code>do</code> expression contains the
topic reference <code>#</code>. The topic reference <code>#</code> is bound to the previous result
<code>value |&gt; f</code> within the scope of the block, and the result of the <code>do</code> block
becomes the final result of that pipeline, which in turn is passed into <code>|&gt; g</code>.</p>
<pre><code class="language-js">value
|&gt; f
|&gt; do { sideEffect(); # }
|&gt; g
</code></pre>
<p>This can be useful for embedding side effects in pipeline chains, as in the example
above, and <code>if</code> <code>else</code> statements and <code>try</code> statements, such as with the
examples in the rows below.</p>
<p>This may be made even more pithier with <a href="#additional-feature-bp">Additional Feature BP</a>, explained later.</p>
<td>
<pre><code class="language-js">g (
  do {
    const $ = f(value);
    sideEffect();
    $
  }
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; do {
    if (typeof # === 'number')
      # + 1;
    else
      { data: # };
  }
|&gt; g
</code></pre>
<p><code>if</code> <code>else</code> statements may also be used within <code>do</code>-block pipeline bodies, as an
alternative to the ternary conditional operator <code>?</code> <code>:</code>.</p>
<td>
<pre><code class="language-js">g (
  do {
    const $ = f(value);
    if (typeof $ === 'number')
      $ + 1;
    else
      { data: $ };
  }
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; do {
  try {
    JSON.parse(#);
    catch (error) {
      { message: error.message }
    }
  }
}
|&gt; g
</code></pre>
<p><code>try</code> statements are also useful to embed in pipelines with <code>do</code>-block bodies.</p>
<td>
<pre><code class="language-js">g (
  do {
    const $ = f(value);
    try {
      JSON.parse($);
      catch (error) {
        { message: error.message }
      }
    }
  }
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; x =&gt; # + x
</code></pre>
<p>The body of a pipeline in topic style may contain an inner arrow function but no
other type of block expression. Both versions of this example result in an arrow
function in a closure on the previous pipeline’s result <code>value |&gt; f</code>.</p>
<td>
<pre><code class="language-js">do {
  const $ = f(value);
  x =&gt; $ + x
}
</code></pre>
<p>The arrow function lexically closes over the topic value, takes one parameter,
and returns the sum of the topic value and the parameter.</p>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; settimeout(() =&gt; # * 5)
</code></pre>
<p>This ability to create arrow functions, which do not lexically shadow the topic,
can be useful for using callbacks in a pipeline.</p>
<td>
<pre><code class="language-js">do {
  const $ = f(value);
  settimeout(() =&gt; $ * 5)
}
</code></pre>
<p>The topic value (here represented by a normal variable <code>$</code>) is still lexically
accessible within the arrow function’s body in both examples.</p>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; (() =&gt; # * 5)
|&gt; settimeout
</code></pre>
<p>The arrow function can also be created on a separate pipeline step.</p>
<td>
<pre><code class="language-js">do {
  const $ = f(value);
  settimeout(() =&gt; $ * 5)
}
</code></pre>
<p>The result here is the same.</p>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; () =&gt; # * 5
|&gt; settimeout
// 🚫 Syntax Error:
// Unexpected token `=&gt;`.
// Cannot parse base expression.
</code></pre>
<p>Note, however, that arrow functions have looser precedence than the pipe
operator. This means that if a pipeline creates an arrow function alone in one
of its steps’ bodies, then the arrow-function expression must be parenthesized.
(The same applies to assignment and yield operators, which are also looser than
the pipeline operator.) The example above is being parsed as if it were:</p>
<pre><code class="language-js">(value |&gt; f |&gt; ()) =&gt;
  (# * 5 |&gt; settimeout)
// 🚫 Syntax Error:
// Unexpected token `=&gt;`.
// Cannot parse base expression.
</code></pre>
<p>The arrow function must be parenthesized, simply as with any other
looser-precedence expression:</p>
<pre><code class="language-js">value
|&gt; (f, g)
|&gt; (() =&gt; # * 5)
|&gt; settimeout
</code></pre>
<td>
<tr>
<td>
<p>Both the head and the body of a pipeline may contain nested inner pipelines.</p>
<pre><code class="language-js">value
|&gt; f(x =&gt;
    # + x |&gt; g |&gt; # * 2)
|&gt; #.toString()
</code></pre>
<td>
<p>A nested pipeline works consistently. It merely shadows the outer context’s
topic with the topic within its own body’s inner context.</p>
<pre><code class="language-js">do {
  const $ = value;
  f(x =&gt; g($ + x) * 2)
    .toString()
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">value
|&gt; # ** 2
|&gt; f(x =&gt; #
  |&gt; g(#, x)
  |&gt; [# * 3, # * 5])
</code></pre>
<td>
<pre><code class="language-js">do {
  const $ = value ** 2;
  f(x =&gt; {
    const _$ = g($, x);
    return [_$ * 3, _$ * 5];
  })
}
</code></pre>
<tr>
<td>
<p><strong>Most nested statements cannot</strong> use an <strong>outside context’s topic</strong> in their
expressions. This applies to block statements; function, async-function,
generator, async-generator, and class definitions; <code>for</code> and <code>while</code> statements
(but see <a href="#additional-feature-tf">Additional Feature TF</a>); and <code>catch</code> clauses (but see <a href="#additional-feature-tc">Additional
Feature TC</a>). (Exceptions include arrow functions and <code>do</code>, <code>if</code>, <code>try</code>,
<code>return</code>, <code>yield</code>, and <code>yield *</code> statements.)</p>
<p>This behavior is in order to fulfill the <a href="#goals">goals</a> of <a href="#simple-scoping">simple scoping</a> and of
<a href="#dont-shoot-me-in-the-foot">“don’t shoot me in the foot”</a>: it prevents the origin of any topic from being
difficult to find.</p>
<pre><code class="language-js">value |&gt; function () { return #; }
// 🚫 Syntax Error:
// Lexical context `function () { return #; }`
// contains a topic reference
// but has no topic binding.
// 🚫 Syntax Error:
// Pipeline body `|&gt; function () { … }`
// binds topic but contains no topic reference.
</code></pre>
<td>
<tr>
<td>
<pre><code class="language-js">value |&gt; class { m: () { return #; }}
// 🚫 Syntax Error:
// Pipeline body `|&gt; class { … }`
// binds topic but contains no topic reference.
</code></pre>
<td>
<tr>
<td>
<pre><code class="language-js">value
|&gt; await f(#, 5)
|&gt; {
    # + 30
  }
|&gt; g
</code></pre>
<p>The nested statements that <strong>may</strong> contain topic references from outer lexical
environments are <strong><a href="#do-expressions"><code>do</code> expressions</a></strong>, <strong>arrow functions, <code>if</code> statements</strong>,
<code>try</code> statements (though not <code>catch</code> clauses), and <code>return</code>, <code>yield</code>, and
<code>yield *</code> statements.</p>
<p>This example demonstrates how a <code>do</code> expression can be a pipeline body if it
contains an outer topic reference <code>#</code>.</p>
<td>
<pre><code class="language-js">g(await f(value, 5) + 30)
</code></pre>
<tr>
<td>
<pre><code class="language-js">value
|&gt; await f(#, 5)
|&gt; {
    if (# &gt; 20)
      # + 30;
    else
      # - 10;
  }
|&gt; g
</code></pre>
<p>Using <code>do</code> expressions then allows the embedding of arbitrary statements such as
<code>if</code> statements inside pipeline bodies, greatly increasing their expressiveness.</p>
<td>
<pre><code class="language-js">g(do {
  const value_ = await f(value, 5)
  if (value_ &gt; 20)
    value_ + 30;
  else
    value_ - 10;
})
</code></pre>
<tr>
<td>
<pre><code class="language-js">value
|&gt; await f(#, 5)
|&gt; {
    if (x &gt; 20)
      x + 30;
    else
      x - 10;
  }
|&gt; g
// 🚫 Syntax Error:
// Pipeline body `|&gt; { if (…) … else … }`
// binds topic but contains no topic reference.
</code></pre>
<p>But the same <a href="#static-early-errors">early error rules</a> that apply to any topical
pipeline body apply also to topical bodies that are <code>do</code> expressions.</p>
<td>
</table>
<h3>WHATWG Fetch Standard (Core Proposal only)</h3>
<p>The <a href="https://fetch.spec.whatwg.org/">WHATWG Fetch Standard</a> contains several examples of using the DOM <code>fetch</code>
function, resolving its promises into values, then processing the values in
various ways. These examples may become more easily readable with smart pipelines.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">'/music/pk/altes-kamuffel'
|&gt; await fetch(#)
|&gt; await #.blob()
|&gt; playBlob
</code></pre>
<td>
<pre><code class="language-js">fetch('/music/pk/altes-kamuffel')
  .then(res =&gt; res.blob())
  .then(playBlob)
</code></pre>
<pre><code class="language-js">playBlob(
  await (
    await fetch('/music/pk/altes-kamuffel')
  ).blob()
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">'https://example.com/'
|&gt; await fetch(#, { method: 'HEAD' })
|&gt; #.headers.get('content-type')
|&gt; console.log
</code></pre>
<td>
<pre><code class="language-js">fetch('https://example.com/',
  { method: 'HEAD' }
).then(response =&gt;
  console.log(
    response.headers.get('content-type'))
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">'https://example.com/'
|&gt; await fetch(#, { method: 'HEAD' })
|&gt; #.headers.get('content-type')
|&gt; console.log
</code></pre>
<td>
<pre><code class="language-js">console.log(
  (await
    fetch('https://example.com/',
      { method: 'HEAD' }
    )
  ).headers.get('content-type')
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">'https://example.com/'
|&gt; await fetch(#, { method: 'HEAD' })
|&gt; #.headers.get('content-type')
|&gt; console.log
</code></pre>
<td>
<pre><code class="language-js">do {
  const url = 'https://example.com/';
  const response =
    await fetch(url, { method: 'HEAD' });
  const contentType =
    response.headers.get('content-type');
  console.log(contentType)
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">'https://pk.example/berlin-calling'
|&gt; await fetch(#, { mode: 'cors' })
|&gt; do {
    if (
      # |&gt; #.headers.get('content-type')
        |&gt; #??.toLowerCase()
        |&gt; #.indexOf('application/json')
        |&gt; # &gt;= 0
    )
      throw new TypeError();
    else
      # |&gt; await #.json()
        |&gt; processJSON
  }
}
</code></pre>
<td>
<pre><code class="language-js">do {
  const response =
    await fetch('https://pk.example/berlin-calling',
      { mode: 'cors' }
    );
  const json = do {
    if (response.headers.get('content-type')
      ??.toLowerCase()
      .indexOf('application/json') &gt;= 0
    )
      response.json();
    else
      throw new TypeError();
  };
  processJSON(json)
}
</code></pre>
</table>
<h3>jQuery (Core Proposal only)</h3>
<p>As the single most-used JavaScript library in the world, <a href="https://jquery.com/">jQuery</a> has provided
an alternative human-ergonomic API to the DOM since 2006. jQuery is under the
stewardship of the <a href="https://js.foundation/">JS Foundation</a>, a member organization of TC39 through which
jQuery’s developers are represented in TC39. jQuery’s API requires complex data
processing that becomes more readable with smart pipelines.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">return data
|&gt; buildFragment([#], context, scripts)
|&gt; #.childNodes
|&gt; jQuery.merge([], #);
</code></pre>
<p>The path that a reader’s eyes must trace while reading this pipeline moves
straight down, with some movement toward the right then back: from <code>data</code> to
<code>buildFragment</code> (and its arguments), then <code>.childNodes</code>, then <code>jQuery.merge</code>.
Here, no one-off-variable assignment is necessary.</p>
<td>
<pre><code class="language-js">parsed = buildFragment(
  [ data ], context, scripts
);
return jQuery.merge(
  [], parsed.childNodes
);
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/parseHTML.js">jquery/src/core/parseHTML.js</a>. In this code, the eyes first must look
for <code>data</code> – then upwards to <code>parsed = buildFragment</code> (and then back for
<code>buildFragment</code>’s other arguments) – then down, searching for the location of
the <code>parsed</code> variable in the next statement – then right when noticing its
<code>.childNodes</code> postfix – then back upward to <code>return jQuery.merge</code>.</p>
<tr>
<td>
<pre><code class="language-js">(key |&gt; toType) === 'object'
key |&gt; toType |&gt; # === 'object'
</code></pre>
<p><code>|&gt;</code> has a looser precedence than most operators, including <code>===</code>. (Only
assignment operators, arrow function <code>=&gt;</code>, yield operators, and the comma
operator are any looser.)</p>
<td>
<pre><code class="language-js">toType(key) === 'object'
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/access.js">jquery/src/core/access.js</a>.</p>
<tr>
<td>
<pre><code class="language-js">context = context
|&gt; # instanceof jQuery
    ? #[0] : #
</code></pre>
<td>
<pre><code class="language-js">context =
  context instanceof jQuery
    ? context[0] : context
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/access.js">jquery/src/core/access.js</a>.</p>
<tr>
<td>
<pre><code class="language-js">context
|&gt; #??.nodeType
      ? #.ownerDocument || #
      : document
|&gt; jQuery.parseHTML(match[1], #, true)
|&gt; jQuery.merge
</code></pre>
<td>
<pre><code class="language-js">jQuery.merge(
  this, jQuery.parseHTML(
    match[1],
    context??.nodeType
      ? context.ownerDocument
        || context
      : document,
    true
  )
)
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/init.js">jquery/src/core/init.js</a>. Used <code>??.</code> in both versions for conciseness.</p>
<tr>
<td>
<pre><code class="language-js">match |&gt; do {
  if (this[match] |&gt; isFunction)
    # |&gt; context[#] |&gt; this[match](#);
  else
    # |&gt; context[#] |&gt; this.attr(match, #);
}
</code></pre>
<p>Note how, in this version, the parallelism between the two clauses is very
clear: they both share the form <code>match |&gt; context[#] |&gt; something(match, #)</code>.</p>
<td>
<pre><code class="language-js">if (isFunction(this[match])) {
  this[match](context[match]);
} else
  this.attr(match, context[match]);
}
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/init.js">jquery/src/core/init.js</a>. Here, the parallelism between the clauses
is somewhat less clear: the common expression <code>context[match]</code> is at the end
of both clauses, at a different offset from the margin.</p>
<tr>
<td>
<pre><code class="language-js">elem = match[2]
|&gt; document.getElementById
</code></pre>
<td>
<pre><code class="language-js">elem = document.getElementById( match[ 2 ] )
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/init.js">jquery/src/core/init.js</a>.</p>
<tr>
<td>
<pre><code class="language-js">return context |&gt; do {
  // Handle HTML strings
  if (…)
    …
  // Handle $(expr, $(...))
  else if (!# || #.jquery)
    # |&gt; # || root
      |&gt; #.find(selector);
  // Handle $(expr, context)
  else
    # |&gt; this.constructor
      |&gt; #.find(selector);
};
</code></pre>
<p>The parallelism between the final two clauses becomes clearer here too.
They both are of the form <code># |&gt; something |&gt; #.find(selector)</code>.</p>
<td>
<pre><code class="language-js">// Handle HTML strings
if (…)
  …
// Handle $(expr, $(...))
else if (!context || context.jquery)
  return (context || root).find(selector);
// Handle $(expr, context)
else
  return this.constructor(context)
    .find(selector);
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/init.js">jquery/src/core/init.js</a>. The parallelism is much less clear here.</p>
<tr>
<td>
<pre><code class="language-js">return selector |&gt; do {
  if (typeof # === 'string')
    …
  else if (# |&gt; isFunction) {
    if (root.ready !== undefined)
      root.ready(#);
    else
      #(jQuery);
  }
  else
    jQuery.makeArray(#, this);
};
</code></pre>
<td>
<pre><code class="language-js">if (typeof selector === 'string')
  …
else if (isFunction(selector))
  return root.ready !== undefined
    ? root.ready(selector)
    : selector(jQuery);
return jQuery.makeArray(selector, this);
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/access.js">jquery/src/core/access.js</a>.</p>
</table>
<h3>Underscore.js (Core Proposal only)</h3>
<p><a href="http://underscorejs.org">Underscore.js</a> is another utility library very widely used since 2009,
providing numerous functions that manipulate arrays, objects, and other
functions. It too has a codebase that transforms values through many expressions
– a codebase whose readability would therefore benefit from smart pipelines.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">function (obj, pred, context) {
  return obj
  |&gt; isArrayLike
  |&gt; # ? _.findIndex : _.findKey
  |&gt; #(obj, pred, context)
  |&gt; (# !== void 0 &amp;&amp; # !== -1)
      ? obj[#] : undefined;
}
</code></pre>
<td>
<pre><code class="language-js">function (obj, pred, context) {
  var key;
  if (isArrayLike(obj)) {
    key = _.findIndex(obj, pred, context);
  } else {
    key = _.findKey(obj, pred, context);
  }
  if (key !== void 0 &amp;&amp; key !== -1)
    return obj[key];
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">function (obj, pred, context) {
  return pred
  |&gt; cb
  |&gt; _.negate
  |&gt; _.filter(obj, #, context);
}
</code></pre>
<td>
<pre><code class="language-js">function (obj, pred, context) {
  return _.filter(obj,
    _.negate(cb(pred)),
    context
  );
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">function (
  srcFn, boundFn, ctxt, callingCtxt, args
) {
  if (!(callingCtxt instanceof boundFn))
    return srcFn.apply(ctxt, args);
  var self = srcFn
  |&gt; #.prototype |&gt; baseCreate;
  return self
  |&gt; srcFn.apply(#, args)
  |&gt; _.isObject(#) ? # : self;
}
</code></pre>
<td>
<pre><code class="language-js">function (
  srcFn, boundFn,
  ctxt, callingCtxt, args
) {
  if (!(callingCtxt instanceof boundFn))
    return srcFn.apply(ctxt, args);
  var self = baseCreate(srcFn.prototype);
  var result = srcFn.apply(self, args);
  if (_.isObject(result)) return result;
  return self;
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">function (obj) {
  return obj |&gt; do {
    if (# == null)
      0;
    else if (|&gt; isArrayLike)
    |&gt; #.length;
    else
    |&gt; _.keys
    |&gt; #.length;
  };
}
</code></pre>
<p>Pipelines make parallelism between all three clauses becomes clearer: <code>0</code> for
the <code>if</code> clause, <code># |&gt; #.length</code> for the <code>else if</code>, and <code># |&gt; something |&gt; #.length</code>
for the <code>else</code>. <a href="#underscorejs-core-proposal--additional-feature-bppp">This particular example becomes even clearer</a> when paired with <a href="#additional-feature-bp">Additional Feature BP</a> and <a href="#additional-feature-pp">Additional
Feature PP</a>.</p>
<td>
<pre><code class="language-js">function (obj) {
  if (obj == null) return 0;
  return isArrayLike(obj)
    ? obj.length
    : _.keys(obj).length;
}
</code></pre>
</table>
<h3>Lodash (Core Proposal only)</h3>
<p><a href="https://lodash.com/">Lodash</a> is a fork of <a href="http://underscorejs.org">Underscore.js</a> that remains under rapid active
development. Along with Underscore.js’ other utility functions, Lodash provides
many other high-order functions that attempt to make <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a>
more ergonomic. Like <a href="https://jquery.com/">jQuery</a>, Lodash is under the stewardship of the
<a href="https://js.foundation/">JS Foundation</a>, a member organization of TC39, through which Lodash’s developers
also have TC39 representation. And like jQuery and Underscore.js, Lodash’s API
involves complex data processing that becomes more readable with smart pipelines.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">function hashGet (key) {
  return this.__data__
  |&gt; do {
      if (nativeCreate)
        #[key] |&gt; do {
          if (# !== HASH_UNDEFINED)
            #;
        };
      else if (hashOwnProperty.call(#, key))
        #[key];
    };
}
</code></pre>
<td>
<pre><code class="language-js">function hashGet (key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED
      ? undefined : result;
  }
  return hasOwnProperty.call(data, key)
    ? data[key] : undefined;
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">function listCacheHas (key) {
  return this.__data__
  |&gt; assocIndexOf(#, key)
  |&gt; # &gt; -1;
}
</code></pre>
<td>
<pre><code class="language-js">function listCacheHas (key) {
  return assocIndexOf(this.__data__, key)
    &gt; -1;
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">function mapCacheDelete (key) {
  return key
  |&gt; getMapData(this, #)
  |&gt; #['delete']
  |&gt; #(key)
  |&gt; do {
    this.size -= # ? 1 : 0;
    #
  };
}
</code></pre>
<td>
<pre><code class="language-js">function mapCacheDelete (key) {
  var result =
    getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">function castPath (value, object) {
  return value |&gt; do {
    if (# |&gt; isArray)
      #;
    else if (# |&gt; isKey(#, object))
      [#];
    else
      # |&gt; toString |&gt; stringToPath;
  };
}
</code></pre>
<td>
<pre><code class="language-js">function castPath (value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object)
    ? [value]
    : stringToPath(toString(value));
}
</code></pre>
</table>
<h2>Additional Feature BP</h2>
<p>In the <a href="#core-proposal">Core Proposal</a>, <a href="#do-expressions"><code>do</code> expressions</a> are permitted as
<a href="#topic-style">topic-style</a> pipeline bodies as long as they contain the topic
reference <code>#</code>. They might be so useful, in fact, that it might be worth building
them into the pipeline operator <code>|&gt;</code> itself.</p>
<p>This first Additional Feature – <strong>block pipelines</strong> – adds an additional
<a href="#smart-body-syntax">topic-style pipeline body syntax</a>, using blocks to stand for
<code>do</code> expressions.</p>
<p><a href="https://jschoi.org/18/es-smart-pipelines/spec#sec-additional-feature-bp">Additional Feature BP is <strong>formally specified in a separate draft
specification</strong></a>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; { sideEffect(); # }
|&gt; g
</code></pre>
<p>Instead of using <a href="#do-expressions"><code>do</code> expressions</a> (that is, <code>|&gt; do { sideEffect(); # }</code>), a
block body is used with the same meaning: <code>|&gt; { sideEffect(); # }</code>.</p>
<td>
<pre><code class="language-js">g (
  do {
    const $ = f(value);
    sideEffect();
    $
  }
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; {
    if (typeof # === 'number')
      # + 1;
    else
      { data: # };
  }
|&gt; g
</code></pre>
<td>
<pre><code class="language-js">g (
  do {
    const $ = f(value);
    if (typeof $ === 'number')
      $ + 1;
    else
      { data: $ };
  }
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; {
    try {
      JSON.parse($);
      catch (error) {
        { message: error.message }
      }
    }
  }
|&gt; g
</code></pre>
<p>This example becomes even pithier with <a href="#additional-feature-pp">Additional Feature PP</a> and <a href="#additional-feature-tc">Additional
Feature TC</a>.</p>
<td>
<pre><code class="language-js">g (
  do {
    const $ = f(value);
    try {
      JSON.parse(#);
      catch (error) {
        { message: error.message }
      }
    }
  }
)
</code></pre>
</table>
<h2>Additional Feature PP</h2>
<p>The next Additional Feature – <strong>Prefix Pipelines</strong> – adds a “headless” tacit
prefix form of the pipeline operator. The tacit, default head is the topic
reference <code>#</code> itself, which must be resolvable within the outer lexical
environment. This may occur within <code>if</code> statements, <code>try</code> statements, and <a href="#do-expressions"><code>do</code>
expressions</a>, as well as block pipeline bodies with <a href="#additional-feature-bp">Additional Feature BP</a>.</p>
<p><a href="https://jschoi.org/18/es-smart-pipelines/spec#sec-additional-feature-pp">Additional Feature PP is <strong>formally specified in a separate draft
specification</strong></a>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">x |&gt; {
  if (# |&gt; predicate)
    # |&gt; f |&gt; # ** 2;
  else
    # |&gt; g |&gt; # ** 3;
}
</code></pre>
<p>In this version, which uses Core Proposal syntax only, several pipelines start
with the phrase <code># |&gt;</code>.</p>
<td>
<pre><code class="language-js">do {
  if (predicate(x))
    f(x) ** 2;
  else
    g(x) ** 3;
}
</code></pre>
<p>Note that the topic reference in the repeated <code># |&gt;</code> here all refer to the same
topic from the same lexical environment – <code>x</code> – into <code>predicate</code>, <code>f</code>, and <code>g</code>.</p>
<tr>
<td>
<pre><code class="language-js">x |&gt; {
  if (|&gt; predicate)
  |&gt; f |&gt; # ** 2;
  else
  |&gt; g |&gt; # ** 3;
}
</code></pre>
<p>In this version, which also uses Additional Feature PP, those pipelines omit the
phrase <code># |&gt;</code>, using a tacit prefix pipeline <code>|&gt;</code>, which is implied to use <code>#</code>
as the value of their topics.</p>
<td>
<pre><code class="language-js">do {
  if (predicate(x))
    f(x) ** 2;
  else
    g(x) ** 3;
}
</code></pre>
<p>The unary pipeline <code>|&gt;</code> still piped in the same tacit topic from the same
lexical environment – <code>x</code> – into <code>predicate</code>, <code>f</code>, and <code>g</code>. The result is still
the same as before.</p>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; {
    try {
    |&gt; JSON.parse;
      catch (error) {
        { message: error.message }
      }
    }
  }
|&gt; g
</code></pre>
<p>This example becomes even pithier with <a href="#additional-feature-tc">Additional Feature TC</a>.</p>
<td>
<pre><code class="language-js">g (
  do {
    const $ = f(value);
    try {
      JSON.parse(#);
      catch (error) {
        { message: error.message }
      }
    }
  }
)
</code></pre>
<tr>
<td>
<pre><code class="language-js">function () {
|&gt; f |&gt; g
}
// 🚫 Syntax Error:
// Lexical context `function () { |&gt; f |&gt; g }`
// contains a prefix pipeline `|&gt; f`
// but has no topic binding.
</code></pre>
<p>If a prefix pipeline is used within a context in which the topic is not
resolvable, then this is an <a href="#static-early-errors">early error</a>, just like how it is an error to use
explicit topic references within a context without a topic in general:</p>
<pre><code class="language-js">function () {
  # |&gt; f |&gt; g
}
// 🚫 Syntax Error:
// Lexical context `function () { # |&gt; f |&gt; g }`
// contains a topic reference
// but has no topic binding.
</code></pre>
<td>
</table>
<h3>WHATWG Fetch Standard (Core Proposal + Additional Feature BP+PP)</h3>
<p>Revisiting the <a href="#whatwg-fetch-standard-core-proposal-only">examples above from the WHATWG Fetch Standard</a> with <a href="#additional-feature-bp">Additional Feature BP</a> and <a href="#additional-feature-pp">Additional Feature PP</a> shows how
terseness could be further improved.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">'https://pk.example/berlin-calling'
|&gt; await fetch(#, { mode: 'cors' })
|&gt; do {
    if (
      # |&gt; #.headers.get('content-type')
        |&gt; #??.toLowerCase()
        |&gt; #.indexOf('application/json')
        |&gt; # &gt;= 0
    )
      throw new new TypeError();
    else
      # |&gt; await #.json()
        |&gt; processJSON;
  }
}
</code></pre>
<p>This pipeline version uses <a href="#core-proposal">Core Proposal</a> syntax (plus <a href="#do-expressions"><code>do</code> expressions</a>)
only. Note that several expressions start with <code># |&gt;</code>. There is also a <code>|&gt; do { … }</code> block being used as a pipeline body.</p>
<td>
<pre><code class="language-js">fetch('https://pk.example/berlin-calling',
  { mode: 'cors' }
).then(response =&gt; {
  if (response.headers.get('content-type')
    ??.toLowerCase()
    .indexOf('application/json') &gt;= 0
  )
    return response.json();
  else
    throw new TypeError();
}).then(processJSON);
</code></pre>
<tr>
<td>
<pre><code class="language-js">'https://pk.example/berlin-calling'
|&gt; await fetch(#, { mode: 'cors' })
|&gt; {
    if (
    |&gt; #.headers.get('content-type')
    |&gt; #??.toLowerCase()
    |&gt; #.indexOf('application/json')
    |&gt; # &gt;= 0
    )
      throw new new TypeError();
    else
    |&gt; await #.json()
    |&gt; processJSON;
  }
}
</code></pre>
<p>This pipeline version also uses <a href="#additional-feature-bp">Additional Feature BP</a> and <a href="#additional-feature-pp">Additional
Feature PP</a>. The <code>|&gt; do { … }</code> has simply become <code>|&gt; { … }</code>. And the repeated
<code># |&gt;</code> has been elided, but it is still tacitly there.</p>
<td>
<pre><code class="language-js">fetch('https://pk.example/berlin-calling',
  { mode: 'cors' }
).then(response =&gt; {
  if (response.headers.get('content-type')
    ??.toLowerCase()
    .indexOf('application/json') &gt;= 0
  )
    return response.json();
  else
    throw new TypeError();
}).then(processJSON);
</code></pre>
</table>
<h3>jQuery (Core Proposal + Additional Feature BP+PP)</h3>
<p>Similarly, revisiting the <a href="#jquery-core-proposal-only">examples above from jQuery</a> with
<a href="#additional-feature-bp">Additional Feature BP</a> and <a href="#additional-feature-pp">Additional Feature PP</a> shows how terseness
could be further improved.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">match |&gt; do {
  if (this[match] |&gt; isFunction)
    # |&gt; context[#] |&gt; this[match](#);
  else
    # |&gt; context[#] |&gt; this.attr(match, #);
}
</code></pre>
<p>This pipeline version uses <a href="#core-proposal">Core Proposal</a> syntax (plus <a href="#do-expressions"><code>do</code> expressions</a>)
only. Note that several expressions start with <code># |&gt;</code>. There is also a <code>|&gt; do { … }</code> block being used as a pipeline body.</p>
<td>
<pre><code class="language-js">if (isFunction(this[match])) {
  this[match](context[match]);
} else
  this.attr(match, context[match]);
}
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/init.js">jquery/src/core/init.js</a>.</p>
<tr>
<td>
<pre><code class="language-js">match |&gt; {
  if (this[match] |&gt; isFunction)
  |&gt; context[#] |&gt; this[match](#);
  else
  |&gt; context[#] |&gt; this.attr(match, #);
}
</code></pre>
<p>This pipeline version also uses <a href="#additional-feature-bp">Additional Feature BP</a> and <a href="#additional-feature-pp">Additional
Feature PP</a>. The <code>|&gt; do { … }</code> has simply become <code>|&gt; { … }</code>. And the repeated
<code># |&gt;</code> has been elided, but it is still tacitly there.</p>
<td>
<pre><code class="language-js">if (isFunction(this[match])) {
  this[match](context[match]);
} else
  this.attr(match, context[match]);
}
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/init.js">jquery/src/core/init.js</a>.</p>
<tr>
<td>
<pre><code class="language-js">return context |&gt; do {
  // Handle HTML strings
  if (…)
    …
  // Handle $(expr, $(...))
  else if (!# || #.jquery)
    # |&gt; # || root
      |&gt; #.find(selector);
  // Handle $(expr, context)
  else
    # |&gt; this.constructor
      |&gt; #.find(selector);
};
</code></pre>
<p>This pipeline version uses <a href="#core-proposal">Core Proposal</a> syntax (plus <a href="#do-expressions"><code>do</code> expressions</a>)
only. Note that several expressions start with <code># |&gt;</code>. There is also a <code>|&gt; do { … }</code> block being used as a pipeline body.</p>
<td>
<pre><code class="language-js">// Handle HTML strings
if (…) {
  …
// Handle $(expr, $(...))
} else if (!context || context.jquery) {
  return (context || root).find(selector);
// Handle $(expr, context)
} else {
  return this.constructor(context)
    .find(selector);
}
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/init.js">jquery/src/core/init.js</a>.</p>
<tr>
<td>
<pre><code class="language-js">return context |&gt; {
  // Handle HTML strings
  if (…)
    …
  // Handle $(expr, $(...))
  else if (!# || #.jquery)
  |&gt; # || root
  |&gt; #.find(selector);
  // Handle $(expr, context)
  else
  |&gt; this.constructor
  |&gt; #.find(selector);
};
</code></pre>
<p>This pipeline version also uses <a href="#additional-feature-bp">Additional Feature BP</a> and <a href="#additional-feature-pp">Additional
Feature PP</a>. The <code>|&gt; do { … }</code> has simply become <code>|&gt; { … }</code>. And the repeated
<code># |&gt;</code> has been elided, but it is still tacitly there.</p>
<td>
<pre><code class="language-js">// Handle HTML strings
if (…) {
  …
// Handle $(expr, $(...))
} else if (!context || context.jquery) {
  return (context || root).find(selector);
// Handle $(expr, context)
} else {
  return this.constructor(context)
    .find(selector);
}
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/init.js">jquery/src/core/init.js</a>.</p>
<tr>
<td>
<pre><code class="language-js">return selector |&gt; do {
  if (typeof # === 'string')
    …
  else if (# |&gt; isFunction)
    root.ready !== undefined
      ? root.ready(#)
      : #(jQuery);
  else
    jQuery.makeArray(#, this);
}
</code></pre>
<p>This pipeline version uses <a href="#core-proposal">Core Proposal</a> syntax (plus <a href="#do-expressions"><code>do</code> expressions</a>)
only. Note that several expressions start with <code># |&gt;</code>. There is also a <code>|&gt; do { … }</code> block being used as a pipeline body.</p>
<td>
<pre><code class="language-js">if (typeof selector === 'string') {
  …
} else if (isFunction(selector)) {
  return root.ready !== undefined
    ? root.ready(selector)
    : selector(jQuery);
}
return jQuery.makeArray(selector, this);
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/access.js">jquery/src/core/access.js</a>.</p>
<tr>
<td>
<pre><code class="language-js">return selector |&gt; {
  if (typeof # === 'string')
    …
  else if (|&gt; isFunction)
    root.ready !== undefined
      ? root.ready(#)
      : #(jQuery);
  else
    jQuery.makeArray(#, this);
};
</code></pre>
<p>This pipeline version also uses <a href="#additional-feature-bp">Additional Feature BP</a> and <a href="#additional-feature-pp">Additional
Feature PP</a>. The <code>|&gt; do { … }</code> has simply become <code>|&gt; { … }</code>. And the repeated
<code># |&gt;</code> has been elided, but it is still tacitly there.</p>
<td>
<pre><code class="language-js">if (typeof selector === 'string') {
  …
} else if (isFunction(selector)) {
  return root.ready !== undefined
    ? root.ready(selector)
    : selector(jQuery);
}
return jQuery.makeArray(selector, this);
</code></pre>
<p>From <a href="https://github.com/jquery/jquery/blob/2.2-stable/src/core/access.js">jquery/src/core/access.js</a>.</p>
</table>
<h3>Underscore.js (Core Proposal + Additional Feature BP+PP)</h3>
<p>One of the <a href="#underscorejs-core-proposal-only">examples above from Underscore.js</a>
with <a href="#additional-feature-pp">Additional Feature PP</a> improves the visual parallelism of its code.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">function (obj) {
  return obj |&gt; do {
    if (# == null)
      0;
    else if (# |&gt; isArrayLike)
      # |&gt; #.length;
    else
      # |&gt; _.keys
        |&gt; #.length;
  };
}
</code></pre>
<p>Pipelines make parallelism between all three clauses becomes clearer.
This pipeline version uses <a href="#core-proposal">Core Proposal</a> syntax (plus <a href="#do-expressions"><code>do</code> expressions</a>)
only. Note that several expressions start with <code># |&gt;</code>. There is also a <code>|&gt; do { … }</code> block being used as a pipeline body.</p>
<td>
<pre><code class="language-js">function (obj) {
  if (obj == null) return 0;
  return isArrayLike(obj)
    ? obj.length
    : _.keys(obj).length;
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">function (obj) {
  return obj |&gt; {
    if (# == null)
      0;
    else if (|&gt; isArrayLike)
    |&gt; #.length;
    else
    |&gt; _.keys
    |&gt; #.length;
  };
}
</code></pre>
<p>By removing <code># |&gt;</code> noise, <a href="#additional-feature-pp">Additional Feature PP</a> makes this parallelism even
clearer: <code>0</code> for the <code>if</code> clause, <code>|&gt; #.length</code> for the <code>else if</code> clause, and
<code>|&gt; something |&gt; #.length</code> for the <code>else</code> clause. <a href="#additional-feature-bp">Additional Feature BP</a> also
makes the <code>do</code> unnecessary.</p>
<td>
<pre><code class="language-js">function (obj) {
  if (obj == null) return 0;
  return isArrayLike(obj)
    ? obj.length
    : _.keys(obj).length;
}
</code></pre>
<p>The behavior of the code remains the same. All tacit prefix pipelines <code>|&gt;</code> here
use the outer environment’s topic: <code>obj</code>.</p>
</table>
<h3>Lodash (Core Proposal + Additional Feature BP+PP)</h3>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">function hashGet (key) {
  return this.__data__ |&gt; do {
    if (nativeCreate)
      #[key] |&gt; {
        if # !== HASH_UNDEFINED
          #;
      };
    else if (hashOwnProperty.call(#, key))
      #[key];
    else
      undefined;
  };
}
</code></pre>
<p>This pipeline version uses <a href="#core-proposal">Core Proposal</a> syntax (plus <a href="#do-expressions"><code>do</code> expressions</a>)
only. Note that several expressions start with <code># |&gt;</code>. There is also a <code>|&gt; do { … }</code> block being used as a pipeline body.</p>
<td>
<pre><code class="language-js">function hashGet (key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED
      ? undefined : result;
  }
  return hasOwnProperty.call(data, key)
    ? data[key] : undefined;
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">function castPath (value, object) {
  return value |&gt; {
    if (|&gt; isArray)
      #;
    else if (|&gt; isKey(#, object))
      [#];
    else
    |&gt; toString |&gt; stringToPath;
  };
}
</code></pre>
<p>This pipeline version also uses <a href="#additional-feature-bp">Additional Feature BP</a> and <a href="#additional-feature-pp">Additional
Feature PP</a>. The <code>|&gt; do { … }</code> has simply become <code>|&gt; { … }</code>. And the repeated
<code># |&gt;</code> has been elided, but it is still tacitly there.</p>
<td>
<pre><code class="language-js">function castPath (value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object)
    ? [value]
    : stringToPath(toString(value));
}
</code></pre>
</table>
<h2>Additional Feature TC</h2>
<p>With the <a href="#core-proposal">Core Proposal</a> only, all <code>try</code> statements’ <code>catch</code> clauses would
prohibit the use of the topic reference <code>#</code> within their bodies, except where
the topic reference <code>#</code> is inside an inner pipeline inside the <code>catch</code> clause:
this is one of the Core Proposal’s <a href="#static-early-errors">early errors</a> mentioned above.</p>
<p>The next Additional Feature – <strong>Topical <code>catch</code>es</strong> – makes all <code>catch</code> clauses
implicitly bind their caught errors to the topic reference <code>#</code>. This implicit
binding would be in addition to the explicit binding of a normal variable
<code>error</code> declared within any parenthesized antecedent <code>(error)</code> in
<code>try { … } catch (error) { … }</code>.</p>
<p><a href="https://jschoi.org/18/es-smart-pipelines/spec#sec-additional-feature-tc">Additional Feature TC is <strong>formally specified in a separate draft
specification</strong></a>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">try {
  …
} catch {
  #.message |&gt; console.log
} finally {
  …
}
</code></pre>
<p>The second Additional Feature makes all <code>catch</code> clauses implicitly bind their
caught errors to the topic reference <code>#</code>.</p>
<p>An additional bare <code>catch</code> form, completely lacking a parenthesized antecedent,
has already been proposed as <a href="https://github.com/tc39/proposal-optional-catch-binding">ECMAScript optional catch binding</a>. This bare
form would also support the tacit topic binding.</p>
<td>
<pre><code class="language-js">try {
  …
} catch (error) {
  log(error.message)
} finally {
  …
}
</code></pre>
<p>The implicit topic binding would be in addition to the explicit binding of a
normal variable <code>error</code> declared within any parenthesized antecedent.</p>
<tr>
<td>
<pre><code class="language-js">value
|&gt; f
|&gt; {
    try {
    |&gt; JSON.parse;
      catch {
        { message: #.message }
      }
    }
  }
|&gt; g
</code></pre>
<td>
<pre><code class="language-js">g (
  do {
    const $ = f(value);
    try {
      JSON.parse(#);
      catch (error) {
        { message: error.message }
      }
    }
  }
)
</code></pre>
</table>
<h2>Additional Feature PF</h2>
<p>The third Additional Feature – <strong>Pipeline Functions</strong> – introduces a <strong>new
prefix operator <code>+&gt; …</code></strong>, which creates a new type of function, the <strong>pipeline
function</strong>. <code>+&gt; …</code> interprets its inner expression as a <strong>pipeline body</strong> but
wraps it in a <strong>unary arrow function</strong>, which plugs its single parameter into
the pipeline body as if it were a pipeline head. In other words, a pipeline
function would act as if it were <code>$ =&gt; $ |&gt; …</code>, where <code>$</code> is a hygienically
unique variable.</p>
<p>A pipe function takes <strong>no</strong> a parameter list; its unary parameter is implicitly
bound to the tacit pipeline head. And just like with regular pipelines, a
pipeline function may be in <strong><a href="#bare-style">bare style</a> or <a href="#topic-style">topic style</a></strong>.</p>
<p><strong>More than any other</strong> possible extension in this table, pipeline functions would
dramatically increase the potential of tacit programming. Just this single
additional operator seems to solve<br />
tacit unary <strong>functional composition</strong>,<br />
tacit unary functional <strong>partial application</strong>,<br />
and tacit <strong>method extraction</strong>,<br />
…all with a single additional concept.</p>
<p>With <a href="#additional-feature-np">Additional Feature NP</a>, this versatility would also solve<br />
tacit <strong>N-ary</strong> functional partial application<br />
and <strong>N-ary</strong> functional composition.</p>
<p><code>+&gt;</code> was chosen because of its similarity both to <code>|&gt;</code> and to <code>=&gt;</code>. The precise
appearance of the pipeline-function operator does not have to be <code>+&gt;</code>. It could
also be <code>~&gt;</code>, <code>-&gt;</code>, <code>=|</code>, <code>=|&gt;</code> or something else to be decided after future
bikeshedding discussion.</p>
<p><a href="https://jschoi.org/18/es-smart-pipelines/spec#sec-additional-feature-pf">Additional Feature PF is <strong>formally specified in a separate draft
specification</strong></a>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">array.map($ =&gt; $ |&gt; #)
</code></pre>
<pre><code class="language-js">array.map($ =&gt; $)
</code></pre>
<p>These functions are the same. They both pipe a unary parameter into a
topic-style pipeline whose bodies evaluate simply to the topic, unmodified.</p>
<td>
<pre><code class="language-js">array.map($ =&gt; $)
</code></pre>
<p>In other words, they are both <a href="https://en.wikipedia.org/wiki/Identity_function">identity function</a>s.</p>
<tr>
<td>
<pre><code class="language-js">array.map($ =&gt; $ |&gt; # + 2)
array.map(+&gt; # + 2)
</code></pre>
<p>These functions are also the same with each other. They both pipe a unary
parameter into a topic-style pipeline whose bodies are the topic plus two.</p>
<td>
<pre><code class="language-js">array.map($ =&gt; $ + 2)
</code></pre>
<tr>
<td>
<pre><code class="language-js">array.map($ =&gt; $ |&gt; f)
array.map(+&gt; f)
</code></pre>
<p>These functions are also the same as each other. However, their pipelines
are in <strong>bare mode</strong>, so no topic reference is needed in their bodies.</p>
<td>
<pre><code class="language-js">array.map($ =&gt; f($))
</code></pre>
<tr>
<td>
<pre><code class="language-js">array.map($ =&gt; $ |&gt; f |&gt; g |&gt; h |&gt; # * 2)
array.map(+&gt; f |&gt; g |&gt; h |&gt; # * 2)
</code></pre>
<p>Pipelines may be chained within a pipeline function. The prefix
pipeline-function operator <code>+&gt;</code> would have looser precedence than the infix
pipeline operator <code>|&gt;</code>.</p>
<td>
<pre><code class="language-js">array.map($ =&gt; h(g(f($))) * 2)
</code></pre>
<tr>
<td>
<pre><code class="language-js">array.map(+&gt; |&gt; f |&gt; g |&gt; h |&gt; # * 2)
array.map($ +&gt; # |&gt; f |&gt; g |&gt; h |&gt; # * 2)
array.map($ =&gt; $ |&gt; # |&gt; f |&gt; g |&gt; h |&gt; # * 2)
array.map($ =&gt; $ |&gt; f |&gt; g |&gt; h |&gt; # * 2)
array.map($ +&gt; f |&gt; g |&gt; h |&gt; # * 2)
</code></pre>
<p>When coupled with <a href="#additional-feature-pp">Additional Feature PP</a>, the phrase <code>+&gt; |&gt;</code> (that is,
prefix pipeline function <code>|=&gt;</code> immediately followed by prefix pipeline <code>|&gt;</code>)
cancels out into simply the prefix pipeline function <code>+&gt;</code>. All five of these
expressions here are equivalent.</p>
<td>
<pre><code class="language-js">array.map($ =&gt; h(g(f($))) * 2)
</code></pre>
<tr>
<td>
<pre><code class="language-js">+&gt; x + 2
// 🚫 Syntax Error:
// Pipeline body `+&gt; x + 2`
// binds topic but contains no topic reference.
</code></pre>
<p>This is an <a href="#static-early-errors">early error</a>, as usual. The topic is not used anywhere
in the pipeline function’s body – just like with <code>… |&gt; x + 2</code>.</p>
<td>
<tr>
<td>
<pre><code class="language-js">=&gt; # + 2
// 🚫 Syntax Error:
// Unexpected token `=&gt;`.
</code></pre>
<p>If the pipeline-function operator <code>+&gt;</code> is typoed as an arrow function <code>=&gt;</code>
instead, then this is another syntax error, because the arrow function <code>=&gt;</code>
expects to always have a parameter antecedent as its head.</p>
<td>
<tr>
<td>
<pre><code class="language-js">() =&gt; # + 2
// 🚫 Syntax Error:
// Lexical context `() =&gt; # + 2`
// contains a topic reference
// but has no topic binding.
</code></pre>
<p>But even if that typo also includes a parameter head for the arrow function
<code>=&gt;</code>, this is would still be an <a href="#static-early-errors">early error</a>…unless the outer lexical
environment does have its own topic binding.</p>
<td>
<tr>
<td>
<p><strong><a href="#terse-composition">Terse composition</a></strong> of unary functions is a goal of smart pipelines. It is
equivalent to piping a value through several function calls, within a unary
function, starting with the outer function’s tacit unary parameter.</p>
<pre><code class="language-js">array.map(+&gt; f |&gt; g |&gt; h(2, #) |&gt; # + 2)
</code></pre>
<p>There are <a href="#function-composition">several existing proposals for unary functional composition</a>, which Additional Feature PF would all subsume. And with
<a href="#additional-feature-np">Additional Feature NP</a>, even n-ary functional composition would be supported,
which no current proposal yet addresses.</p>
<td>
<pre><code class="language-js">array.map($ =&gt; h(2, g(f($))) + 2)
</code></pre>
<tr>
<td>
<pre><code class="language-js">const doubleThenSquareThenHalfAsync =
  async $ =&gt; $
    |&gt; double |&gt; await squareAsync |&gt; half
</code></pre>
<pre><code class="language-js">const doubleThenSquareThenHalfAsync =
  async +&gt; double |&gt; await squareAsync |&gt; half
</code></pre>
<p>When compared to the proposal for <a href="https://github.com/TheNavigateur/proposal-pipeline-operator-for-function-composition">syntactic functional composition by
TheNavigateur</a>, this syntax does not need
to give implicit special treatment to async functions. There is instead an async
version of the pipe-function operator, within which <code>await</code> may be used, simply
as usual.</p>
<td>
<pre><code class="language-js">const doubleThenSquareThenHalfAsync =
  async $ =&gt;
    half(await squareAsync(double($)))
</code></pre>
<pre><code class="language-js">const doubleThenSquareThenHalfAsync =
  double +&gt; squareAsync +&gt; half
</code></pre>
<p>From the proposal for <a href="https://github.com/TheNavigateur/proposal-pipeline-operator-for-function-composition">syntactic functional composition by
TheNavigateur</a>.</p>
<tr>
<td>
<pre><code class="language-js">const toSlug =
  $ =&gt; $
  |&gt; #.split(' ')
  |&gt; #.map($ =&gt; $.toLowerCase())
  |&gt; #.join('-')
  |&gt; encodeURIComponent
</code></pre>
<p>This example also uses <a href="#additional-feature-pp">Additional Feature PP</a> for its second line:</p>
<pre><code class="language-js">const toSlug = +&gt;
|&gt; #.split(' ')
|&gt; #.map(+&gt; #.toLowerCase())
|&gt; #.join('-')
|&gt; encodeURIComponent
</code></pre>
<p>When compared to the proposal for <a href="https://github.com/isiahmeadows/function-composition-proposal">syntactic functional composition by Isiah
Meadows</a>, this syntax does not need to
surround each non-function expression with an arrow function. The <a href="#smart-body-syntax">smart body
syntax</a> has more powerful <a href="#expressive-versatility">expressive versatility</a>, improving the
readability of the code.</p>
<td>
<pre><code class="language-js">const toSlug = $ =&gt;
  encodeURIComponent(
    $.split(' ')
      .map(str =&gt;
        str.toLowerCase())
      .join('-'))
</code></pre>
<pre><code class="language-js">const toSlug =
    _ =&gt; _.split(&quot; &quot;)
    :&gt; _ =&gt; _.map(str =&gt;
      str.toLowerCase())
    :&gt; _ =&gt; _.join(&quot;-&quot;)
    :&gt; encodeURIComponent
</code></pre>
<p>From the proposal for <a href="https://github.com/isiahmeadows/function-composition-proposal">syntactic functional composition by Isiah
Meadows</a>.</p>
<tr>
<td>
<pre><code class="language-js">const getTemperatureFromServerInLocalUnits =
  async +&gt;
  |&gt; await getTemperatureKelvinFromServerAsync
  |&gt; convertTemperatureKelvinToLocalUnits
</code></pre>
<p>Lifting of non-sync-function expressions into function expressions is
unnecessary for composition with Additional Feature PF.</p>
<td>
<pre><code class="language-js">Promise.prototype[Symbol.lift] =
  f =&gt; x =&gt; x.then(f)
const getTemperatureFromServerInLocalUnits =
  getTemperatureKelvinFromServerAsync
  :&gt; convertTemperatureKelvinToLocalUnits
</code></pre>
<p>From the proposal for <a href="https://github.com/isiahmeadows/function-composition-proposal">syntactic functional composition by Isiah
Meadows</a>.</p>
<tr>
<td>
<pre><code class="language-js">// Functional Building Blocks
const car = +&gt;
|&gt; startMotor
|&gt; useFuel
|&gt; turnKey;
const electricCar = +&gt;
|&gt; startMotor
|&gt; usePower
|&gt; turnKey;

// Control Flow Management
const getData = +&gt;
|&gt; truncate
|&gt; sort
|&gt; filter
|&gt; request;

// Argument Assignment
const sortBy = 'date';
const getData = +&gt;
  |&gt; truncate
  |&gt; sort
  |&gt; #::filter(sortBy)
  |&gt; request;
</code></pre>
<p>This example also uses <a href="#function-binding">function binding</a>.</p>
<td>
<pre><code class="language-js">// Functional Building Blocks
const car = startMotor.compose(
  useFuel, turnKey);
const electricCar = startMotor.compose(
  usePower, turnKey);

// Control Flow Management
const getData = truncate.compose(
  sort, filter, request);

// Argument Assignment
const sortBy = 'date';
const getData = truncate.compose(
  sort,
  $ =&gt; filter.bind($, sortBy),
  request);
</code></pre>
<p>From the proposal for <a href="https://github.com/simonstaton/Function.prototype.compose-TC39-Proposal">syntactic functional composition by Simon
Staton</a>.</p>
<tr>
<td>
<pre><code class="language-js">const pluck = +&gt; map |&gt; prop
</code></pre>
<td>
<pre><code class="language-js">const pluck = compose(map)(prop)
</code></pre>
<p>From a <a href="https://github.com/fantasyland/ECMAScript-proposals/issues/1#issuecomment-306243513">comment about syntactic functional composition by Tom Harding</a>.</p>
<tr>
<td>
<p><strong><a href="#terse-partial-application">Terse partial application</a> into a unary function</strong> is equivalent to piping
a tacit parameter into a function-call expression, within which the one
parameter is resolvable.</p>
<pre><code class="language-js">array.map($ =&gt; $ |&gt; f(2, #))
array.map(+&gt; f(2, #))
</code></pre>
<td>
<p>Pipeline functions look similar to the proposal for <a href="#partial-function-application">partial function
application</a> by <a href="https://github.com/rbuckton">Ron Buckton</a>, except that partial-application expressions
are simply pipeline bodies that are prefixed by the pipeline-function operator.</p>
<pre><code class="language-js">array.map(f(2, ?))
array.map($ =&gt; f(2, $))
</code></pre>
<tr>
<td>
<pre><code class="language-js">const addOne = +&gt; add(1, #)
addOne(2) // 3
</code></pre>
<td>
<pre><code class="language-js">const addOne = add(1, ?)
addOne(2) // 3
</code></pre>
<tr>
<td>
<pre><code class="language-js">const addTen = +&gt; add(#, 10)
addTen(2) // 12
</code></pre>
<td>
<pre><code class="language-js">const addTen = add(?, 10)
addTen(2) // 12
</code></pre>
<tr>
<td>
<pre><code class="language-js">let newScore = player.score
|&gt; add(7, #)
|&gt; clamp(0, 100, #)
</code></pre>
<td>
<pre><code class="language-js">let newScore = player.score
|&gt; add(7, ?)
|&gt; clamp(0, 100, ?)
</code></pre>
<tr>
<td>
<pre><code class="language-js">const toSlug = +&gt;
|&gt; encodeURIComponent
|&gt; _.split(#, &quot; &quot;)
|&gt; _.map(#, _.toLower)
|&gt; _.join(#, &quot;-&quot;)
</code></pre>
<p>Additional Feature PF simultaneously handles function composition and
partial application into unary functions.</p>
<td>
<pre><code class="language-js">const toSlug =
  encodeURIComponent
  :&gt; _.split(?, &quot; &quot;)
  :&gt; _.map(?, _.toLower)
  :&gt; _.join(?, &quot;-&quot;)
</code></pre>
<p>From the proposal for <a href="https://github.com/isiahmeadows/function-composition-proposal">syntactic functional composition by Isiah
Meadows</a>.</p>
<tr>
<td>
<p><strong>Method extraction</strong> can be addressed by pipeline functions alone, as a natural
result of their pipeline-operator-like semantics.<br />
<code>+&gt; console.log</code> is equivalent to <code>$ =&gt; $ |&gt; console.log</code>, which is a pipeline in
<a href="#bare-style">bare style</a>. This in turn is <code>$ =&gt; console.log($)</code>…</p>
<pre><code class="language-js">Promise.resolve(123)
  .then(+&gt; console.log)
</code></pre>
<td>
<p>…and <code>$ =&gt; console.log($)</code> is equivalent to <code>console.log.bind(console)</code>.</p>
<pre><code class="language-js">Promise.resolve(123)
  .then(console.log.bind(console))
Promise.resolve(123)
  .then(::console.log)
</code></pre>
<tr>
<td>
<pre><code class="language-js">$('.some-link').on('click', +&gt; view.reset)
</code></pre>
<td>
<pre><code class="language-js">$('.some-link').on('click', ::view.reset)
</code></pre>
<tr>
<td>
<pre><code class="language-js">const { hasOwnProperty } =
  Object.prototype
const x = { key: 5 }
x::hasOwnProperty
x::hasOwnProperty('key')
</code></pre>
<p>For terse <strong>method calling/binding</strong>, the infix <code>::</code> operator would still be
required.</p>
<td>
<pre><code class="language-js">const { hasOwnProperty } =
  Object.prototype
const x = { key: 5 }
x::hasOwnProperty
x::hasOwnProperty('key')
</code></pre>
<p>But the <code>::</code> operator would only need to handle method calls. No operator
overloading of <code>::</code> for method extraction (that is, <code>::</code> as a prefix operator)
would be needed.</p>
</table>
<h3>Ramda (Core Proposal + Additional Feature BP+PF)</h3>
<p><a href="http://ramdajs.com/">Ramda</a> is a utility library focused on <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> with <a href="https://en.wikipedia.org/wiki/Pure_function">pure
functions</a> and <a href="https://en.wikipedia.org/wiki/Immutable_object">immutable objects</a>. Its functions are automatically
<a href="https://en.wikipedia.org/wiki/Currying">curried</a>. Smart pipelines with <a href="#additional-feature-pf">Additional Feature PF</a>
would address many of Rambda’s use cases. The examples below were taken from the <a href="https://github.com/ramda/ramda/wiki/Cookbook">Ramda wiki
cookbook</a>. They use smart pipelines with vanilla JavaScript APIs when possible
(such as <code>Array.prototype.map</code> instead of <code>R.map</code>), but they also use Ramda
functions wherever no terse JavaScript equivalent yet exists (such as with
<code>R.zipWith</code> and <code>R.adjust</code>).</p>
<p><a href="#ramda-core-proposal--additional-features-bppfmt">Even more of Ramda’s use cases are covered</a> when
<a href="#additional-feature-np">Additional Feature NP</a> syntax is supported.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">const pickIndexes = +&gt; R.values |&gt; R.pickAll
['a', 'b', 'c'] |&gt; pickIndexes([0, 2], #)
// ['a', 'c']
</code></pre>
<td>
<pre><code class="language-js">const pickIndexes = R.compose(
  R.values, R.pickAll)
pickIndexes([0, 2], ['a', 'b', 'c'])
// ['a', 'c']
</code></pre>
<tr>
<td>
<pre><code class="language-js">const list = +&gt; [...]
list(1, 2, 3)
// [1, 2, 3]
</code></pre>
<td>
<pre><code class="language-js">const list = R.unapply(R.identity)
list(1, 2, 3)
// [1, 2, 3]
</code></pre>
<tr>
<td>
<pre><code class="language-js">const getNewTitles = async +&gt;
|&gt; await fetch
|&gt; parseJSON
|&gt; #.flatten()
|&gt; #.map(+&gt; #.items)
|&gt; #.map(+&gt; #.filter(+&gt; #))
|&gt; #.map(+&gt; #.title)

try {
  '/products.json'
  |&gt; getNewTitles
  |&gt; console.log
} catch {
|&gt; console.error
}

const fetchDependent = async +&gt;
|&gt; await fetch
|&gt; JSON.parse
|&gt; #.flatten()
|&gt; #.map(+&gt; #.url)
|&gt; #.map(fetch)
|&gt; #.flatten()

try {
  'urls.json'
  |&gt; fetchDependent
  |&gt; console.log
} catch {
|&gt; console.error
}
</code></pre>
<td>
<pre><code class="language-js">const getNewTitles = R.compose(
  R.map(R.pluck('title')),
  R.map(R.filter(R.prop('new'))),
  R.pluck('items'),
  R.chain(JSON.parse),
  fetch
)

getNewTitles('/products.json')
  .fork(console.error, console.log);

const fetchDependent = R.compose(
  R.chain(fetch),
  R.pluck('url'),
  R.chain(parseJSON),
  fetch
)

fetchDependent('urls.json')
  .fork(console.error, console.log)
</code></pre>
<tr>
<td>
<pre><code class="language-js">number
|&gt; R.repeat(Math.random, #)
|&gt; #.map(+&gt; #())
</code></pre>
<td>
<pre><code class="language-js">R.map(R.call,
  R.repeat(Math.random, number))
</code></pre>
<tr>
<td>
<pre><code class="language-js">const renameBy = (fn, obj) =&gt;
  [...obj]
  |&gt; #.map(R.adjust(fn, 0)),
  |&gt; {...#}
{ A: 1, B: 2, C: 3 }
|&gt; renameBy(+&gt; `a${#}`))
// { aA: 1, aB: 2, aC: 3 }
</code></pre>
<td>
<pre><code class="language-js">const renameBy = R.curry((fn, obj) =&gt;
  R.pipe(
    R.toPairs,
    R.map(R.adjust(fn, 0)),
    R.fromPairs
  )(obj)
)
renameBy(R.concat('a'), { A: 1, B: 2, C: 3 })
// { aA: 1, aB: 2, aC: 3 }
</code></pre>
</table>
<h3>WHATWG Streams Standard (Core Proposal + Additional Features BP+PP+PF)</h3>
<p>The <a href="https://stream.spec.whatwg.org/">WHATWG Streams Standard</a> provides an efficient, standardized stream API,
inspired by Node.js’s Streams API, but also applicable to the DOM. The
specification contains numerous usage examples that would become more readable
with smart pipelines. The Core Proposal alone would untangle much of this code,
and the Additional Features would further improve its terseness.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">class LipFuzzTransformer {
  constructor(substitutions) {
    this.substitutions = substitutions;
    this.partialChunk = &quot;&quot;;
    this.lastIndex = undefined;
  }

  transform (chunk, controller) {
    this.partialChunk = &quot;&quot;
    this.lastIndex = 0
    const partialAtEndRegexp =
      /\{(\{([a-zA-Z0-9_-]+(\})?)?)?$/g
    partialAtEndRegexp.lastIndex =
      this.lastIndex
    this.lastIndex = undefined
    chunk
    |&gt; this.partialChunk + #
    |&gt; #.replace(
        /\{\{([a-zA-Z0-9_-]+)\}\}/g,
        +&gt; this.replaceTag)
    |&gt; partialAtEndRegexp.exec
    |&gt; {
        if (#) {
          this.partialChunk =
          |&gt; #.index
          |&gt; chunk.substring;
          #
          |&gt; #.index
          |&gt; chunk.substring(0, #);
        }
        else
          chunk;
      }
    |&gt; controller.enqueue;
  }

  flush (controller) {
    this.partialChunk |&gt; {
      if (#.length &gt; 0) {
      |&gt; controller.enqueue;
      }
    };
  }

  replaceTag (match, p1, offset) {
    return this.substitutions
    |&gt; #[p1]
    |&gt; # === undefined ? '' : #
    |&gt; {
        this.lastIndex =
        |&gt; #.length
        |&gt; offset + #;
        #;
    };
  }
}
</code></pre>
<td>
<pre><code class="language-js">class LipFuzzTransformer {
  constructor (substitutions) {
    this.substitutions = substitutions;
    this.partialChunk = &quot;&quot;;
    this.lastIndex = undefined;
  }

  transform (chunk, controller) {
    chunk = this.partialChunk + chunk;
    this.partialChunk = &quot;&quot;;
    this.lastIndex = 0;
    chunk = chunk.replace(
      /\{\{([a-zA-Z0-9_-]+)\}\}/g,
      this.replaceTag.bind(this));
    const partialAtEndRegexp =
      /\{(\{([a-zA-Z0-9_-]+(\})?)?)?$/g;
    partialAtEndRegexp.lastIndex =
      this.lastIndex;
    this.lastIndex = undefined;
    const match =
      partialAtEndRegexp.exec(chunk);
    if (match) {
      this.partialChunk =
        chunk.substring(match.index);
      chunk =
        chunk.substring(0, match.index);
    }
    controller.enqueue(chunk);
  }

  flush (controller) {
    if (this.partialChunk.length &gt; 0) {
      controller.enqueue(
        this.partialChunk);
    }
  }

  replaceTag (match, p1, offset) {
    let replacement = this.substitutions[p1];
    if (replacement === undefined) {
      replacement = &quot;&quot;;
    }
    this.lastIndex =
      offset + replacement.length;
    return replacement;
  }
}
</code></pre>
</table>
<h2>Additional Feature NP</h2>
<p>Another Additional Feature – <strong>n-ary pipelines</strong> – enables the passing of
multiple arguments from each pipeline’s head into its body. <code>(a, b) |&gt; f</code> is
equivalent to <code>f(a, b)</code>.</p>
<p>For <a href="#topic-style">topic style</a>, Additional Feature NP introduces <strong>multiple lexical
topics</strong>: not only the <strong>primary</strong> topic reference <code>#</code>, but also <strong>secondary</strong>
<code>##</code>, <strong>tertiary</strong> <code>###</code>, and <strong>rest</strong> <code>...</code> <strong>topic references</strong>. It also
enables both <strong>n-ary application</strong> and <strong>n-ary partial application</strong>.
This is somewhat akin to <a href="https://clojure.org/reference/reader#_dispatch">Clojure’s compact anonymous functions</a>, which use <code>%</code> aka <code>%1</code>, then <code>%2</code>, <code>%3</code>, … for its parameters within
the compact functions’ bodies.</p>
<p>This explainer limits this Additional Feature to three topic references plus a
rest topic reference. This limit could theoretically be lifted, but readability
would rapidly suffer with five, six, seven different topics at once. Arrow
functions could always be used instead for such many-parameter functions.<br />
The precise appearances of the secondary, tertiary, and rest topic references do
not have to be <code>##</code>, <code>###</code>, and <code>...</code>. For instance, they could instead be <code>#1</code>,
<code>#2</code>, and <code>#...</code>; this is yet to be bikeshedded.</p>
<p><a href="https://jschoi.org/18/es-smart-pipelines/spec#sec-additional-feature-np">Additional Feature NP is <strong>formally specified in a separate draft
specification</strong></a>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">(a, b)
|&gt; f
</code></pre>
<p>Pipeline heads would become reinterpreted as argument lists, which would then be
applied to the pipeline bodies.</p>
<td>
<pre><code class="language-js">f(a, b)
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, b, ...c, d)
|&gt; f
</code></pre>
<p>Spread elements are permitted within pipeline heads, with the same meaning as in
regular argument lists.</p>
<td>
<pre><code class="language-js">f(a, b, ...c, d)
</code></pre>
<tr>
<td>
<pre><code class="language-js">...a
|&gt; f
</code></pre>
<p>When a pipeline head only consists of one item, its parentheses may be omitted,
which is the usual syntax from the <a href="#core-proposal">Core Proposal</a>. But this now goes for
spread elements too.</p>
<td>
<pre><code class="language-js">f(...a)
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, b)
|&gt; f(#, x, ##)
</code></pre>
<p>When a pipeline’s body is in <a href="#topic-style">topic style</a>, the first element in the argument
list is bound to the primary topic reference <code>#</code>, the second element is bound to
the secondary topic reference <code>##</code>, and the third element is bound to the
tertiary topic reference <code>###</code>. These are resolvable as usual within the
pipeline body.</p>
<td>
<pre><code class="language-js">f(a, x, b)
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, b, ...c, d)
|&gt; f(#, x, ...)
</code></pre>
<p>The pipeline also binds an array to a rest topic reference <code>...</code> within the
pipeline body. The array contains the arguments of the pipeline head that were
not bound to any other topic reference.</p>
<td>
<pre><code class="language-js">f(a, x, ...[b, ...c, d])
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, b, c, d, e)
|&gt; f(##, x, ...)
</code></pre>
<p>The rest topic reference <code>...</code> starts from beyond the furthest topic reference
that is used within the pipeline body. Here, the furthest topic reference is the
secondary topic reference <code>##</code>: the second argument item. So <code>[c, d, e]</code> is
bound to the rest topic reference. The rest topic reference <code>...</code> may only be
used where the spread operator <code>...expression</code> would also be valid (that is,
argument lists, array literals, and object literals), and it automatically
spreads its elements into whatever expression surrounds it.</p>
<td>
<pre><code class="language-js">do {
  const [_tertiary, ..._rest] = [c, d, e];
  f(a, _secondary, x, ..._rest)
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, b, c, ...d, e)
|&gt; f(#, ###, x, ...)
</code></pre>
<p>Here, the furthest topic reference is the tertiary topic reference <code>###</code>: the
third argument item. So only the rest topic reference <code>...</code> contains <code>d</code>’s
spread elements as well as <code>e</code>. The second argument, <code>b</code>, is skipped entirely,
because <code>##</code> is not used at all in the pipeline body.</p>
<td>
<pre><code class="language-js">do {
  const _rest = [...d, e];
  f(a, _tertiary, x, ..._rest)
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, ...b, c, ...d, e)
|&gt; f(#, ##, ###, x, ...)
</code></pre>
<td>
<pre><code class="language-js">do {
  const [_secondary, _tertiary, ..._rest] =
    [...b, c, ...d, e];
  f(a, _secondary, _tertiary, x, ..._rest)
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, ...b, c, ...d, e)
|&gt; f(#, ##, x, ...)
</code></pre>
<td>
<pre><code class="language-js">do {
  const [_secondary, ..._rest] =
    [...b, c, ...d, e];
  f(a, _secondary, x, ..._rest)
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, b)
|&gt; # - ##
</code></pre>
<td>
<pre><code class="language-js">a - b
</code></pre>
<tr>
<td>
<p>N-ary pipelines may be chained by using comma expressions to make their pipeline
bodies also n-ary.</p>
<pre><code class="language-js">(a, b)
|&gt; (f, g)
|&gt; h
</code></pre>
<p>Each element in an N-ary pipeline body is independently applied to each
consecutive argument from the pipeline head.</p>
<td>
<pre><code class="language-js">h(f(a), g(b))
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, b)
|&gt; (f, # ** c + ##)
|&gt; # - ##
</code></pre>
<p>The elements in an N-ary pipeline body may be either in bare style (like the <code>f</code>
here) or in topic style (like the <code># ** c + ##</code> here).</p>
<td>
<pre><code class="language-js">f(a) - (a ** c + b)
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, b)
|&gt; (f, g)
|&gt; h
|&gt; (i, # + 1, k)
|&gt; l
</code></pre>
<td>
<pre><code class="language-js">do {
  const $ = h(f(a), g(b));
  l(i($), $ + 1, k($))
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">(a, b)
|&gt; (f, g)
|&gt; (h, i)
// 🚫 Syntax Error:
// A pipeline chain terminates
// with a 2-ary pipeline body
// but must terminate with a
// unary pipeline body.
</code></pre>
<p>It is an <a href="#static-early-errors">early error</a> for a pipeline head to end with an n-ary pipeline body,
where n &gt; 1. Such a comma expression would almost certainly be an accidental
mistake by the developer.</p>
<td>
<tr>
<td>
<pre><code class="language-js">value
|&gt; (f, g)
|&gt; (x, y) =&gt; # * x + ## * y
|&gt; settimeout
// 🚫 Syntax Error:
// Unexpected token `=&gt;`.
// Cannot parse base expression.
</code></pre>
<p>Because arrow functions have looser precedence than the pipeline operator <code>|&gt;</code>,
it is never ambiguous with the parenthesized-list syntax for N-ary pipelines.
The above invalid code is being interpreted as if it were the below:</p>
<pre><code class="language-js">(value |&gt; (f, g) |&gt; (x, y)) =&gt;
  (# * 5 |&gt; settimeout)
// 🚫 Syntax Error:
// Unexpected token `=&gt;`.
// Cannot parse base expression.
</code></pre>
<p>The arrow function must be parenthesized, simply as with any other
looser-precedence expression:</p>
<pre><code class="language-js">value
|&gt; (f, g)
|&gt; ((x, y) =&gt; # * x + ## * y)
|&gt; settimeout
</code></pre>
<td>
<tr>
<td>
<pre><code class="language-js">number
|&gt; ...createRange
|&gt; [#, ###, ...]
</code></pre>
<p>As a result of these rules, <code>|&gt; ... |&gt;</code> collects the previous</p>
<td>
<pre><code class="language-js">do {
  const [_primary, , _tertiary, ..._rest] =
    createRange(number);
  [_primary, _tertiary, _rest]
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">x
|&gt; (f, ...g, h)
|&gt; [...].length
</code></pre>
<p>As a result of the rules, <code>|&gt; [...]</code> collects its pipeline head’s n-ary
arguments into a single flattened array, to which the rest topic reference <code>...</code>
is then bound.</p>
<td>
<pre><code class="language-js">[f(x), ...g(x), h(x)].length
</code></pre>
<tr>
<td>
<pre><code class="language-js">array.sort(+&gt; # - ##)
</code></pre>
<p>Additional Feature NP, when coupled with <a href="#additional-feature-pf">Additional Feature PF</a>, would
enable very terse callback functions.</p>
<td>
<pre><code class="language-js">array.sort((_0, _1) =&gt; _0 - _1)
</code></pre>
<tr>
<td>
<pre><code class="language-js">[ { x: 22 }, { x: 42 } ]
  .map(+&gt; #.x)
  .reduce(+&gt; # - ##, 0)
</code></pre>
<td>
<pre><code class="language-js">[ { x: 22 }, { x: 42 } ]
  .map(el =&gt; el.x)
  .reduce((_0, _1) =&gt; _0 - _1, 0)
</code></pre>
<tr>
<td>
<pre><code class="language-js">const f = (x, y, z) =&gt; [x, y, z]
const g = +&gt; f(#, 4, ##)
g(1, 2) // [1, 4, 2]
</code></pre>
<p>Additional Feature NP, when coupled with <a href="#additional-feature-pf">Additional Feature PF</a>, would also
solve <strong>partial application into n-ary functions</strong>. (Additional Feature PF would
only address partial application into unary functions.)</p>
<td>
<pre><code class="language-js">const f = (x, y, z) =&gt; [x, y, z]
const g = f(?, 4, ?)
g(1, 2) // [1, 4, 2]
</code></pre>
<p>The current proposal for <a href="#partial-function-application">partial function application</a> assumes that each use
of the same <code>?</code> placeholder token represents a different parameter. In contrast,
each use of <code>#</code> within the same scope always refers to the same value. This is
why additional topic parameters are required.</p>
<tr>
<td>
<p>The resulting model is more flexible: with Additional Feature NP with
<a href="#additional-feature-pf">Additional Feature PF</a>, <code>+&gt; f(#, 4, ##)</code> is different from <code>+&gt; f(#, 4, #)</code>.
The former refers to a <strong>binary</strong> function: a function with two parameters,
essentially <code>(x, y) =&gt; f(x, 4, y)</code>. The latter refers to a <strong>unary</strong> function
that passes the same one argument into both the first and third parameters of
the original function <code>f</code>: <code>x =&gt; f(x, 4, x)</code>. The same symbol refers to the same
value in the same lexical environment.</p>
<tr>
<td>
<pre><code class="language-js">const maxGreaterThanZero =
  +&gt; Math.max(0, ...)
maxGreaterThanZero(1, 2) // 2
maxGreaterThanZero(-1, -2) // 0
</code></pre>
<p>Partial application into a variadic function is also naturally handled by
Additional Feature NP with <a href="#additional-feature-pf">Additional Feature PF</a>.</p>
<td>
<pre><code class="language-js">const maxGreaterThanZero =
  Math.max(0, ...)
maxGreaterThanZero(1, 2) // 2
maxGreaterThanZero(-1, -2) // 0
</code></pre>
<p>In this case, the topic function version looks once again nearly identical to
the other proposal’s code.</p>
</table>
<h3>Lodash (Core Proposal + Additional Features BP+PP+PF+NP)</h3>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">function createRound (methodName) {
  var func = Math[methodName];
  return function (number, precision) {
    number = number |&gt; toNumber;
    precision = precision |&gt; {
      if (# == null)
        0;
      else
      |&gt; toInteger |&gt; nativeMin(#, 292);
    }
    return number |&gt; {
      if (precision)
        // Shift with exponential notation
        // to avoid floating-point issues.
        // See https://mdn.io/round#Examples.
      |&gt; `${#}e`
      |&gt; ...#.split('e')
      |&gt; `${#}e${+## + precision}`
      |&gt; func
      |&gt; `${#}e`
      |&gt; ...#.split('e')
      |&gt; `${#}e${+## - precision}`
      |&gt; +#;
      else
      |&gt; func;
    };
  };
}
</code></pre>
<p>The parallelism between the <code>if</code> clause’s <code>|&gt; shift |&gt; func |&gt; shiftBack</code> and
the <code>else</code> clause’s <code>|&gt; func</code> becomes visually clearer with smart pipelines.</p>
<td>
<pre><code class="language-js">function createRound (methodName) {
  var func = Math[methodName];
  return function (number, precision) {
    number = toNumber(number)
    precision = precision == null
      ? 0
      : nativeMin(toInteger(precision), 292)
    if (precision) {
      // Shift with exponential notation
      // to avoid floating-point issues.
      // See https://mdn.io/round#Examples.
      var
        pair = (toString(number) + 'e')
          .split('e'),
        value = func(
          pair[0] + 'e' + (
            +pair[1] + precision));

      pair = (toString(value) + 'e')
        .split('e');
      return +(
        pair[0] + 'e' + (
          +pair[1] - precision));
    }
    return func(number);
  }
}

</code></pre>
</table>
<h3>Ramda (Core Proposal + Additional Features BP+PF+NP)</h3>
<p><a href="#ramda-core-proposal--additional-feature-bppf">Many examples above using Ramda</a> benefited from pipeline
functions with Additional Feature PF. Even more use cases are covered by
pipeline functions when <a href="#additional-feature-np">Additional Feature NP</a> syntax is supported.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">const cssQuery = +&gt; ##.querySelectorAll(#)
const setStyle = +&gt; { ##.style = # }
document
|&gt; cssQuery('a, p', #)
|&gt; #.map(+&gt; setStyle({ color: 'red' }))
</code></pre>
<td>
<pre><code class="language-js">const cssQuery = R.invoker(1,
  'querySelectorAll')
const setStyle = R.assoc('style')
R.pipe(
  cssQuery('a, p'),
  R.map(setStyle({ color: 'red' }))
)(document)
</code></pre>
<tr>
<td>
<pre><code class="language-js">const disco = +&gt;
|&gt; R.zipWith(+&gt; #(##),
    [ red, green, blue ])
|&gt; #.join(' ')
[ 'foo', 'bar', 'xyz' ]
|&gt; disco
|&gt; console.log
</code></pre>
<td>
<pre><code class="language-js">const disco = R.pipe(
  R.zipWith(
    R.call,
    [ red, green, blue ]),
  R.join(' ')
)
console.log(
  disco([ 'foo', 'bar', 'xyz' ]))
</code></pre>
<tr>
<td>
<pre><code class="language-js">const dotPath = +&gt;
|&gt; (#.split('.'), ##)
|&gt; R.path(#, ##)
const propsDotPath = +&gt;
|&gt; (R.map(dotPath), [##])
|&gt; R.ap
const obj = {
  a: { b: { c: 1 } },
  x: 2
}
propsDotPath(['a.b.c', 'x'], obj)
// [ 1, 2 ]
</code></pre>
<td>
<pre><code class="language-js">const dotPath = R.useWith(
  R.path,
  [R.split('.')])
const propsDotPath = R.useWith(
  R.ap,
  [R.map(dotPath), R.of])
const obj = {
  a: { b: { c: 1 } },
  x: 2
}
propsDotPath(['a.b.c', 'x'], obj)
// [ 1, 2 ]
</code></pre>
</table>
<h3>WHATWG Streams Standard (Core Proposal + Additional Features BP+PP+PF+NP)</h3>
<p><a href="#whatwg-streams-standard-core-proposal--additional-feature-bppf">Many examples above using WHATWG Streams</a>
benefited from pipeline functions with Additional Features CP + PF. Even more
use cases are covered by pipeline functions with <a href="#additional-feature-np">Additional Feature NP</a>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<pre><code class="language-js">try {
  readableStream
  |&gt; await #.pipeTo(writableStream);
  &quot;Success&quot;
  |&gt; console.log
} catch {
  (&quot;Error&quot;, #)
  |&gt; console.error
}
</code></pre>
<td>
<pre><code class="language-js">readableStream.pipeTo(writableStream)
  .then(() =&gt; console.log(&quot;Success&quot;))
  .catch(e =&gt; console.error(&quot;Error&quot;, e))
</code></pre>
<tr>
<td>
<pre><code class="language-js">const reader = readableStream
  .getReader({ mode: &quot;byob&quot; })

try {
  new ArrayBuffer(1024)
  |&gt; await readInto
  |&gt; (&quot;The first 1024 bytes:&quot;, #)
  |&gt; console.log
} catch {
  (&quot;Something went wrong!&quot;, #)
  |&gt; console.error
}

async function readInto(buffer, offset = 0) {
  return buffer |&gt; {
    if (#.byteLength === offset)
      #;
    else
    |&gt; (#, offset, #.byteLength - offset)
    |&gt; new Uint8Array
    |&gt; await reader.read
    |&gt; (#.buffer, #.byteLength)
    |&gt; readInto(#, offset + ##);
  };
}
</code></pre>
<td>
<pre><code class="language-js">const reader = readableStream
  .getReader({ mode: &quot;byob&quot; })

let startingAB = new ArrayBuffer(1024)
readInto(startingAB)
  .then(buffer =&gt;
    console.log(&quot;The first 1024 bytes:&quot;, buffer))
  .catch(e =&gt;
    console.error(&quot;Something went wrong!&quot;, e))

function readInto(buffer, offset = 0) {
  if (offset === buffer.byteLength) {
    return Promise.resolve(buffer);
  }
  const view = new Uint8Array(
    buffer, offset, buffer.byteLength - offset)
  return reader.read(view).then(newView =&gt; {
    return readInto(newView.buffer,
      offset + newView.byteLength);
  });
}
</code></pre>
</table>
<h2>Additional Feature TF</h2>
<p>With the <a href="#core-proposal">Core Proposal</a> only, <code>for</code>–<code>of</code> statements would prohibit the use
of <code>#</code> within their bodies, except where <code>#</code> is inside an inner pipeline inside
the <code>for</code> loop. But this could be changed afterward with Additional Feature TF –
<strong>Topical <code>for</code>s</strong> – which would cause <code>for</code> loops to bind the topic to useful
values, which in turn would make <code>for</code> loops terser, emphasizing what happens to
each item rather than the items’ variables themselves.</p>
<p><a href="https://jschoi.org/18/es-smart-pipelines/spec#sec-additional-feature-tf">Additional Feature TF is <strong>formally specified in a separate draft
specification</strong></a>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Status quo
<tbody>
<tr>
<td>
<p>With Additional Feature FT, all <code>for</code>–<code>of</code> loops would implicitly bind each
iterator value to <code>#</code>. This implicit binding would be in addition to the
explicit binding of a normal variable <code>i</code> declared within the parenthesized
antecedent <code>for (const i of … { … })</code>.</p>
<pre><code class="language-js">for (range(0, 50)) {
  log(# ** 2);
  log(|&gt; Math.sqrt);
}
</code></pre>
<p>An additional tacit <code>for</code> loop form, completely lacking a parenthesized
antecedent, would also be added. This example uses that tacit form, along with
<a href="#additional-feature-pp">Additional Feature PP</a>.</p>
<td>
<pre><code class="language-js">for (const i of range(0, 50)) {
  log(i ** 2);
  log(Math.sqrt(i));
}
</code></pre>
<tr>
<td>
<p>Similar additions would be made to the asynchronous <code>for</code> loop. All
<code>for</code>–<code>await</code>–<code>of</code> loops would implicitly bind each iterator value to <code>#</code>. This
implicit binding would be in addition to the explicit binding of a normal
variable <code>i</code> declared within the parenthesized antecedent
<code>for await (const i of …) { … }</code>.</p>
<pre><code class="language-js">for await (stream) {
  yield |&gt;
  |&gt; await f
  |&gt; #.length
  |&gt; # + 3
  |&gt; g
}
</code></pre>
<p>An additional tacit <code>for await</code> loop form, completely lacking a parenthesized
antecedent, would also be added. Note that in this case, a <code>|&gt;</code> (or a <code>#</code>) must
be included after <code>yield</code> because – as usual – a newline after a <code>yield</code> causes
<a href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion">automatic semicolon insertion</a> after the <code>yield</code>.</p>
<td>
<pre><code class="language-js">for await (const c of stream) {
  yield g(
    (await f(c))
      .length
      + 3
  )
}
</code></pre>
</table>
<h1>Goals</h1>
<p>There are sixteen ordered goals that the smart body syntax tries to fulfill,
which may be summarized,<br>
“Don’t break my code,”<br>
“Don’t make me overthink,”<br>
“Don’t shoot me in the foot,”<br>
“Make my code easier to read,”<br>
and a few other goals.</p>
<table>
<tr>
<td>
<p><strong>“Don’t break my code.”</strong></p>
<ol>
<li><a href="#backward-compatibility">Backward compatibility</a></li>
<li><a href="#zero-runtime-cost">Zero runtime cost</a></li>
<li><a href="#forward-compatibility">Forward compatibility</a></li>
</ol>
<td>
<p><strong>“Don’t make me overthink.”</strong></p>
<ol start="4">
<li><a href="#syntactic-locality">Syntactic locality</a></li>
<li><a href="#expressive-versatility">Expressive versatility</a></li>
<li><a href="#cyclomatic-simplicity">Cyclomatic simplicity</a></li>
</ol>
<td>
<p><strong>“Don’t shoot me in the foot.”</strong></p>
<ol start="7">
<li><a href="#simple-scoping">Simple scoping</a></li>
<li><a href="#static-analyzability">Static analyzability</a></li>
</ol>
<tr>
<td>
<p><strong>“Make my code easier to read.”</strong></p>
<ol start="9">
<li><a href="#untangled-flow">Untangled flow</a></li>
<li><a href="#distinguishability">Distinguishability</a></li>
<li><a href="#terse-parentheses">Terse parentheses</a></li>
<li><a href="#terse-variables">Terse variables</a></li>
<li><a href="#terse-function-calls">Terse function calls</a></li>
</ol>
<td>
<p><strong>Other</strong></p>
<ol start="14">
<li><a href="#conceptual-generality">Conceptual generality</a></li>
<li><a href="#human-writability">Human writability</a></li>
<li><a href="#novice-learnability">Novice learnability</a></li>
</ol>
</table>
<h2>“Don’t break my code.”</h2>
<p>The syntax should not break any existing code; it should also be forward
compatible with future code.</p>
<h3>Backward compatibility</h3>
<p>The syntax must avoid stepping on the toes of existing code, including but not
limited to JavaScript libraries such as <a href="https://jquery.com/">jQuery</a> and <a href="https://lodash.com/">Lodash</a>. In particular,
the topic reference should not be an existing identifier such as <code>$</code> or <code>_</code>,
which both may cause surprising results to a developer who adopts pipelines
while also using a globally bound convenience variable. It is a common pattern
to do this even without a library: <code>var $ = document.querySelectorAll</code>”. The
silent shadowing of such outer-context variables may silently cause bugs, which
may also be difficult to debug (see <a href="#expressive-versatility">Expressive Versatility</a>).</p>
<p>Nor can it cause previously valid code to become invalid. This includes, to a
lesser extent, common nonstandard extensions to JavaScript: for instance, using
<code>&lt;&gt;</code> for the topic reference would retroactively invalidate existing E4X and JSX
code.</p>
<p>This proposal uses <code>#</code> for its topic reference. This is compatible with all
known previous JavaScript code. <code>?</code> and <code>@</code> could be chosen instead, which are
each also backwards compatible.</p>
<h3>Zero runtime cost</h3>
<p>This could be considered a specific type of backward compatibility. When
translating old code into the new syntax, doing so should not cause unexpected
performance regression. For instance, the new syntax should not require memory
allocation for newly created functions that were not necessary in the old code.
Instead, it should, at least theoretically, perform as well the old code did for
both memory and CPU. And it should be able to do this without dramatically
rearranging code logic or relying on hidden, uncontrollable compiler
optimization.</p>
<p>For instance, in order to apply the syntax to the logic of an async functions, a
hypothetical new pipeline syntax might not support using <code>await</code> in the same
async context as the pipeline itself. Such a syntax would, for each of its
pipelines’ steps, require inner async functions that would return wrapper
promises and pass them between consecutive steps. Such an approach would be be
unnecessarily expensive to naively evaluate for both CPU and memory. But
inlining these async functions may be internally complicated, and such
optimizations would be difficult for the developer to correctly predict and
might differ widely between JavaScript engines.</p>
<p>Instead, this proposal’s use of a topic reference enables the zero-cost
rewriting of any expression within the current environmental context, including
<code>await</code> operations in async functions, without having to create unnecessary
inner async functions, and without having to wrap values in unnecessary promises.</p>
<h3>Forward compatibility</h3>
<p>The syntax should not preclude other proposals: both <a href="#other-ecmascript-proposals">already-proposed
ECMAScript proposals</a>, such as <a href="#partial-function-application">partial function
application</a> and <a href="https://github.com/tc39/proposal-class-fields/">private class fields</a> – as well as the <a href="#smart-pipelines">Additional
Features</a> of this proposal. The Core Proposal is forward compatible with
all of these, especially because of its <a href="#static-early-errors">early errors</a>.</p>
<h2>“Don’t shoot me in the foot.”</h2>
<p>The syntax should not be a footgun: it should not easy for a developer to
accidentally shoot themselves in the foot with it.</p>
<h3>Simple scoping</h3>
<p>It should not be easy to accidentally shadow a reference from an outer lexical
scope. When the developer does so, any use of that reference could result in
subtle, pernicious bugs.</p>
<p>The rules for when the topic is bound should be simple and consistent. It should
be clear and obvious when a topic is bound and in what scope it exists. And
forgetting these rules should result in early, compile-time errors, not subtle
runtime bugs.</p>
<p>The rules of topic scoping is simple: <strong>Topic references are bound in the bodies
of pipelines, and they cannot be used within any block other than arrow
functions.</strong> See the section on <a href="#inner-blocks">inner blocks</a>.</p>
<h3>Static analyzability</h3>
<p><a href="#static-early-errors">Early errors</a> help the editing JavaScript developer avoid common <a href="https://en.wiktionary.org/wiki/footgun">footguns</a>
at compile time, such as preventing them from accidentally omitting a topic
reference where they meant to put one. For instance, if <code>x |&gt; 3</code> were not an
error, then it would be a useless operation and almost certainly not what the
developer intended. Situations like these should be statically detectable and
cause compile-time <a href="#static-early-errors">early errors</a>.</p>
<p>The same preference for strict early errors is used by the class decorators
proposal: see <a href="tc39/proposal-decorators#30">tc39/proposal-decorators#30</a>, <a href="tc39/proposal-decorators#42">tc39/proposal-decorators#42</a>,
and <a href="tc39/proposal-decorators#60">tc39/proposal-decorators#60</a>. Early errors also assist with <a href="#forward-compatibility">forward
compatibility</a>, as changing a behavior from “throws” to “does something” is
generally web compatible, though the reverse is not true.</p>
<h2>“Don’t make me overthink.”</h2>
<p>The syntax should not make a developer overthink about the syntax, rather than
their product.</p>
<h3>Syntactic locality</h3>
<p>The syntax should minimize the parsing lookahead that the compiler must check.
If the grammar makes <a href="https://en.wikipedia.org/wiki/Garden_path_sentence">garden-path syntax</a> common, then this increases the
dependency that pieces of code have on other code. This long lookahead in turn
makes it more likely that the code will exhibit developer-unintended behavior.</p>
<p>This is true particularly for <a href="#smart-body-syntax">distinguishing between different styles of
pipeline body syntax</a>. A pipeline’s meaning would often be
ambiguous between these styles – at least without checking the pipeline’s body
carefully to see in which style it is written. And the pipeline body may be a
very long expression.</p>
<p>By restricting the space of valid bare-style pipeline bodies (that is, without
topic references), the rule minimizes garden-path syntax that would otherwise be
possible – such as <code>value |&gt; compose(f, g, h, i, j, k, #)</code>. Syntax becomes more
locally readable. It becomes easier to reason about code without thinking about
code elsewhere.</p>
<h3>Expressive versatility</h3>
<p>JavaScript is a language rich with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">expressions of numerous kinds</a>, each of which may usefully transform data from one
form to another. There is <strong>no single type</strong> of expression that forms a
<strong>majority of used expressions</strong>.</p>
<table>
<tr>
<td>
<ol>
<li><code>undefined</code> and <code>null</code>.</li>
<li>Boolean literals.</li>
<li>String literals.</li>
<li>Regular-expression literals.</li>
</ol>
<td>
<ol start="5">
<li>Template literals.</li>
<li>Array literals.</li>
<li>Object literals.</li>
</ol>
<tr>
<td>
<ol start="8">
<li>Variable references.</li>
<li>Property accessors.</li>
<li><code>this</code>.</li>
<li><code>new.target</code>.</li>
</ol>
<td>
<ol start="13">
<li>Arithmetic operations.</li>
<li>Bitwise operations.</li>
<li>Logical operations.</li>
</ol>
<tr>
<td>
<ol start="16">
<li>Equality operations.</li>
<li><code>instanceof</code> and <code>in</code> operations.</li>
<li>Conditional operations.</li>
</ol>
<td>
<ol start="19">
<li>Unary function calls.</li>
<li>Unary constructor calls.</li>
<li>N-ary function calls.</li>
<li>N-ary constructor calls.</li>
<li><code>super</code> calls.</li>
</ol>
<tr>
<td>
<ol start="23">
<li>Arrow functions.</li>
<li>Function definitions.</li>
<li>Generator definitions.</li>
</ol>
<td>
<ol start="26">
<li>Async-function definitions.</li>
<li>Async-generator definitions.</li>
<li>Class definitions.</li>
</ol>
<tr>
<td>
<ol start="29">
<li><code>typeof</code> operations.</li>
<li><code>void</code> expressions.</li>
<li><code>await</code> expressions.</li>
<li><code>yield</code> expressions.</li>
</ol>
<td>
<ol start="33">
<li><a href="#function-binding">Function binding?</a></li>
</ol>
</table>
<p>The goal of the pipeline operator is to untangle deeply nested expressions into flat
threads of postfix expressions. To limit it to only one type of expression, even
a common type, truncates its benefits to that one type only and compromises its
expressivity and versatility.</p>
<p>In particular, relying on immediately invoked function expressions (<a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">IIFEs</a>)
to accomodate non-unary function is insufficient for idiomatic JavaScript code.
JavaScript functions have never fulfilled the <a href="http://gafter.blogspot.com/2006/08/tennents-correspondence-principle-and.html">Tennent correspondence
principle</a>. Several common types of expressions cannot be equivalently used
within inner functions, particularly <code>await</code> and <code>yield</code>. In these frequent
cases, attempting to replacing code with “equivalent” IIFEs may cause different
behavior, may cause different performance behavior (see example in <a href="#zero-runtime-cost">zero runtime
cost</a>), or may require dramatic rearrangement of logic to conserve the old
code’s behavior.</p>
<p>It would be possible to add ad-hoc handling, for selected other expression
types, to the operator’s grammar. This would expand its benefits to that type.
However, this conflicts with the goal of <a href="#cyclomatic-simplicity">cyclomatic simplicity</a>, by adding
complexity to the parsing process, proportional to the number of ad-hoc handled
cases. It also does not fulfill this goal well either: excluding, perhaps
arbitrarily, whatever classes its grammar’s branches do not handle.</p>
<p>Such new <a href="https://en.wikipedia.org/wiki/Incidental_complexity">incidental complexity</a> makes code less readable and distracts the
developer from the program’s <a href="https://en.wikipedia.org/wiki/Essential_complexity">essential logic</a>. A pipeline
operator that improves readability should be versatile (this goal) but
<a href="#cyclomatic-simplicity">conceptually and cyclomatically simple</a>. Such an
operator should be able to handle <strong>all</strong> expressions, in a <strong>single</strong> manner
<strong>uniformly</strong> <strong>universally</strong> applicable to <strong>all</strong> expressions. It is the hope
of this proposal’s authors that its <a href="#smart-body-syntax">smart body syntax</a> fulfills both criteria.</p>
<h3>Cyclomatic simplicity</h3>
<p>Each edge case of the grammar increases the <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity#Applications">cyclomatic complexity</a> of parsing
the new syntax, increasing cognitive burden on both machine compiler and human
reader in writing and reading code without error. If edge cases and branching
are minimized, then the resulting syntax will be uniform and consistent. The
reduced complexity would hopefully reduce the probability that the developer
will misunderstand the code they read or write.</p>
<p>Similarly, reducing edge cases reduces the amount of trivia that a developer
must learn and remember in order to use the syntax. The more uniform and
simple the syntax’s rules, the more the developer may focus on the actual
meaning of their code.</p>
<p>Both <a href="#expressive-versatility">expressive versatility</a> and simplicity are important components of
<a href="#dont-make-me-overthink">“don’t make me overthink”</a>, but they sometimes conflict with one another.
When this happens, expressive versatility often wins: simplicity is important,
but sometimes it may be traded off for increased expressiveness. For instance,
<a href="#terse-function-calls">terse function calls</a> are important for <a href="https://en.wikipedia.org/wiki/Tacit_programming">tacit functional programming</a>, one of the impetuses for the <a href="https://github.com/tc39/proposal-pipeline-operator/blob/37119110d40226476f7af302a778bc981f606cee/README.md">first pipeline-operator proposal</a>.</p>
<p>The pipeline operator could be designed to support only <a href="#topic-style">topic style</a>: that
would require <code>x |&gt; f</code> to be <code>x |&gt; f(#)</code>. But adding a <a href="#bare-style">bare style</a> brings
many expressive benefits for tacit functional programming: not just <a href="#terse-function-calls">terse
function calls</a> but also the possibility of <a href="#terse-composition">terse composition</a> with
<a href="#additional-feature-pf">Additional Feature PF</a>.</p>
<p>But even with this tradeoff, not too much simplicity should be given up. The
sacrifice of simplicity for bare style’s alternate mode can be minimized by
ensuring that <a href="#smart-body-syntax">its parsing rules are very simple</a>.</p>
<h2>“Make my code easier to read.”</h2>
<p>The new syntax should increase the human readability and writability of much
common code. It should be simpler to read and comprehend. And it should be
easier to compose and update. Otherwise, the new syntax would be useless.</p>
<p>Making JavaScript expressions more ergonomic for humans is the prime, original
purpose of this proposal. To a computer, the form of complex expressions –
whether as deeply nested groups or as flat threads of postfix steps – should not
matter. But to a human, it can make a significant difference.</p>
<h3>Untangled flow</h3>
<p>When a human reads deeply nested groups of expressions – which are very common
in JavaScript code – their attention must switch between the start and end of
each nested expression. And these expressions will dramatically differ in
length, depending on their level in the syntactic tree. To use the example above:</p>
<pre><code class="language-js">new User.Message(
  capitalize(
    doubledSay(
      (await promise)
        ??: throw new TypeError(`Invalid value from ${promise}`)
    )
  ) + '!'
)
</code></pre>
<p>…the deep inner expression <code>await promise</code> is relatively short. In
contrast, the shallow outer expression
<code>capitalize(doubledSay((await promise) ??: throw new TypeError(`Invalid value from ${promise}`))) + '!'`)</code>
is very long. Yet both are
quite similar: they are transformations of a string into another. This
insight is lost in the deeply nested noise.</p>
<p>With pipelines, the code forms a flat thread of postfix steps. It is much
easier for a human to read and comprehend. Each of its steps are roughly the
same length. In order to understand what occurs before a given step, one
only need to scan left, rather than in both directions as the deeply nested
tree would require. To read the whole thing, a reader may simply follow
along left to right, not back and forth.</p>
<pre><code class="language-js">promise
|&gt; await #
|&gt; # ??: throw new TypeError()
|&gt; doubleSay(#, ', ')
|&gt; capitalize
|&gt; # + '!'
|&gt; new User.Message
|&gt; await stream.write
</code></pre>
<p>The introduction to this <a href="#motivation">motivation</a> section already explained much of
the readability rationale.</p>
<h3>Distinguishable punctuators</h3>
<p>Another important aspect of code readability is the visual distinguishability of
its most important words or symbols. Visually similar punctuators can distract
or even mislead the human reader, as they attempt to figure out the true meaning
of their code.</p>
<p>Any new punctuator should be easily distinguishable from existing symbols and should
not be visually confusable with unrelated syntax. This is particularly true for
choosing the topic-reference token, which would appear often in a wide variety
of expressions. If the topic reference hypothetically were <code>?</code> (and <code>??</code> and
<code>???</code> with <a href="#additional-feature-np">Additional Feature NP</a>), and if the topic reference were used
anywhere near the visually similar <a href="https://github.com/tc39/proposal-optional-chaining">optional-chaining syntax proposal</a> and
<a href="https://github.com/tc39/proposal-nullish-coalescing/">nullish coalescing proposal</a>, then the topic reference might be lost or
unnoticed by the developer: for example, <code>(?)??.m(??)</code> is much less readable
than <code>#??.m(##)</code>.</p>
<h3>Terse parentheses</h3>
<p>Terseness also aids distinguishability by obviating the need for boilerplate
syntactic noise. Parentheses are a prominent example: as long as operator
precedence is clear, then reducing parentheses always would JavaScript code more
visually terse and less cluttered.</p>
<p>The example above demonstrates how numerous verbose parentheses could become
unnecessary with pipelines. In these cases the <a href="https://www.darkhorseanalytics.com/blog/data-looks-better-naked">“data-to-ink” visual ratio</a>
would significantly increase, emphasizing the program’s essential information.
The developer’s cognitive burden – of ignoring unimportant incidental symbols as
they read – has hopefully lightened.</p>
<h3>Terse variables</h3>
<p>Similarly, terseness of code may also be increased by removing variables where
possible. This in turn would increase the data-to-ink visual ratio of the text
and the distinguishability of important symbols. This style of programming is
known as <a href="https://en.wikipedia.org/wiki/Tacit_programming">tacit or point-free programming</a> (where “point”
refers to function arguments). Jeremy Gibbons, a computer scientist, expressed
its claimed benefits in a 1970 paper as such:</p>
<blockquote>
<p>Our calculations got completely bogged down using [function arguments]. In
attempting to rephrase [function] definitions […] in particular, eliminating
as many variables as possible and performing point-free (or ‘pointless‘)
calculations at the level of functino compisition instead of point-wise
calculations at the level of application, suddenly the calculations became
almost trivial. This is the point of [point-free] calculations: when you
travel light – discarding variables that do not contribute to the calculation
– you can sometimes step lightly across the surface of the quagmire.</p>
</blockquote>
<p>This sort of terseness, in which the explicit is made tacit and implicit, must
be balanced with <a href="#syntactic-locality">syntactic locality</a> and <a href="#cyclomatic-simplicity">cyclomatic simplicity</a>. Excessive
implicitness compromises comprehensibility, at least without low-level tracing
of tacit arguments’ invisible paths, rather than the actual, high-level meaning
of the code. Yet at the same time, excessive explicitness generates ritual,
verbose boilerplate that also interferes with reading comprehension. Therefore,
<a href="#untangled-flow">untangled flow</a> must be balanced with <a href="#backward-compatibility">backward compatibility</a>, <a href="#syntactic-locality">syntactic
locality</a>, and <a href="#cyclomatic-simplicity">cyclomatic simplicity</a>.</p>
<p><a href="https://www.python.org/dev/peps/pep-0020/">The Zen of Python</a> famously says, “Explicit is better than implicit,”
but it also says, “Flat is better than nested,” and, “Sparse is better than
dense.”</p>
<h3>Terse function calls</h3>
<p>Unary function / constructor calls are a particularly frequent type of
expression and a good target for especial human optimization. However, such
extra shortening might dramatically reduce the verbosity of unary function
calls, but again this must be balanced with <a href="#backward-compatibility">backward compatibility</a>,
<a href="#syntactic-locality">syntactic locality</a>, and <a href="#cyclomatic-simplicity">cyclomatic simplicity</a>.</p>
<p>It is the hope of this proposal’s authors that its <a href="#smart-body-syntax">smart body syntax</a> reaches
a good balance between this goal and <a href="#syntactic-locality">syntactic locality</a> and <a href="#cyclomatic-simplicity">cyclomatic
simplicity</a>, in the same manner that <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman coding</a> optimizes textual
symbols’ length for their frequency of use: more commonly used symbols are
shorter in written length.</p>
<p>Furthermore, calls are not only unary; they may also be n-ary. <a href="#additional-feature-np">Additional
Feature NP</a> adds support for terse N-ary function calls within pipelines.</p>
<h3>Terse composition</h3>
<p>Terse composition of all expressions – <a href="#expressive-versatility">not only unary functions</a> but also n-ary functions, object methods, async functions,
generators, <code>if</code> <code>else</code> statements, and so forth – is a goal of smart pipelines.
<a href="#function-composition">Several alternative proposals also address function composition</a>, but <a href="#additional-feature-pf">Additional Feature PF</a> holistically addresses it with
application, partial application, and method extraction, and not only for unary
functions but also for expressions of any type.</p>
<h3>Terse partial application</h3>
<p>Terse partial application of all expressions – <a href="#expressive-versatility">not only functions</a> but also object methods, async functions, generators, <code>if</code> <code>else</code>
statements, and so forth – is a goal of smart pipelines. <a href="#partial-function-application">An existing
alternative proposal also addresses partial function application</a>, but <a href="#additional-feature-pf">Additional Feature PF</a> holistically addresses it
with application, partial application, and method extraction, and not only for
unary functions but also for expressions of any type. <a href="#additional-feature-np">Additional Feature NP</a>
extends this ability to N-ary expressions, including variadic expressions.</p>
<h3>Terse method extraction</h3>
<p>Terse method extraction – being able to use a method as a function without
relying on <code>Function.prototype.bind</code>, such as using <code>console.log</code> as a callback
function – is another goal of smart pipelines. Method extraction is also
addressed by <a href="#additional-feature-pf">Additional Feature PF</a>. <a href="#function-binding">An existing alternative proposal for
function binding already addresses method extraction as a special case</a>, but <a href="#additional-feature-pf">Additional Feature PF</a> holistically addresses method binding
with composition, application, and partial application.</p>
<h2>Other Goals</h2>
<p>Although these have been prioritized last, they are still important.</p>
<h3>Conceptual generality</h3>
<p>If a concept is uniformly generalizable to many other cases, then this
multiplies its usefulness. The more versatile its concepts, the more it may be
applied to other syntax, including existing syntax and future syntax (compare
with <a href="#forward-compatibility">forward compatibility</a>).</p>
<p>This proposal’s concept of a <strong>topic reference does not need to be coupled only
to pipelines</strong>. The topic concept is <strong>generalizable to many syntactic forms</strong>,
as the <a href="#smart-pipelines">Additional Features</a> demonstrate. They together form one unified vision
of a future in which composition, partial application, method extraction, and
error handling are all tersely expressible with the same simple concepts.</p>
<h3>Human writability</h3>
<p>Writability of code is less important a priority than readability of code. Code
is usually written a few days, perhaps by a few authors – but code will be read
dozens or hundreds of times, perhaps by many more people. However, ease of
writing and editing is still a good goal, and it often naturally increases when
code also becomes more readable. A useful heuristic for writability is assessing
the probability that a single edit to one piece of code will necessitate changes
to other parts of code that are not directly related to the edit.</p>
<p>The simple addition or removal of a deeply nested expression may necessitate the
indentation, de-indentation, parenthetical grouping, and parenthetical
flattening of many lines of code; the tedium of these incidental changes is a
major factor in the general popularity of automatic code formatters.</p>
<p>Achieving <a href="#static-analyzability">static analyzability</a> therefore also improves the ease of composing
and editing code. By flattening deeply nested expression trees into single
threads of postfix steps, a step may be added oredited in isolation on a single
line, it may be rearranged up or down, it may be removed – all without affecting
the pipeline’s other steps in the lines above or below it.</p>
<h3>Novice learnability</h3>
<p>Learnability of the syntax is a desirable goal: the more intuitive the syntax
is, the more rapidly it might be adopted by developers. However, learnability in
of itself is not more desirable than the <a href="#goals">other goals above</a>. Most
JavaScript developers would be novices to this syntax at most once, during which
the intuitiveness of the syntax will dominate their experience. But after that
honeymoon period, the syntax’s usability in workaday programming will instead
affect their reading and writing most.</p>
<p>So instead, readability, comprehensibility, locality, simplicity,
expressiveness, and terseness are prioritized first, where they would conflict
with learnability itself. However, a syntax that is simple but expressive – and,
most of all, readable – could well be easier to learn. Its up-front cost in
learning could be small, particularly in comparison to the large gains in
readability and comprehensibility that it might bring to code in general.</p>
<h1>Relations to other work</h1>
<h2>Pipelines in other programming languages</h2>
<p>The concept of a pipeline operator appears in numerous other languages, variously
called “pipeline”, “threading”, and “feed” operators. This is because developers
find the concept useful.</p>
<table>
<tr>
<th>
<p><code>|</code></p>
<td>
<p><a href="https://en.wikipedia.org/wiki/Pipeline_(Unix">Unix shells, PowerShell</a></p>
<tr>
<th>
<p><code>|&gt;</code></p>
<td>
<p><a href="https://elixir-lang.org/getting-started/enumerables-and-streams.html">Elixir and Erlang</a>, <a href="http://elm-lang.org/docs/syntax#infix-operators">Elm</a>, <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/index#function-composition-and-pipelining">F# / F-sharp</a>,
<a href="https://docs.hhvm.com/hack/operators/pipeline-operator">Hack</a>, <a href="https://docs.julialang.org/en/stable/stdlib/base/#Base.:%7C%3E">Julia</a>, <a href="http://livescript.net/#operators-piping">LiveScript</a>, <a href="http://blog.shaynefletcher.org/2013/12/pipelining-with-operator-in-ocaml.html">OCaml</a>,</p>
<tr>
<th>
<p><code>|&gt;</code> with <code>$$</code></p>
<td>
<p><a href="https://docs.hhvm.com/hack/operators/pipeline-operator">Hack</a></p>
<tr>
<th>
<p><code>%&gt;%</code></p>
<td>
<p><a href="https://cran.r-project.org/web/packages/magrittr/index.html">R with magrittr</a></p>
<tr>
<th>
<p><code>==&gt;</code></p>
<td>
<p><a href="https://docs.perl6.org/language/operators#infix_==%3E">Perl 6</a></p>
<tr>
<th>
<p><code>-&gt;</code> <code>-&gt;&gt;</code><br />
<code>as-&gt;</code> <code>as-&gt;&gt;</code><br />
<code>some-&gt;</code> <code>some-&gt;&gt;</code><br />
<code>cond-&gt;</code> <code>cond-&gt;&gt;</code></p>
<td>
<p><a href="https://clojuredocs.org/clojure.core/as-%3E">Clojure</a></p>
<tr>
<th>
<p><a href="https://en.wikipedia.org/wiki/Concatenative_programming_language">Term concatenation</a></p>
<td>
<p>Factor, Forth, Joy, Onyx, PostScript, RPL</p>
</table>
<p>Pipeline operators are also conceptually similar to <a href="https://streams.spec.whatwg.org/#pipe-chains">WHATWG-stream piping</a> and
<a href="https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options">Node-stream piping</a>.</p>
<h2>Topic references in other programming languages</h2>
<p>The <a href="https://rosettacode.org/wiki/Topic_variable">concept of the “topic variable” already exists in many other programming
languages</a>, commonly named with an
underscore <code>_</code> or <code>$_</code>. These languages often integrate their topic variables
into their function-call control-flow syntaxes, with <a href="https://www.perl.com/pub/2002/10/30/topic.html/">Perl 6 as perhaps the most
extensive, unified example</a>. Integration of topic with
syntax enables especially pithy, terse <a href="https://en.wikipedia.org/wiki/Tacit_programming">tacit programming</a>.</p>
<p>In addition, many JavaScript console <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPLs</a>, <a href="https://webkit.org/blog/829/web-inspector-updates/">such as the WebKit Web
Inspector console variables</a>, <a href="https://www.andismith.com/blogs/2011/11/25-dev-tool-secrets/">other browsers’ console
variables</a> and the Node.js console variables.</p>
<p>Several disadvantages to these prior approaches may increase the probability of
developer surprise, in which “surprise” refers to behavior difficult to predict
by the developer.</p>
<p>One disadvantage arises from their frequent dynamic binding rather than lexical
binding, as the former is not <a href="#static-analyzability">statically analyzable</a> and is more stateful
than the latter. It may also cause surprising results when coupled with
bare/tacit calls: it becomes more difficult to tell whether a bare identifier
<code>print</code> is meant to be a simple variable reference or a bare function call on
the topic value.</p>
<p>Another disadvantage arises from the ability to clobber or overwrite the value of the
topic variable, which may affect code in surprising ways.</p>
<p>However, JavaScript’s topic reference <code>#</code> is different than this prior art. It
is lexically bound, with <a href="#simple-scoping">simple scoping</a>, and it is <a href="#static-analyzability">statically
analyzable</a>. It also cannot be accidentally bound; the developer must opt into
binding it by using the pipeline operator (although <a href="#additional-feature-tc">Additional Feature TC</a>
and <a href="#additional-feature-tf">Additional Feature TF</a> are limited exceptions that do not extend into
inner blocks). The topic also cannot be accidentally used; it is an <a href="#static-early-errors">early
error</a> when <code>#</code> is used outside of a pipeline body (see <a href="#core-proposal">Core Proposal</a> and
<a href="#static-analyzability">static analyzability</a>). The proposal is as a whole designed to <a href="#dont-shoot-me-in-the-foot">prevent
footguns</a>.</p>
<p>The topic is <a href="#conceptual-generality">conceptually general</a> and could be extended
to other forms. This proposal is <a href="#forward-compatibility">forward compatible</a>
with such extensions, which would increase its <a href="#expressive-versatility">expressive versatility</a>, and
potentially multiplying its benefits toward <a href="#untangled-flow">untangled flow</a>, <a href="#terse-variables">terse
variables</a>, and <a href="#human-writability">human writability</a>, while still preserving <a href="#simple-scoping">simple
scoping</a> and <a href="#static-analyzability">static analyzability</a>.</p>
<h2>Function binding</h2>
<p>An existing proposal for <a href="https://github.com/zenparsing/es-function-bind">ECMAScript function binding</a> has three use cases:</p>
<ol>
<li>Extracting a method from an object as a standalone function:
<code>o.method.bind(object)</code> as <code>::object.method</code>.</li>
<li>Calling a function as if it were a method call on an object:
<code>func.call(object, ...args)</code> as <code>object::func(...args)</code></li>
<li>Creating a function by binding an object to it:
<code>func.bind(object)</code> as <code>object::func</code>.</li>
</ol>
<p>The smart-pipelines <a href="#core-proposal">Core Proposal</a> + <a href="#additional-feature-pf">Additional Feature PF</a> <strong>subsumes</strong>
the <a href="https://github.com/zenparsing/es-function-bind">ECMAScript function binding</a> proposal in the <strong>first use case</strong> (prefix
<code>::</code>). But the other two use cases (infix <code>::</code>) are not addressed by smart
pipelines. Smart pipelines and infix function binding <code>::</code> can and should
coexist. In fact, infix function binding could be made more ergonomic in many
cases by replacing prefix <code>::function</code> with a shortcut for infix <code>#::function</code>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>
<p>With <a href="https://github.com/zenparsing/es-function-bind">existing proposal</a></p>
<tbody>
<tr>
<td>
<p><strong>Method extraction</strong> can be addressed by pipeline functions alone, as a natural
result of their pipeline-operator-like semantics.<br />
<code>+&gt; console.log</code> is equivalent to <code>$ =&gt; $ |&gt; console.log</code>, which is a pipeline in
<a href="#bare-style">bare style</a>. This in turn is <code>$ =&gt; console.log($)</code>…</p>
<pre><code class="language-js">Promise.resolve(123).then(+&gt; console.log)
</code></pre>
<td>
<p>…and <code>$ =&gt; console.log($)</code> is equivalent to <code>console.log.bind(console)</code>.</p>
<pre><code class="language-js">Promise.resolve(123).then(console.log.bind(console))
Promise.resolve(123).then(::console.log)
</code></pre>
<tr>
<td>
<pre><code class="language-js">$('.some-link').on('click', +&gt; view.reset)
</code></pre>
<td>
<pre><code class="language-js">$('.some-link').on('click', ::view.reset)
</code></pre>
<tr>
<td>
<pre><code class="language-js">const { hasOwnProperty } = Object.prototype
const x = { key: 5 }
x::hasOwnProperty
x::hasOwnProperty('key')
</code></pre>
<p>For terse <strong>method calling/binding</strong>, the infix <code>::</code> operator would still be
required.</p>
<td>
<pre><code class="language-js">const { hasOwnProperty } = Object.prototype
const x = { key: 5 }
x::hasOwnProperty
x::hasOwnProperty('key')
</code></pre>
<p>But the <code>::</code> operator would only need to handle method calls. No operator
overloading of <code>::</code> for method extraction (that is, <code>::</code> as a prefix operator)
would be needed.</p>
<tr>
<td>
<p>The <a href="#function-bind-operator">function bind operator <code>::</code></a>’s proposal switches its prefix form
<code>::function</code> to mean <code>#::function</code> instead of <code>object.bind(object)</code>, then many
nested functions would become even terser.</p>
<pre><code class="language-js">a(1, +&gt;
  ::b(2, +&gt; …)
)
</code></pre>
<p>See <a href="#block-parameters">block parameters</a> for further examples.</p>
<td>
<pre><code class="language-js">a(1, $ =&gt;
  $::b(2, $ =&gt; …)
)
</code></pre>
</table>
<h2>Function composition</h2>
<p><strong><a href="#terse-composition">Terse composition</a></strong> on unary functions is a goal of smart pipelines.
It is equivalent to piping a value through several function calls, within a
unary function, starting with the outer function’s tacit unary parameter.</p>
<p>There are several existing proposals for unary functional composition, which
<a href="#additional-feature-pf">Additional Feature PF</a> would all subsume. Additional Feature PF can compose
not only unary functions but <a href="#expressive-versatility">expressions of any type</a>,
including object methods, async functions, and <code>if</code> <code>else</code> statements. And with
<a href="#additional-feature-np">Additional Feature NP</a>, even functional composition into n-ary functions
would be supported, which no current proposal yet addresses.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>With alternative proposals
<tbody>
<tr>
<td>
<pre><code class="language-js">array.map(+&gt; f |&gt; g |&gt; h(2, #) |&gt; # + 2)
</code></pre>
<td>
<pre><code class="language-js">array.map($ =&gt; h(2, g(f($))) + 2)
</code></pre>
<tr>
<td>
<pre><code class="language-js">const doubleThenSquareThenHalfAsync =
  async +&gt;
    |&gt; double
    |&gt; await squareAsync
    |&gt; half
</code></pre>
<p>When compared to the proposal for <a href="https://github.com/TheNavigateur/proposal-pipeline-operator-for-function-composition">syntactic functional composition by
TheNavigateur</a>, this syntax does not need
to give implicit special treatment to async functions. There is instead an async
version of the pipe-function operator, within which <code>await</code> may be used, simply
as usual.</p>
<td>
<pre><code class="language-js">const doubleThenSquareThenHalfAsync =
  async $ =&gt;
    half(await squareAsync(double($)))
</code></pre>
<pre><code class="language-js">const doubleThenSquareThenHalfAsync =
  double +&gt; squareAsync +&gt; half
</code></pre>
<p>From the proposal for <a href="https://github.com/TheNavigateur/proposal-pipeline-operator-for-function-composition">syntactic functional composition by
TheNavigateur</a>.</p>
<tr>
<td>
<pre><code class="language-js">const toSlug =
  $ =&gt; $
  |&gt; #.split(' ')
  |&gt; #.map($ =&gt; $.toLowerCase())
  |&gt; #.join('-')
  |&gt; encodeURIComponent
</code></pre>
<p>This example also uses <a href="#additional-feature-pp">Additional Feature PP</a> for its second line:</p>
<pre><code class="language-js">const toSlug = +&gt;
|&gt; #.split(' ')
|&gt; #.map(+&gt; #.toLowerCase())
|&gt; #.join('-')
|&gt; encodeURIComponent
</code></pre>
<p>When compared to the proposal for <a href="https://github.com/isiahmeadows/function-composition-proposal">syntactic functional composition by Isiah
Meadows</a>, this syntax does not need to
surround each non-function expression with an arrow function. The <a href="#smart-body-syntax">smart body
syntax</a> has more powerful <a href="#expressive-versatility">expressive versatility</a>, improving the
readability of the code.</p>
<td>
<pre><code class="language-js">const toSlug = $ =&gt;
  encodeURIComponent(
    $.split(' ')
      .map(str =&gt;
        str.toLowerCase())
      .join('-'))
</code></pre>
<pre><code class="language-js">const toSlug =
  _ =&gt; _.split(&quot; &quot;)
  :&gt; _ =&gt; _.map(str =&gt;
    str.toLowerCase())
  :&gt; _ =&gt; _.join(&quot;-&quot;)
  :&gt; encodeURIComponent
</code></pre>
<p>From the proposal for <a href="https://github.com/isiahmeadows/function-composition-proposal">syntactic functional composition by Isiah
Meadows</a>.</p>
<tr>
<td>
<pre><code class="language-js">const getTemperatureFromServerInLocalUnits =
  async +&gt;
  |&gt; await getTemperatureKelvinFromServerAsync
  |&gt; convertTemperatureKelvinToLocalUnits
</code></pre>
<p>Lifting of non-sync-function expressions into function expressions is
unnecessary for composition with Additional Feature PF.</p>
<td>
<pre><code class="language-js">Promise.prototype[Symbol.lift] = f =&gt; x =&gt;
  x.then(f)
const getTemperatureFromServerInLocalUnits =
  getTemperatureKelvinFromServerAsync
  :&gt; convertTemperatureKelvinToLocalUnits
</code></pre>
<p>From the proposal for <a href="https://github.com/isiahmeadows/function-composition-proposal">syntactic functional composition by Isiah
Meadows</a>.</p>
<tr>
<td>
<pre><code class="language-js">// Functional Building Blocks
const car = +&gt;
|&gt; startMotor
|&gt; useFuel
|&gt; turnKey;
const electricCar = +&gt;
|&gt; startMotor
|&gt; usePower
|&gt; turnKey;

// Control Flow Management
const getData = +&gt;
|&gt; truncate
|&gt; sort
|&gt; filter
|&gt; request;

// Argument Assignment
const sortBy = 'date';
const getData = +&gt;
|&gt; truncate
|&gt; sort
|&gt; #::filter(sortBy)
|&gt; request;
</code></pre>
<p>This example also uses <a href="#function-binding">function binding</a>.</p>
<td>
<pre><code class="language-js">// Functional Building Blocks
const car = startMotor.compose(
  useFuel, turnKey);
const electricCar = startMotor.compose(
  usePower, turnKey);

// Control Flow Management
const getData = truncate.compose(
  sort, filter, request);

// Argument Assignment
const sortBy = 'date';
const getData = truncate.compose(
  sort,
  $ =&gt; filter.bind($, sortBy),
  request
);
</code></pre>
<p>From the proposal for <a href="https://github.com/simonstaton/Function.prototype.compose-TC39-Proposal">syntactic functional composition by Simon
Staton</a>.</p>
<tr>
<td>
<pre><code class="language-js">const pluck = +&gt; map |&gt; prop
</code></pre>
<td>
<pre><code class="language-js">const pluck = compose(map)(prop)
</code></pre>
<p>From a <a href="https://github.com/fantasyland/ECMAScript-proposals/issues/1#issuecomment-306243513">comment about syntactic functional composition by Tom Harding</a>.</p>
</table>
<h2>Partial function application</h2>
<p><a href="#terse-partial-application">Terse partial application</a> is a goal of smart pipelines. The current proposal
for syntactic <a href="https://github.com/tc39/proposal-partial-application">ECMAScript partial application</a> by <a href="https://github.com/rbuckton">Ron Buckton</a> would be
subsumed by <a href="#additional-feature-pf">Additional Feature PF</a> and <a href="#additional-feature-np">Additional Feature NP</a>. Terse
partial application into an N-ary function is equivalent to piping N tacit
parameters into an N-ary function-call expression, within which the parameters
are resolvable topic references. (Additional Feature PF alone would only address
partial application into unary functions.)</p>
<p>Pipeline functions look similar to the alternative proposal, except that
partial-application expressions are simply pipeline bodies that are prefixed by
the pipeline-function operator, and consecutive <code>?</code> placeholders are instead
consecutive topic references <code>#</code>, <code>##</code>, <code>###</code>.</p>
<p>The current proposal for <a href="#partial-function-application">partial function application</a> assumes that each use
of the same <code>?</code> placeholder token represents a different parameter. In contrast,
each use of <code>#</code> within the same scope always refers to the same value. This is
why additional topic parameters are required.</p>
<p>The resulting model is more flexible: with Additional Feature NP with
<a href="#additional-feature-pf">Additional Feature PF</a>, <code>+&gt; f(#, 4, ##)</code> is different from <code>+&gt; f(#, 4, #)</code>.
The former refers to a <strong>binary</strong> function: a function with two parameters,
essentially <code>(x, y) =&gt; f(x, 4, y)</code>. The latter refers to a <strong>unary</strong> function
that passes the same one argument into both the first and third parameters of
the original function <code>f</code>: <code>x =&gt; f(x, 4, x)</code>. The same symbol refers to the same
value in the same lexical environment.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>With alternative proposals
<tbody>
<tr>
<td>
<pre><code class="language-js">array.map($ =&gt; $ |&gt; f(2, #))
array.map(+&gt; f(2, #))
</code></pre>
<td>
<pre><code class="language-js">array.map(f(2, ?))
array.map($ =&gt; f(2, $))
</code></pre>
<tr>
<td>
<pre><code class="language-js">const addOne = +&gt; add(1, #)
addOne(2) // 3
</code></pre>
<td>
<pre><code class="language-js">const addOne = add(1, ?)
addOne(2) // 3
</code></pre>
<tr>
<td>
<pre><code class="language-js">const addTen = +&gt; add(#, 10)
addTen(2) // 12
</code></pre>
<td>
<pre><code class="language-js">const addTen = add(?, 10)
addTen(2) // 12
</code></pre>
<tr>
<td>
<pre><code class="language-js">let newScore = player.score
|&gt; add(7, #)
|&gt; clamp(0, 100, #)
</code></pre>
<td>
<pre><code class="language-js">let newScore = player.score
|&gt; add(7, ?)
|&gt; clamp(0, 100, ?)
</code></pre>
<tr>
<td>
<pre><code class="language-js">const toSlug = +&gt;
|&gt; encodeURIComponent
|&gt; _.split(#, &quot; &quot;)
|&gt; _.map(#, _.toLower)
|&gt; _.join(#, &quot;-&quot;)
</code></pre>
<p>Additional Feature PF simultaneously handles function composition and
partial application into unary functions.</p>
<td>
<pre><code class="language-js">const toSlug =
encodeURIComponent
:&gt; _.split(?, &quot; &quot;)
:&gt; _.map(?, _.toLower)
:&gt; _.join(?, &quot;-&quot;)
</code></pre>
<p>From the proposal for <a href="https://github.com/isiahmeadows/function-composition-proposal">syntactic functional composition by Isiah
Meadows</a>.</p>
<tr>
<td>
<pre><code class="language-js">[ { x: 22 }, { x: 42 } ]
  .map(+&gt; #.x)
  .reduce(+&gt; # - ##, 0)
</code></pre>
<td>
<pre><code class="language-js">[ { x: 22 }, { x: 42 } ]
  .map(el =&gt; el.x)
  .reduce((_0, _1) =&gt; _0 - _1, 0)
</code></pre>
<tr>
<td>
<pre><code class="language-js">const f = (x, y, z) =&gt; [x, y, z]
const g = +&gt; f(#, 4, ##)
g(1, 2) // [1, 4, 2]
</code></pre>
<td>
<pre><code class="language-js">const f = (x, y, z) =&gt; [x, y, z]
const g = f(?, 4, ?)
g(1, 2) // [1, 4, 2]
</code></pre>
<tr>
<td>
<pre><code class="language-js">const maxGreaterThanZero =
  +&gt; Math.max(0, ...)
maxGreaterThanZero(1, 2) // 2
maxGreaterThanZero(-1, -2) // 0
</code></pre>
<p>Partial application into a variadic function is also naturally handled by
Additional Feature NP with <a href="#additional-feature-pf">Additional Feature PF</a>.</p>
<td>
<pre><code class="language-js">const maxGreaterThanZero =
  Math.max(0, ...)
maxGreaterThanZero(1, 2) // 2
maxGreaterThanZero(-1, -2) // 0
</code></pre>
<p>In this case, the topic function version looks once again nearly identical to
the other proposal’s code.</p>
</table>
<h2>Pattern matching</h2>
<p>The smart pipelines and topic references of the <a href="#core-proposal">Core Proposal</a> would be a
boon to the proposal for <a href="https://github.com/tc39/proposal-pattern-matching">ECMAScript pattern matching</a>.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>With pattern matching only
<tbody>
<tr>
<td>
<pre><code class="language-js">… |&gt; f
|&gt; match (#) {
    100: #
    Array:
      #.length
    /(\d)(\d)(\d)/:
      #.groups |&gt; #[0] + #[1] + #[2]
  }
</code></pre>
<p>The <code>match</code> expression would <strong>bind the topic reference</strong> within the scope of a
successfully matching clause’s scope. The topic value would be the <strong>truthy
result</strong> of the successful <strong><code>Symbol.matches</code></strong> call.</p>
<td>
<pre><code class="language-js">match (f(…)) {
  100: x
  Array -&gt; a:
    x.length
  /(\d)(\d)(\d)/ -&gt; m:
    m.groups |&gt; #[0] + #[1] + #[2]
}
</code></pre>
<p>With a topic binding, the <code>-&gt; a</code> and <code>-&gt; m</code> bindings would be unnecessary.</p>
<tr>
<td>
<pre><code class="language-js">… |&gt; f
|&gt; match {
    { x, y }:
      (x ** 2 + y ** 2)
      |&gt; Math.sqrt
    [...]:
      #.length
    else:
      throw new Error(#)
  }
</code></pre>
<p><a href="https://github.com/tc39/proposal-pattern-matching">ECMAScript pattern matching</a> could also have a <strong>completely tacit version</strong>,
in which the parenthesized antecedent (<code>(#)</code> in <code>match (#)</code>) is completely
omitted in favor of tacitly using the outer context’s topic.</p>
<td>
<pre><code class="language-js">match (f(…)) {
  { x, y }:
    (x ** 2 + y ** 2)
    |&gt; Math.sqrt
  [...] -&gt; a:
    a.length
  else:
    throw new Error(vector)
  }
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">try {
  …
  catch {
    match {
      SyntaxError:
      |&gt; f
      TypeError:
      |&gt; g |&gt; h(#, {strict: true})
      Error:
      |&gt; throw #
    }
  }
}
</code></pre>
<p>With ECMAScript pattern matching + the <a href="#core-proposal">Core Proposal</a> + <a href="#additional-feature-pp">Additional
Feature PP</a> + <a href="#additional-feature-tc">Additional Feature TC</a> + <a href="https://github.com/tc39/proposal-optional-catch-binding">ECMAScript optional catch
binding</a>, handling caught errors (and promise rejections) based on error type
becomes more ergonomic.</p>
<td>
<pre><code class="language-js">try {
  …
  catch (error) {
    match (error) {
      SyntaxError:
        f(error)
      TypeError:
        h(g(error), {strict: true})
      Error:
        throw error
    }
  }
}
</code></pre>
<p>The version with pattern matching alone is more verbose with five more <code>error</code>
variables, distracting the reader from how the error is actually handled.</p>
</table>
<tr>
<th>
<h2>Block parameters</h2>
<p>The proposed syntax of <a href="https://github.com/samuelgoto/proposal-block-params">ECMAScript block parameters</a> may greatly benefit from
the pipeline and topic concepts, which would be able to explain much of their
desired behavior.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>With block parameters only
<tbody>
<tr>
<td>
<tr>
<td>
<pre><code class="language-js">materials.map { |&gt; f |&gt; .length }
</code></pre>
<p>This example uses <a href="#additional-feature-pp">Additional Feature PP</a>. The first parameter of the arrow
function that the block parameter implicitly creates is bound to the topic,
which in turn is fed into the pipeline <code>|&gt; f |&gt; .length</code>.</p>
<td>
<pre><code class="language-js">materials.map do (m) { f(m).length }
</code></pre>
<p>The block-parameter proposal itself has not yet settled on how to parameterize
its block parameters. The topic reference may be the key to solving this
problem, making other, special block parameters unnecessary.</p>
<tr>
<td>
<p>Note that this would be the same as:</p>
<pre><code class="language-js">materials.map(+&gt; f |&gt; .length)
</code></pre>
<td>
<pre><code class="language-js">materials.map (m) { f(m).length }
</code></pre>
<tr>
<td>
<pre><code class="language-js">a(1) {
  #::b(2) { … }
}
</code></pre>
<p>The block-parameter proposal in particular has not settled on how to nest block
parameters. But the <a href="#core-proposal">Core Proposal</a>’s simple syntax rules already can handle
nested block parameters.</p>
<td>
<pre><code class="language-js">a(1) {
  ::b(2) { … }
}
</code></pre>
<p>The block-parameter proposal’s authors have been exploring using a sygil –
perhaps related to the <a href="#function-binding">function bind operator <code>::</code></a> – in
order to refer to the parent block param, using some to-be-determined symbolic
magic that would be unnecessary with topic references.</p>
<tr>
<td>
<p>This would simply be equivalent to:</p>
<pre><code class="language-js">a(1, +&gt;
  #::b(2, +&gt; { … })
)
</code></pre>
<td>
<pre><code class="language-js">a(1) {
  ::b(2) { … }
}
</code></pre>
<tr>
<td>
<p>…and if the <a href="#function-binding">function bind operator <code>::</code></a>’s proposal switches
its prefix form <code>::function</code> to mean <code>#::function</code>, then this can become even
terser, without additional magic:</p>
<pre><code class="language-js">a(1) do {
  ::b(2) { … }
}
</code></pre>
<td>
<pre><code class="language-js">a(1) {
  ::b(2) { … }
}
</code></pre>
<tr>
<td>
<pre><code class="language-js">server(app) {
  #::get('/') do (response) {
    request()
    |&gt; .get('param1')
    |&gt; `hello world ${#}`
    |&gt; response.send
  }

  #::listen(3000) {
    log('hello')
  }
}
</code></pre>
<p>And again, if the <a href="#function-binding">function bind operator <code>::</code></a>’s proposal
switches its prefix form <code>::function</code> to mean <code>#::function</code>, then <code>#::get</code> and
<code>#::listen</code> could become simply <code>::get</code> and <code>::listen</code>.</p>
<td>
<pre><code class="language-js">server(app) do (_app) {
  _app::get('/') do (response) {
    request()
    |&gt; #.get('param1')
    |&gt; `hello world ${#}`
    |&gt; response.send
  }

  _app::listen(3000) {
    log('hello')
  }
}
</code></pre>
</table>
<h3>Topic metaprogramming references</h3>
<p>In the event that TC39 seriously considers the topic function definitions
shown above, a <strong><code>function.topic</code></strong> metaprogramming operator, in the style of
the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target"><code>new.target</code></a> operator, could be useful in creating topic-aware functions.</p>
<p>This might be especially useful in creating APIs resembling <a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain-specific
languages</a> with <a href="https://github.com/samuelgoto/proposal-block-params">ECMAScript block parameters</a>. This example creates
three functions that form an API resembling <a href="https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/statements/select-case-statement">Visual Basic’s <code>select</code>
statement</a>. Two of these functions (<code>when</code> and <code>otherwise</code>) that are expected
to be called always within the third function (<code>select</code>)’s callback block.</p>
<p>Such a solution is not yet specified by the current proposal for <a href="https://github.com/samuelgoto/proposal-block-params">ECMAScript
block parameters</a>. Lexical topics can fill in that gap.</p>
<pre><code class="language-js">class CompletionRecord {
  type, value;

  constructor (testValue) {
    this.testValue = testValue;
  }
}

export function select (value, block) {
  const selectBlockTopic = new CompletionRecord();
  return block(topic)
  |&gt; match {
    CompletionRecord:
      #.value;
    else:
      throw 'Invalid clause was used in select block'
      |&gt; new Error;
  };
}

export function otherwise (block) {
  return function.topic
  |&gt; match (selectBlockTopic) {
    CompletionRecord:
      if (#.type === undefined) {
        #.type = 'normal';
        #.value = {};
      }
      #;
    else:
      throw 'Invalid otherwise clause was used outside select block'
      |&gt; new Error;
  };
}

export function when (caseValue, block) {
  return function.topic
  |&gt; match (selectBlockTopic) {
    CompletionRecord:
    |&gt; applyWhen(#, caseValue, block);
    else:
      throw 'Invalid when clause used was outside select block'
      |&gt; new Error;
  };
}

function applyWhen (selectBlockTopic, caseValue, block) {
  return match (#.value) {
    [...]:
      (selectBlockTopic, caseValue, block)
      |&gt; applyWhenArray;
    else:
      (selectBlockTopic, caseValue, block)
      |&gt; applyWhenValue;
  }
}

function applyWhenArray (selectBlockTopic, testArray, block) {
  return testArray.some(arrayValue =&gt;
    contextTopic |&gt; {
      if (when(arrayValue, block))
        #;
    });
}

function applyWhenValue (contextTopic, testValue, block) {
  return contextTopic |&gt; {
    let match
    if (#.type !== undefined
      &amp;&amp; (match = #[Symbol.matches](testValue))
    ) {
      #.type = 'normal';
      #.value = match |&gt; block;
    }
    #;
  };
}
</code></pre>
<hr />
<pre><code class="language-js">select ('world') {
  when ([Boolean, Number]) {
  |&gt; log;
  }
  when (String) {
  |&gt; `Hello ${#}`
  |&gt; log;
  }
  otherwise {
    throw `Error: ${|&gt; format}`
    |&gt; new Error;
  }
}
</code></pre>
<h2><code>do</code> expressions</h2>
<p>Because pipeline <a href="#topic-style">topic style</a> supports <a href="#expressive-versatility">arbitrary expressions</a>, when <a href="#do-expressions"><code>do</code> expressions</a> are added to JavaScript they too will be
supported within pipeline bodies. When this occurs, topic references would be
allowed within inner <code>do</code> expressions, along with arrow functions and <code>if</code> and
<code>try</code> statements. <a href="#additional-feature-bp">Additional Feature BP</a> would extend this further, also
supporting pipeline-body blocks that act nearly identically to <code>do</code> expressions.</p>
<h2>Private class fields, class decorators, nullish coalescing, and optional chaining</h2>
<p>This proposal’s compatibility with these four proposals depends on its choice of
tokens for its topic references: <code>#</code>/<code>##</code>/<code>###</code>/<code>...</code>, <code>@</code>/<code>@@</code>/<code>@@@</code>, or
<code>?</code>/<code>??</code>/<code>???</code>.</p>
<p>Because topic proposals are nullary operators, these are unambiguous with all
four proposals, with one exception: <code>?</code>/<code>??</code>/<code>???</code> is not compatible with
nullish coalescing and optional chaining’s current choice of <code>… ??: …</code>, <code>…??.…</code>,
<code>…??[…]</code>, and <code>…??(…)</code>. This is not a problem with <code>#</code>/<code>##</code>/<code>###</code>/<code>...</code> and with
<code>@</code>/<code>@@</code>/<code>@@@</code>.</p>
<p>In fact, if <a href="#additional-feature-pf">Additional Feature PF</a> and <a href="#additional-feature-np">Additional Feature NP</a> subsume the
current <a href="#partial-function-application">partial function application</a> proposal, which uses nullary <code>?</code>, then
single <code>?</code> might be freed up for optional chaining.</p>
<h2>Alternative pipeline Babel plugin</h2>
<p><a href="https://github.com/gajus/babel-plugin-transform-function-composition">Gajus Kuizinas wrote a Babel plugin for syntactic functional composition</a>, which may be useful to compare with this proposal’s
smart pipelines. Kuizinas’s plugin makes the choice to insert its pipeline
heads’ values into its pipeline bodies’ last parameter, which is convenient for
Ramda-style functions but not for Underscore-style functions.</p>
<table>
<thead>
<tr>
<th>With smart pipelines
<th>Kuizinas’ Babel plugin
<tbody>
<tr>
<td>
<pre><code class="language-js">apple
|&gt; foo('foo parameter 0', 'foo parameter 1', #)
|&gt; bar('bar parameter 0', #)
|&gt; baz('baz parameter 0', #)
</code></pre>
<td>
<pre><code class="language-js">apple
  ::foo('foo parameter 0', 'foo parameter 1')
  ::bar('bar parameter 0')
  ::baz('baz parameter 0')
</code></pre>
<p>From <a href="https://github.com/gajus/babel-plugin-transform-function-composition">Babel plugin for syntactic functional composition by Gajus Kuizinas</a>.</p>
<tr>
<td>
<pre><code class="language-js">{x: 'x'}
|&gt; assocPath(['y', 'a'], 'a', #)
|&gt; assocPath(['y', 'b'], 'b', #)
</code></pre>
<td>
<pre><code class="language-js">{x: 'x'}
  ::assocPath(['y', 'a'], 'a')
  ::assocPath(['y', 'b'], 'b')
</code></pre>
</table>
<h2>Alternative pipeline proposals</h2>
<p>There are several other alternative pipeline-operator proposals competing with
the smart-pipeline Core Proposal. The Core Proposal is only one variant of the
<a href="https://github.com/tc39/proposal-pipeline-operator/blob/37119110d40226476f7af302a778bc981f606cee/README.md">first pipeline-operator proposal</a> also championed by Ehrenberg; this variant
is listed as <a href="https://github.com/tc39/proposal-pipeline-operator/wiki#proposal-4-smart-mix"><strong>Proposal 4: Smart Mix</strong> in the pipe-proposal wiki</a>. The variant resulted from <a href="https://github.com/tc39/proposal-pipeline-operator/issues?q=placeholder">previous discussions in the previous
pipeline-operator proposal</a>,
discussions which culminated in an <a href="https://github.com/tc39/proposal-pipeline-operator/issues/89#issuecomment-363853394">invitation by Ehrenberg to try writing a
specification draft</a>.</p>
<p>All variants attempt to address the goals of <a href="#untangled-flow">untangled flow</a>,
<a href="#distinguishable-punctuators">distinguishable punctuators</a>, <a href="#terse-function-calls">terse function calls</a>, and <a href="#human-writability">human
writability</a>. But the authors of this proposal believe that the smart pipeline
operator may be the best choice among these competing proposals at fulfilling
all the <a href="#goals">goals</a> listed above.</p>
<p>Only the smart pipeline operator does not need to create unnecessary one-off
arrow functions for non-function-call expressions, which better fulfills the
goal of <a href="#zero-runtime-cost">zero runtime cost</a>. Only the smart pipeline operator has the <a href="#forward-compatibility">forward
compatibility</a> and <a href="#conceptual-generality">conceptual generality</a> to support not only <a href="#terse-function-calls">terse unary
function application</a> but also <a href="#terse-function-calls">terse N-ary function
application</a>, <a href="#terse-function-calls">terse expression application</a>, <a href="#terse-composition">terse function composition</a>, <a href="#terse-composition">terse
expression composition</a>, <a href="#terse-partial-application">terse partial application</a>, and
<a href="#terse-method-extraction">terse method extraction</a> – all with a single <a href="#cyclomatic-simplicity">cyclomatic simplicity</a> and
unified <a href="#conceptual-generality">general concept</a>.</p>
<p>Indeed, the original pipeline proposal was blocked from Stage 2 by TC39 during
its <a href="https://tc39.github.io/tc39-notes/2017-09_sep-26.html#11iia-pipeline-operator">60th meeting, on September 2017</a>. At that
time, several members expressed concern that it could be coordinated more with
the proposals for <a href="#function-binding">function binding</a> and <a href="#partial-function-application">partial function application</a> in a
more coherent approach. Smart pipelines open the door to such a coherent
approach with these and other use cases.</p>
<p>Smart pipelines and their <a href="#smart-body-syntax">smart body syntax</a> sacrifice a small amount of
<a href="#cyclomatic-simplicity">simplicity</a> in return for a vast amount of <a href="#expressive-versatility">expressive
versatility</a> and <a href="#conceptual-generality">conceptual generality</a>. And because it makes many of the
other operator proposals above either unnecessary or possibly simpler, it may
result in less complexity on average anyway. And thanks to its <a href="#syntactic-locality">syntactic
locality</a> and numerous <a href="#static-early-errors">statically detectable early errors</a>, the mental
burden on the developer in remembering <a href="#smart-body-syntax">smart body syntax</a> is light.</p>
<p>The benefits of smart pipelines on many real-world examples are well
demonstrated in the <a href="#motivation">Motivation</a> section above, and many of the examples are
not possible with the other pipeline proposals. It is hoped that the Core
Proposal is strongly considered by TC39, keeping in mind that it simple but
versatile syntax would open the door to addressing the use cases of many other
proposals in a uniform manner.</p>
<h1>Appendices</h1>
<h2>Smart body syntax</h2>
<p>Most pipelines will use the topic reference <code>#</code> in their bodies. This style of
pipeline is called <strong><a href="#topic-style">topic style</a></strong>.</p>
<p>For three simple cases – unary functions, unary async functions, and unary
constructors – you may omit the topic reference from the body. This is called
<strong><a href="#bare-style">bare style</a></strong>.</p>
<p>When a pipe is in bare style, we refer to the body as a <strong>bare function call</strong>,
<strong>bare async function call</strong>, or a <strong>bare constructor call</strong>, depending on the
rules of bare style. The body acts as just a simple reference to a function or
constructor, such as with <code>… |&gt; text.capitalize</code>, with <code>… |&gt; await DOM.fetch</code>,
and with <code>… |&gt; new User.Message</code>. The body’s value would then be called as a
unary function or constructor, without having to use the topic reference as an
explicit argument.</p>
<p>The two bare-style productions require no parameters, because they can only
be made up of identifiers and <code>.</code>, optionally preceded by <code>new</code> or <code>await</code>.</p>
<p>Also, <code>new</code> and <code>await</code> cannot be used on their own with bare style.
<code>… |&gt; await</code> 🚫 and <code>… |&gt; new</code> 🚫 are invalid pipelines. For <code>await</code>, instead
use either <code>… |&gt; await af</code> or use topic style: <code>… |&gt; af |&gt; await #</code>.</p>
<p>| Valid <a href="#topic-style">topic style</a>   | Valid <a href="#bare-style">bare style</a>                     | Invalid pipeline
| ----------------------- | ---------------------------------------- | --------------------
|<code>… \|&gt; f(#)</code>             |<code>… \|&gt; f</code>                                 |  <code>… \|&gt; f()</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; (f)</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; (f())</code> 🚫
|<code>… \|&gt; await af(#)</code>      |<code>… \|&gt; await af</code>                          | <code>… \|&gt; await af()</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; (await f)</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; (await f())</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; await (f)</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; await (f())</code> 🚫
|<code>… \|&gt; af \|&gt; await #</code>   | ″″                                       |  <code>… \|&gt; af \|&gt; await</code> 🚫
|<code>… \|&gt; new C(#)</code>         |<code>… \|&gt; new C</code>                             | <code>… \|&gt; new C()</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; (new C)</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; (new C())</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; new (C)</code> 🚫
| ″″                      | ″″                                       | <code>… \|&gt; new (C())</code> 🚫
|<code>… \|&gt; o.f(#)</code>           |<code>… \|&gt; o.f</code>                               | <code>… \|&gt; o.f()</code> 🚫
|<code>… \|&gt; await o.f(#)</code>     |<code>… \|&gt; await o.f</code>                         | <code>… \|&gt; await o.f()</code> 🚫
|<code>… \|&gt; new o.f(#)</code>       |<code>… \|&gt; new o.f</code>                           | <code>… \|&gt; new o.f()</code> 🚫
|<code>… \|&gt; o.f(arg, #)</code>      |<code>const f = $ =&gt; o::f(arg, $); … \|&gt; f</code>    | <code>… \|&gt; o.f(arg)</code> 🚫
|<code>… \|&gt; new o.C(arg, #)</code>  |<code>const f = $ =&gt; new o::C(arg, $); … \|&gt; f</code>| <code>… \|&gt; new o.C(arg)</code> 🚫
|<code>… \|&gt; o[symbol](#)</code>     |<code>const f = o[symbol]; … \|&gt; f</code>            | <code>… \|&gt; o[symbol]</code> 🚫
|<code>… \|&gt; new o[symbol](#)</code> |<code>const f = new o[symbol]; … \|&gt; f</code>        | <code>… \|&gt; new o[symbol]</code> 🚫
|<code>… \|&gt; o.make()(#)</code>      |<code>const f = o.make(); … \|&gt; f</code>             | <code>… \|&gt; o.make()</code> 🚫
|<code>… \|&gt; new o.make()(#)</code>  |<code>const C = o.make(); … \|&gt; new C</code>         | <code>… \|&gt; new o.make()</code> 🚫
|<code>… \|&gt; await o.make()(#)</code>|<code>const af = o.make(); … \|&gt; await af</code>     | <code>… \|&gt; await o.make()</code> 🚫
|<code>… \|&gt; await new o.make()(#)</code>|<code>const af = new o.make(); … \|&gt; await af</code>| <code>… \|&gt; new await o.make()</code> 🚫</p>
<h3>Bare style</h3>
<p>The <strong>bare style</strong> supports using simple identifiers, possibly with chains of
simple property identifiers. If there are any operators, parentheses (including
for method calls), brackets, or anything other than identifiers and dot
punctuators, then it is in <a href="#topic-style">topic style</a>, not in bare style.</p>
<h4>Bare function call</h4>
<p>If the body is a merely a simple reference, then that identifier is interpreted
to be a <strong>bare function call</strong>. The pipeline’s value will be the result of
calling the body with the current topic as its argument.</p>
<p>That is: <strong>if a pipeline</strong> is of the form<br />
<strong><em>topic</em> <code>|&gt;</code> <em>identifier</em></strong><br />
or <strong><em>topic</em> <code>|&gt;</code> <em>identifier0</em><code>.</code><em>identifier1</em></strong><br />
or <strong><em>topic</em> <code>|&gt;</code> <em>identifier0</em><code>.</code><em>identifier1</em><code>.</code><em>identifier2</em></strong><br />
or so forth,<br />
then the pipeline is a bare function call.</p>
<h4>Bare async function call</h4>
<p>If the body starts with <code>await</code>, followed by a mere identifier, optionally with
a chain of properties, and with no parentheses or brackets, then that identifier
is interpreted to be a <strong>bare async function call</strong>.</p>
<p>That is: <strong>if a pipeline</strong> is of the form<br />
<strong><em>topic</em> <code>|&gt;</code> <code>await</code> <em>identifier</em></strong><br />
or <strong><em>topic</em> <code>|&gt;</code> <code>await</code> <em>identifier0</em><code>.</code><em>identifier1</em></strong><br />
or <strong><em>topic</em> <code>|&gt;</code> <code>await</code> <em>identifier0</em><code>.</code><em>identifier1</em><code>.</code><em>identifier2</em></strong><br />
or so forth,<br />
then the pipeline is a bare async function call.</p>
<h4>Bare constructor call</h4>
<p>If the body starts with <code>new</code>, followed by a mere identifier, optionally with a
chain of properties, and with no parentheses or brackets, then that identifier
is interpreted to be a <strong>bare constructor</strong>.</p>
<p>That is: <strong>if a pipeline</strong> is of the form<br />
<strong><em>topic</em> <code>|&gt;</code> <code>new</code> <em>identifier</em></strong><br />
or <strong><em>topic</em> <code>|&gt;</code> <code>new</code> <em>identifier0</em><code>.</code><em>identifier1</em></strong><br />
or <strong><em>topic</em> <code>|&gt;</code> <code>new</code> <em>identifier0</em><code>.</code><em>identifier1</em><code>.</code><em>identifier2</em></strong><br />
or so forth,<br />
then the pipeline is a bare constructor call.</p>
<h3>Topic style</h3>
<p><strong>If a pipeline</strong> of the form <em>topic</em> |&gt; <em>body</em> does <strong><em>not</em> match the <a href="#bare-style">bare
style</a></strong> (that is, it is <em>not</em> a bare function call, bare async function call,
or bare constructor call), then it <strong>must be in topic style</strong>. And topic style
requires that there be a topic reference in the pipeline body; otherwise it is
an <a href="#static-early-errors">early error</a>.</p>
<p>A topic pipeline body is either:</p>
<ul>
<li>An expression at the <a href="#operator-precedence">precedence level once tighter than pipeline-level
expressions</a> – that is, a conditional-level expression.</li>
<li>A block <code>{</code> … <code>}</code> containing a list of statements, the last of which is used
as the result of the whole pipeline.</li>
</ul>
<h3>Practical consequences</h3>
<p>Therefore, a pipeline in <strong><a href="#bare-style">bare style</a> <em>never</em></strong> has <strong>parentheses <code>(…)</code> or
brackets <code>[…]</code></strong> in its body. Neither <code>… |&gt; object.method()</code> nor
<code>… |&gt; object.method(arg)</code> nor <code>… |&gt; object[symbol]</code> nor <code>… |&gt; object.createFunction()</code>
are in bare style (in fact, they all are Syntax Errors, due to their being in
<a href="#topic-style">topic style</a> without any topic references).</p>
<p><strong>When a body needs parentheses or brackets</strong>, then <strong>don’t use bare style</strong>,
and instead <strong>use a topic reference</strong> in the body (<a href="#topic-style">topic style</a>)…or <strong>assign
the body to a variable</strong>, then <strong>use that variable as a bare body</strong>.</p>
<h2>Operator precedence and associativity</h2>
<p>As a binary operation forming compound expressions, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">operator precedence and
associativity</a> of pipelining must be determined, relative
to other operations.</p>
<p>Precedence is tighter than arrow functions (<code>=&gt;</code>), assignment (<code>=</code>, <code>+=</code>, …),
generator <code>yield</code> and <code>yield *</code>, and sequence <code>,</code>; and it is looser than every
other type of expression. If the pipe operation were any tighter than this
level, its body would have to be parenthesized for many frequent types of
expressions. However, the result of a pipeline is also expected to often serve
as the body of an arrow function or a variable assignment, so it is tighter than
both types of expressions.</p>
<p>All operation-precedence levels in JavaScript are listed here, from <strong>tightest
to loosest</strong>. Each level may contain the parse types listed for that level –
<strong>as well as</strong> any expression types from any precedence level that is listed
<strong>above</strong> it.</p>
<p>| Level          | Type                    | Form           | Associativity / fixity   |
| -------------- | ----------------------- | -------------- | ------------------------ |
| Primary        | This                    |<code>this</code>          | Nullary                  |
| ″″             | <strong><a href="#core-proposal">Primary topic</a></strong>   |<strong><code>#</code></strong>         | ″″                       |
| ″″             | <strong><a href="#additional-feature-np">Secondary topic</a></strong> |<strong><code>##</code></strong>        | ″″                       |
| ″″             | <strong><a href="#additional-feature-np">Tertiary topic</a></strong>  |<strong><code>###</code></strong>       | ″″                       |
| ″″             | <strong><a href="#additional-feature-np">Rest topic</a></strong>      |<strong><code>...</code></strong>       | ″″                       |
| ″″             | Identifiers             |<code>a</code> …           | ″″                       |
| ″″             | Null                    |<code>null</code>          | ″″                       |
| ″″             | Booleans                |<code>true</code> <code>false</code>  | ″″                       |
| ″″             | Numerics                |<code>0</code> …           | ″″                       |
| ″″             | Arrays                  |<code>[…]</code>           | Circumfix                |
| ″″             | Object                  |<code>{…}</code>           | ″″                       |
| ″″             | Function                |<code>function (…) {…}</code>| ″″                     |
| ″″             | Classes                 |<code>class … {…}</code>   | ″″                       |
| ″″             | Generators              |<code>function * (…) {…}</code>| ″″                   |
| ″″             | Async functions         |<code>async function (…) {…}</code>| ″″               |
| ″″             | Regular expression      |<code>/…/…</code>          | ″″                       |
| ″″             | Templates               |<code>…`…`</code>      | Unchainable infix with circumfix|
| ″″             | Parentheses             |<code>(…)</code>           | Circumfix                |
| ″″             | <a href="#do-expressions"><code>do</code> expressions</a>    |<code>do { … }</code>      | ″″                       |
| LHS            | Dynamic properties      |<code>…[…]</code>          | LTR infix with circumfix |
| ″″             | Static properties       |<code>….…</code>           | ″″                       |
| ″″             | Tagged templates        |<code>…`…`</code>      | ″″                       |
| ″″             | Super properties        |<code>super.…</code>       | ″″                       |
| ″″             | Meta properties         |<code>meta.…</code>        | Unchainable prefix       |
| ″″             | Super call op.s         |<code>super(…)</code>      | ″″                       |
| ″″             | Object construction     |<code>new …</code>         | Prefix                   |
| ″″             | Function call           |<code>…(…)</code>          | LTR infix with circumfix |
| Postfix unary  | Postfix incrementing    |<code>…++</code>           | Postfix                  |
| ″″             | Postfix decrementing    |<code>…--</code>           | ″″                       |
| Prefix unary   | Prefix incrementing     |<code>++…</code>           | RTL prefix               |
| Prefix unary   | Prefix decrementing     |<code>--…</code>           | ″″                       |
| ″″             | Deletes                 |<code>delete …</code>      | ″″                       |
| ″″             | Voids                   |<code>void …</code>        | ″″                       |
| ″″             | Unary <code>+</code>/<code>-</code>           |<code>+…</code>            | ″″                       |
| ″″             | Bitwise NOT <code>~…</code>        |<code>~…</code>            | ″″                       |
| ″″             | Logical NOT <code>!…</code>        |<code>!…</code>            | ″″                       |
| ″″             | Awaiting                |<code>await …</code>       | ″″                       |
| Exponentiation | Exponentiation          |<code>… ** …</code>        | RTL infix                |
| Multiplicative | Multiplication          |<code>… * …</code>         | LTR infix                |
| ″″             | Division                |<code>… / …</code>         | ″″                       |
| ″″             | Modulus                 |<code>… % …</code>         | ″″                       |
| Additive       | Addition                |<code>… + …</code>         | ″″                       |
| ″″             | Subtraction             |<code>… - …</code>         | ″″                       |
| Bitwise shift  | Left shift              |<code>… &lt;&lt; …</code>        | ″″                       |
| ″″             | Right shift             |<code>… &gt;&gt; …</code>        | ″″                       |
| ″″             | Signed right shift      |<code>… &gt;&gt; …</code>        | ″″                       |
| Relational     | Greater than            |<code>… &lt; …</code>         | ″″                       |
| ″″             | Less than               |<code>… &gt; …</code>         | ″″                       |
| ″″             | Greater than / equal to |<code>… &gt;= …</code>        | ″″                       |
| ″″             | Less than / equal to    |<code>… &lt;= …</code>        | ″″                       |
| ″″             | Containment             |<code>… in …</code>        | ″″                       |
| ″″             | Instance-of             |<code>… instanceof …</code>| ″″                       |
| Equality       | Abstract equality       |<code>… == …</code>        | ″″                       |
| ″″             | Abstract inequality     |<code>… != …</code>        | ″″                       |
| ″″             | Strict equality         |<code>… === …</code>       | ″″                       |
| ″″             | Strict inequality       |<code>… !== …</code>       | ″″                       |
| Bitwise AND    |                         |<code>… &amp; …</code>         | ″″                       |
| Bitwise XOR    |                         |<code>… ^ …</code>         | ″″                       |
| Bitwise OR     |                         |<code>… \| …</code>        | ″″                       |
| Logical AND    |                         |<code>… ^^ …</code>        | ″″                       |
| Logical OR     |                         |<code>… \|\| …</code>      | ″″                       |
| Conditional    |                         |<code>… ? … : …</code>     | RTL ternary infix        |
| Pipeline       | <strong><a href="#core-proposal">Pipelines</a></strong>       |<strong><code>… \|&gt; …</code></strong>   | LTR infix                |
| Assignment     | <strong><a href="#additional-feature-pf">Pipeline functions</a></strong>|<strong><code>+&gt; …</code></strong>    | Prefix                   |
| ″″             | <strong><a href="#additional-feature-pf">Async pipeline functions</a></strong>|<strong><code>async +&gt; …</code></strong>| Prefix                   |
| ″″             | Arrow functions         |<code>… =&gt; …</code>        | RTL infix                |
| ″″             | Async arrow functions   |<code>async … =&gt; …</code>  | RTL infix                |
| ″″             | Assignment              |<code>… = …</code>         | ″″                       |
| ″″             |                         |<code>… += …</code>        | ″″                       |
| ″″             |                         |<code>… -= …</code>        | ″″                       |
| ″″             |                         |<code>… *= …</code>        | ″″                       |
| ″″             |                         |<code>… %= …</code>        | ″″                       |
| ″″             |                         |<code>… **= …</code>       | ″″                       |
| ″″             |                         |<code>… &lt;&lt;= …</code>       | ″″                       |
| ″″             |                         |<code>… &gt;&gt;= …</code>       | ″″                       |
| ″″             |                         |<code>… &gt;&gt;&gt;= …</code>      | ″″                       |
| ″″             |                         |<code>… &amp;= …</code>        | ″″                       |
| ″″             |                         |<code>… \|= …</code>       | ″″                       |
| Yield          | Yielding                |<code>yield …</code>       | Prefix                   |
| ″″             | Flat yielding           |<code>yield * …</code>     | ″″                       |
| ″″             | Spreading               |<code>...…</code>          | ″″                       |
| Comma level    | Comma                   |<code>…, …</code>          | LTR infix                |
| Base statements| Expression statements   |<code>…;</code>            | Postfix with <a href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion">ASI</a>     |
| ″″             | Empty statements        |<code>;</code>             | Nullary with <a href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion">ASI</a>     |
| ″″             | Debugger statements     |<code>debugger;</code>     | ″″                       |
| ″″             | Block statements        |<code>{…}</code>           | Circumfix                |
| ″″             | Labelled statements     |<code>…: …</code>          | Prefix                   |
| ″″             | Continue statements     |<code>continue …;</code>   | Circumfix with <a href="https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion">ASI</a>   |
| ″″             | Break statements        |<code>break …;</code>      | ″″                       |
| ″″             | Return statements       |<code>return …;</code>     | ″″                       |
| ″″             | Throw statements        |<code>throw …;</code>      | ″″                       |
| ″″             | Variable statements     |<code>var …;</code>        | ″″                       |
| ″″             | Lexical declarations    |<code>let …;</code>        | ″″                       |
| ″″             | ″″                      |<code>const …;</code>      | ″″                       |
| ″″             | Hoistable declarations  |<code>function … (…) {…}</code>| Circumfix with prefix|
| ″″             | ″″                      |<code>async function … (…) {…}</code>| ″″             |
| ″″             | ″″                      |<code>function * … (…) {…}</code>| ″″                 |
| ″″             | ″″                      |<code>async function * … (…) {…}</code>| ″″           |
| ″″             | Class declarations      |<code>class … {…}</code>   | ″″                       |
| Compound statements| If statements       |<code>if (…) … else …</code>| Circumfix with prefix   |
| ″″             | Switch statements       |<code>switch (…) …</code>  | ″″                       |
| ″″             | Iteration statements    |                | ″″                       |
| ″″             | With statements         |<code>with (…) {…}</code>  | ″″                       |
| ″″             | Try statements          |<code>try {… catch (…) {…} finally {…}}</code> | ″″   |
| Statement list | Case clause             |<code>case: …</code>       | Unchainable prefix       |
| Root           | Script                  |                | Root                     |
| ″″             | Module                  |                | ″″                       |</p>
<h2>Explanation of nomenclature</h2>
<p>The term <a href="https://en.wikipedia.org/wiki/Topic_and_comment">“<strong>topic</strong>” comes from linguistics</a> and have
precedent in prior programming languages’ use of “topic variables”.</p>
<p>The term “<strong>head</strong>” is preferred to “<strong>topic expression</strong>” because, in the
future, the topic concept could be extended to other syntaxes, as with
<a href="#additional-feature-tc">Additional Feature TC</a> and <a href="#additional-feature-tf">Additional Feature TF</a>, not just pipelines.</p>
<p>In addition, “head” is preferred to “<strong>LHS</strong>”, because “LHS” in the ECMAScript
specification usually refers to the <a href="https://tc39.github.io/ecma262/#sec-left-hand-side-expressions">LHS of assignments</a>,
which may be confusing. However, “topic expression” and “LHS” are still fine and
acceptable, if not imprecise, names for a pipeline’s head.</p>
<p>The term “<strong>topic reference</strong>” is preferred to the phrase “<strong>topic variable</strong>”
because the latter is a misnomer. The topic reference is <em>not</em> a variable
identifier. Unlike variables, it cannot be manually declared (<code>const #</code> is a
syntax error), nor can it be assigned with a value (<code># = 3</code> is a syntax error).</p>
<p>“Topic reference” is also preferred to “<strong>topic placeholder</strong>”, to avoid
confusion with the placeholders of another TC39 proposal – <a href="#partial-function-application">partial function
application</a>. These placeholders (currently denoted by nullary <code>?</code>) are of a
different nature than topic references. Instead of referring to a single value
bound earlier in the surrounding lexical context, these <strong>parameter
placeholders</strong> act as the parameter to a new function. When this new function is
called, those parameter placeholders will be bound to multiple argument values.</p>
<p>The term “<strong>body</strong>” is preferred instead of “<strong>RHS</strong>” because “topic” is
preferred to “LHS”. However, “RHS” is still a fine and acceptable name for the
body of the pipeline operator.</p>
<p>“<strong><a href="#bare-style">Bare style</a></strong>” can also be called “<strong>tacit style</strong>”, but the former is
preferred to the latter. Eventually, certain possible future extensions to the
topic concept, such as <a href="#additional-feature-tc">Additional Feature TC</a> and <a href="#additional-feature-tf">Additional Feature TF</a>,
would enable <a href="https://en.wikipedia.org/wiki/Tacit_programming">tacit programming</a> even without using bare-style pipelines.</p>
<h1>Term rewriting</h1>
<h2>Core Proposal</h2>
<p>Pipe bodies in <a href="#topic-style">topic style</a> can be rewritten into a nested <code>do</code> expression.
There are two ways to illustrate this equivalency. The first way is to <a href="#term-rewriting-with-autogenerated-variables">replace
each pipe expression’s topic references with an autogenerated variable</a>, which must be guaranteed to be
<a href="https://en.wikipedia.org/wiki/Hygienic_macro">lexically hygienic</a> and to not conflict with other variables. The alternative
way is to <a href="#term-rewriting-with-single-dummy-variable">use two variables – the topic reference <code>#</code> and a single dummy
variable</a> – which also preserves
<a href="https://en.wikipedia.org/wiki/Hygienic_macro">lexical hygiene</a>.</p>
<h3>Term rewriting with autogenerated variables</h3>
<p>The first way to illustrate the operator’s semantics is to replace each pipe
expression’s topic references with an autogenerated variable, which must be
guaranteed to not conflict with other variables.</p>
<p>Let us pretend that each pipe expression autogenerates a new, <a href="https://en.wikipedia.org/wiki/Hygienic_macro">lexically
hygienic</a> variable (<code>#₀</code>, <code>#₁</code>, <code>#₂</code>, <code>#₃</code>, …), which in turn replaces each
topic reference <code>#</code> in each pipeline body. (These <code>#ₙ</code> variables are not true
syntax; it is merely for illustrative purposes. You cannot actually assign or
use <code>#ₙ</code> variables.) Let us also group the expressions with left associativity
(although this is arbitrary, because <a href="#arbitrary-associativity">right associativity would also
work</a>).</p>
<p>With this notation, each line in this example would be equivalent to the other lines.</p>
<pre><code class="language-js">1 |&gt; # + 2 |&gt; # * 3

// Static term rewriting
(1 |&gt; # + 2) |&gt; # * 3
do { const #₀ = 1; # + 2 } |&gt; # * 3
do { const #₁ = do { const #₀ = 1; # + 2 }; #₁ * 3 }

// Runtime evaluation
do { const #₀ = do { 1 + 2 }; #₀ * 3 }
do { const #₀ = 3; #₀ * 3 }
do { do { 3 * 3 } }
9
</code></pre>
<p>Consider also the motivating first example above:</p>
<pre><code class="language-js">promise
|&gt; await #
|&gt; # ??: throw new TypeError()
|&gt; doubleSay // a bare unary function call
|&gt; capitalize // also a bare unary function call
|&gt; # + '!'
</code></pre>
<p>Under left associativity, this would be statically equivalent to the following:</p>
<pre><code class="language-js">do {
  const #₃ = do {
    const #₂ = do {
      const #₁ = do {
        const #₀ = await promise;
        #₀ ??: throw new TypeError()
      };
      doubleSay(#₁)
    };
    capitalize(#₂)
  };
  #₃ + '!'
}
</code></pre>
<p>In general, for each pipe expression <code>topic |&gt; body</code>, assuming that <code>body</code> is in
<a href="#topic-style">topic style</a>, that is, assuming that <code>body</code> contains an unshadowed topic
reference:</p>
<ul>
<li>Let <em>#<sub>n</sub></em> be a <a href="https://en.wikipedia.org/wiki/Hygienic_macro">hygienically autogenerated</a> topic
reference, <em>#<sub>n</sub></em>, where <var>n</var> is a number that would not conflict with
the name of any other autogenerated topic reference in the scope of the
entire pipe expression.</li>
<li>Also let <em>substituted Body</em> be <code>body</code> but with all instances of <code>#</code> replaced
with <em>#<sub>n</sub></em>.</li>
<li>Then the static term rewriting (left associative and inside to outside) would
simply be: <code>do { const</code> <em>#<sub>n</sub></em> <code>= topic;</code> <em>substituted Body</em> <code>}</code>.
This <code>do</code> expression would act as at the topic scope.</li>
</ul>
<h3>Term rewriting with single dummy variable</h3>
<p>The other way to demonstrate <a href="#topic-style">topic style</a> is to use two variables: the topic
reference <code>#</code> and single <a href="https://en.wikipedia.org/wiki/Hygienic_macro">lexically hygienic</a> dummy variable <code>•</code>. It should be
noted that <code>const # = …</code> is not a valid statement under this proposal’s actual
syntax; likewise, <code>•</code> is not a part of the proposal’s syntax. Both forms are for
illustrative purposes here only.</p>
<p>With this notation, no variable autogeneration is required; instead, the nested
<a href="#do-expressions"><code>do</code> expressions</a> will redeclare the same variables <code>#</code> and <code>•</code>, shadowing the
external variables of the same name as needed. The number example above becomes
the following. Each line is still equivalent to the other lines.</p>
<pre><code class="language-js">1 |&gt; # + 2 |&gt; # * 3

// Static term rewriting
(1 |&gt; # + 2) |&gt; # * 3
do { const • = 1; do { const # = •; # + 2 } } |&gt; # * 3
do { const • = (do { const • = 1; do { const # = •; # + 2 } }); do { const # = •; # * 3 } }

// Runtime evaluation
do { const • = do { do { const # = 1; # + 2 } }; do { const # = •; # * 3 } }
do { const • = do { do { const 1 + 2 } }; do { const # = •; # * 3 } }
do { const • = 3; do { const # = •; # * 3 } }
do { do { const # = 3; # * 3 } }
do { do { 3 * 3 } }
9
</code></pre>
<p>Consider also the motivating first example above:</p>
<pre><code class="language-js">promise
|&gt; await #
|&gt; # ??: throw new TypeError()
|&gt; doubleSay // a bare unary function call
|&gt; capitalize // also a bare unary function call
|&gt; # + '!'
</code></pre>
<p>Under left associativity, this would be statically equivalent to the following:</p>
<pre><code class="language-js">do {
  const • = do {
    const • = do {
      const • = do {
        const • = await promise;
        do { const # = •; # ??: throw new TypeError() }
      };
      do { const # = •; doubleSay(#) }
    };
    do { const # = •; capitalize(#) }
  };
  do { const # = •; # + '!' }
}
</code></pre>
<p>For each pipe expression, evaluated left associatively and inside to outside,
the steps of the computation would be:</p>
<ol>
<li>The head is first evaluated in the current lexical context.</li>
<li>The topic’s result is bound to a hidden special variable <code>•</code>.</li>
<li>In a new inner lexical context (the topic scope), the value of <code>•</code> is
bound to the topic reference <code>#</code>.</li>
<li>The pipe’s body is evaluated within this inner lexical context.</li>
<li>The pipe’s result is the result of the body.</li>
</ol>
<h2>Additional Feature NP</h2>
<p>[TODO]</p>
