<pre class=metadata>
title: Smart Pipelines
status: proposal
stage: −1
location: https://github.com/js-choi/proposal-smart-pipelines
copyright: false
contributors: J. S. Choi
</pre>
<script src=ecmarkup.js defer></script>
<link rel=stylesheet href=ecmarkup.css>

<emu-intro id=introduction>
<h1>Introduction</h1>
<p>This is the formal specification for a proposed "smart pipe operator" <code>|&gt;</code> in JavaScript. <a href=https://github.com/js-choi/proposal-smart-pipelines/blob/master/readme.md>See the proposal's explainer for an introduction</a>.</p>
</emu-intro>

<emu-clause id="sec-lexical-environments">
<h1>Lexical Environments</h1>

<ins class=block>
<emu-clause id="sec-lexical-topics">
<h1>Lexical Topics</h1>

<p>The <dfn>topic</dfn> of a Lexical Environment is at most one value of any ECMAScript language type, bound to the topic reference (`#`) within that Lexical Environment at the Lexical Environment's time of instantiation. Every Lexical Environment has at all times one <dfn>topic binding status</dfn>: *"void"*, *"bound"*, and *"clear"*.</p>

<p>At the time of certain declarative environments' construction, those declarative environments' topic binding statuses may change from *"void"* to either *"bound"* or *"clear"*, but a reverse of this change cannot occur afterward.</p>

<p>A <dfn>topic-void environment</dfn> is a Lexical Environment that establishes a topic-void binding. A <dfn>topic-void binding</dfn> prevents the topic reference `#` from being used within the environment at all. In particular, in a topic-void environment, the topic reference cannot be used to refer to the topic binding of its outer environment. All Lexical Environments are topic-void environments by default at the time of their construction.</p>

<emu-note>
<p>The concept of topic-void environments prevents accidental usage of outer environments' topics within an inner environment.</p>
</emu-note>

<p>A <dfn>topic-binding environment</dfn> is a Lexical Environment that establishes a <dfn>topic binding</dfn>, which in turn is a binding of the topic reference (`#`) to a topic (a value of any ECMAScript language type).</p>

<emu-note>
<p>The only Lexical Environments that are topic-binding environments are those that are associated with |PipelineTopicBody| and which were created with the TopicPipelineBodyInstantiation abstract operation.</p>
</emu-note>

<p>A <dfn>topic-clear environment</dfn> is a Lexical Environment that is [TODO]</p>

<p>A <dfn>topic-opaque environment</dfn> is a Lexical Environment that [TODO]</p>
</emu-clause>
</ins>

<!-- es6num="8.1.1" -->
<emu-clause id="sec-environment-records">
<h1>Environment Records</h1>

<emu-table id="table-15" caption="Abstract Methods of Environment Records">
<table>
<tbody>
<tr>
<th>
Method
</th>
<th>
Purpose
</th>
</tr>
<tr>
<td>
HasBinding(N)
</td>
<td>
Determine if an Environment Record has a binding for the String value _N_. Return *true* if it does and *false* if it does not.
</td>
</tr>
<tr>
<td>
CreateMutableBinding(N, D)
</td>
<td>
Create a new but uninitialized mutable binding in an Environment Record. The String value _N_ is the text of the bound name. If the Boolean argument _D_ is *true* the binding may be subsequently deleted.
</td>
</tr>
<tr>
<td>
CreateImmutableBinding(N, S)
</td>
<td>
Create a new but uninitialized immutable binding in an Environment Record. The String value _N_ is the text of the bound name. If _S_ is *true* then attempts to set it after it has been initialized will always throw an exception, regardless of the strict mode setting of operations that reference that binding.
</td>
</tr>
<tr>
<td>
InitializeBinding(N, V)
</td>
<td>
Set the value of an already existing but uninitialized binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and is a value of any ECMAScript language type.
</td>
</tr>
<tr>
<td>
SetMutableBinding(N, V, S)
</td>
<td>
Set the value of an already existing mutable binding in an Environment Record. The String value _N_ is the text of the bound name. _V_ is the value for the binding and may be a value of any ECMAScript language type. _S_ is a Boolean flag. If _S_ is *true* and the binding cannot be set throw a *TypeError* exception.
</td>
</tr>
<tr>
<td>
GetBindingValue(N, S)
</td>
<td>
Returns the value of an already existing binding from an Environment Record. The String value _N_ is the text of the bound name. _S_ is used to identify references originating in strict mode code or that otherwise require strict mode reference semantics. If _S_ is *true* and the binding does not exist throw a *ReferenceError* exception. If the binding exists but is uninitialized a *ReferenceError* is thrown, regardless of the value of _S_.
</td>
</tr>
<tr>
<td>
DeleteBinding(N)
</td>
<td>
Delete a binding from an Environment Record. The String value _N_ is the text of the bound name. If a binding for _N_ exists, remove the binding and return *true*. If the binding exists but cannot be removed return *false*. If the binding does not exist return *true*.
</td>
</tr>
<tr>
<td>
HasThisBinding()
</td>
<td>
Determine if an Environment Record establishes a `this` binding. Return *true* if it does and *false* if it does not.
</td>
</tr>
<tr>
<td>
HasSuperBinding()
</td>
<td>
Determine if an Environment Record establishes a `super` method binding. Return *true* if it does and *false* if it does not.
</td>
</tr>
<tr>
<td>
<ins>GetTopicBindingStatus()</ins>
</td>
<td>
<ins>Determine the status of an Environment Record's topic (`#`) binding. Return *"bound"* if it establishes a topic binding, return *"void"* if it establishes a topic-void binding, and return *"clear"* if it establishes no topic binding.</ins>
</td>
</tr>
<tr>
<td>
<ins>GetTopicBindingValue()</ins>
</td>
<td>
<ins>If the value returned by an Environment Record's GetTopicBindingStatus method is *"bound"*, return the topic value (that is, the `#` value) of an Environment Record. If the value returned by GetTopicBindingStatus is not *"bound"*, throw a *ReferenceError* exception.</ins>
</td>
</tr>
<tr>
<td>
WithBaseObject()
</td>
<td>
If this Environment Record is associated with a `with` statement, return the with object. Otherwise, return *undefined*.
</td>
</tr>
</tbody>
</table>
</emu-table>

<!-- es6num="8.1.1.1" -->
<emu-clause id="sec-declarative-environment-records">
<h1>Declarative Environment Records</h1>
<p>Each declarative Environment Record is associated with an ECMAScript program scope containing variable, constant, let, class, module, import, and/or function declarations. A declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.</p>

<ins class=block>
<p>Declarative Environment Records have the additional state fields listed in <emu-xref href="#table-61"></emu-xref>.</p>

<emu-table id="table-61" caption="Additional Fields of Declarative Environment Records">
<table>
<tbody>
<tr>
<th>
Method
</th>
<th>
Value
</th>
<th>
Purpose
</th>
</tr>
<tr>
<td>
[[TopicBindingStatus]]
</td>
<td>
Any
</td>
<td>
If the value is *"bound"*, the associated program scope binds the topic (that is, it binds `#`) to a value. If the value is *"void"*, the scope voids the topic, which hides its outer environment's topic. If the value is *"clear"*, the scope establishes neither a topic binding nor a topic-void binding.
</td>
</tr>
<tr>
<td>
[[TopicValue]]
</td>
<td>
Any
</td>
<td>
If the value of [[TopicBindingStatus]] is *"bound"*, this is the topic value (that is, the `#` value). The default value for [[TopicBindingStatus]] is *undefined*.
</td>
</tr>
</tbody>
</table>
</emu-table>

<p>Declarative Environment Records support all of the abstract methods of Environment Records listed in <emu-xref href="#table-15"></emu-xref>. In addition, declarative Environment Records support the methods listed in <emu-xref href="#table-62"></emu-xref>.</p>

<emu-table id="table-62" caption="Additional Methods of Declarative Environment Records">
<table>
<tbody>
<tr>
<th>
Method
</th>
<th>
Purpose
</th>
</tr>
<tr>
<td>
ClearTopicBinding()
</td>
<td>
Clear the topic binding of an Environment Record, which allows the topic binding (that is, the `#` binding) of its outer Lexical Environment to become visible to its inner Lexical Environment.
</td>
</tr>
<tr>
<td>
BindTopicValue(V)
</td>
<td>
Establish the topic binding (that is, the `#` binding) of an Environment Record and set the topic binding's value. _V_ is the value for the binding and is a value of any ECMAScript language type. Afterward, the value returned by the Environment Record's GetTopicBindingStatus method is *"bound"*.
</td>
</tr>
</tbody>
</table>
</emu-table>
</ins>

<p>The behaviour of the concrete <ins>and additional</ins> specification methods for declarative Environment Records is defined by the following algorithms.</p>

<ins class=block>
<emu-clause id="sec-declarative-environment-records-gettopicbindingstatus">
<h1>GetTopicBindingStatus ( )</h1>
<p>The concrete Environment Record method GetTopicBindingStatus for declarative Environment Records returns the value of their field [[TopicBindingStatus]], which is *"void"* by default. The value may also be *"clear"* (if the declarative Environment Record's ClearTopicBinding method has been called) or *"bound"* (if its BindTopicValue method has been called). An Environment Record with a void topic binding may change its status to *"clear"* or *"bound"* but never vice versa.</p>
<emu-alg>
1. Let _envRec_ be the function Environment Record for which the method was invoked.
2. Return _envRec_.[[TopicBindingStatus]].
</emu-alg>
</emu-clause>

<emu-clause id="sec-declarative-environment-records-gettopicbindingvalue">
<h1>GetTopicBindingValue ( )</h1>
<p>The method GetTopicBindingValue for declarative Environment Records is guaranteed to be called only when their topic bindings have already been established.</p>
<emu-alg>
1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
2. Assert: _envRec_.[[TopicBindingStatus]] is *"bound"*.
3. Return _envRec_.[[TopicValue]].
</emu-alg>
</emu-clause>
</ins>

<!-- es6num="8.1.1.2" -->
<emu-clause id="sec-object-environment-records">
<h1>Object Environment Records</h1>

<ins class=block>
<emu-clause id="sec-object-environment-records-gettopicbindingstatus">
<h1>GetTopicBindingStatus ( )</h1>
<p>Regular object Environment Records have void topic bindings.</p>
<emu-alg>
1. Return *"void"*.
</emu-alg>
</emu-clause>
</ins>

</emu-clause>

<!-- es6num="8.1.1.4" -->
<emu-clause id="sec-global-environment-records">
<h1>Global Environment Records</h1>

<ins class=block>
<emu-clause id="sec-global-environment-records-gettopicbindingstatus">
<h1>GetTopicBindingStatus ( )</h1>
<p>Global Environment Records have void topic bindings.</p>
<emu-alg>
1. Return *"void"*.
</emu-alg>
</emu-clause>
</ins>
</emu-clause>

<!-- es6num="8.1.1.5" -->
<emu-clause id="sec-module-environment-records">
<h1>Module Environment Records</h1>
</emu-clause>

</emu-clause>

<emu-clause id=sec-punctuators>
<h1>Punctuators</h1>

<ins class=block>
<emu-grammar>
Punctuator :: one of
  `{` `(` `)` `[` `]` `.` `...` `;` `,` `<` `>` `<=` `>=` `==` `!=` `===` `!==` `+` `-` `*` `%` `**` `++` `--` `<<` `>>` `>>>` `&` `|` `^` `!` `~` `&&` `||` `?` `:` <ins>`|>` `#`</ins> `=` `+=` `-=` `*=` `%=` `**=` `<<=` `>>=` `>>>=` `&=` `|=` `^=` `=>`
</emu-grammar>
</ins>

<del class=block>
<emu-grammar>
Punctuator :: one of
  `{` `(` `)` `[` `]` `.` `...` `;` `,` `<` `>` `<=` `>=` `==` `!=` `===` `!==` `+` `-` `*` `%` `**` `++` `--` `<<` `>>` `>>>` `&` `|` `^` `!` `~` `&&` `||` `?` `:` `=` `+=` `-=` `*=` `%=` `**=` `<<=` `>>=` `>>>=` `&=` `|=` `^=` `=>`
</emu-grammar>
</del>

</emu-clause>

<emu-clause id=sec-primary-expression>
<h1>Primary Expression</h1>
<h2>Syntax</h2>

<emu-grammar>
PrimaryExpression[Yield, Await] :
  `this`
  <ins>`#`</ins>
  IdentifierReference[?Yield, ?Await]
  Literal
  ArrayLiteral[?Yield, ?Await]
  ObjectLiteral[?Yield, ?Await]
  FunctionExpression
  ClassExpression[?Yield, ?Await]
  GeneratorExpression
  AsyncFunctionExpression
  AsyncGeneratorExpression
  RegularExpressionLiteral
  TemplateLiteral[?Yield, ?Await, ~Tagged]
  CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
</emu-grammar>

<ins class=block>
<emu-clause id="sec-gettopicenvironment" aoid="GetTopicEnvironment">
<h1>Runtime Semantics: GetTopicEnvironment</h1>
<emu-note>
<p>Get Topic Environment finds the Environment Record that currently supplies the topic binding (the binding of `#`) or that voids the topic binding. That is, it finds the running execution topic's nearest-ancestral topic-opaque environment, which is the nearest-ancestral outer environment that does not have a topic binding status of *"clear"*.</p>
</emu-note>
<p>When the abstract operation GetTopicEnvironment is called the following steps are performed:</p>
<emu-alg>
1. Let _lex_ be the running execution context's Lexical Environment.
2. Repeat,
  1. Let _envRec_ be _lex_'s EnvironmentRecord.
  2. Let _status_ be _envRec_.GetTopicBindingStatus().
  3. If _status_ is not *"clear"*, return _envRec_.
  4. Let _outer_ be the value of _lex_'s outer environment reference.
  5. Set _lex_ to _outer_.
3. Return _lex_.
</emu-alg>
</emu-clause>
</ins>

</emu-clause>

<emu-clause id=sec-assignment-operators>
<h1>Assignment Operators</h1>
<h2>Syntax</h2>

<emu-grammar>
AssignmentExpression[In, Yield, Await] :
  <del>ConditionalExpression[?In, ?Yield, ?Await]</del>
  <ins>PipelineExpression[?In, ?Yield, ?Await]</ins>
  [+Yield] YieldExpression[?In, ?Await]
  ArrowFunction[?In, ?Yield, ?Await]
  AsyncArrowFunction[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
</emu-grammar>

</emu-clause>

<ins class=block>
<emu-clause id=sec-pipeline-operator>
<h1>Pipeline Operator</h1>
<h2>Syntax</h2>

<emu-grammar>
PipelineExpression[In, Yield, Await] :
  ConditionalExpression[?In, ?Yield, ?Await]
  PipelineExpression[?In, ?Yield, ?Await] `|>` PipelineBody[?In, ?Yield, ?Await]

PipelineBody[In, Yield, Await] :
  PipelineBareFunctionCall
  PipelineBareConstructorCall
  PipelineTopicBody[?In, ?Yield, ?Await]

PipelineBareFunctionCall :
  SimpleReference

PipelineBareConstructorCall :
  `new` SimpleReference

SimpleReference :
  IdentifierReference
  SimpleReference `.` IdentifierName

PipelineTopicBody[In, Yield, Await] :
  ConditionalExpression[?In, ?Yield, ?Await]
</emu-grammar>

<emu-clause id=sec-pipeline-operator-static-semantics-contains>
<h1>Static Semantics: Contains</h1>
With parameter _symbol_.

<emu-grammar>PipelineBareFunctionCall : SimpleReference</emu-grammar>
<emu-alg>
1. If symbol is `#`, return *false*.
2. For each child node _child_ of this Parse Node, do
  1. If _child_ is an instance of _symbol_, return *true*.
  2. If _child_ is an instance of a nonterminal, then
    1. Let _contained_ be the result of _child_ Contains _symbol_.
    2. If _contained_ is *true*, return *true*.
2. Return *false*.
</emu-alg>
</emu-clause>

<emu-clause id=sec-pipeline-operator-static-semantics-early-errors>
<h1>Static Semantics: Early Errors</h1>

<emu-grammar>PipelineTopicBody : ConditionalExpression</emu-grammar>
<emu-alg>
* It is a Syntax Error if _ConditionalExpression_ Contains `#` is *false*.
* It is a Syntax Error if _ConditionalExpression_ is covering a _YieldExpression_.
</emu-alg>
</emu-clause>

<emu-clause id=sec-pipeline-operator-runtime-semantics-evaluation>
<h1>Runtime Semantics: Evaluation</h1>

<emu-grammar>PipelineExpression : PipelineExpression `|>` PipelineBody</emu-grammar>
<emu-alg>
1. [TODO]
</emu-alg>
</emu-clause>

<emu-clause id=sec-pipeline-operator-runtime-semantics-pipelinebodyevaluation>
<h1>Runtime Semantics: PipelineBodyEvaluation</h1>
With parameter _headValue_.

<emu-grammar>PipelineBareFunctionCall : SimpleReference</emu-grammar>
<emu-alg>
1. Let _ref_ be the result of evaluating _SimpleReference_.
2. Let _func_ be ? GetValue(_ref_).
3. Let _thisCall_ be this |PipelineBareFunctionCall|.
4. Let _tailCall_ be IsInTailPosition(_thisCall_).
5. Let _Arguments_ be a List containing the one element which is _headValue_.
6. Return ? EvaluateCall(_func_, _ref_, _Arguments_, _tailCall_).
</emu-alg>

[TODO: More body evaluations]

</emu-clause>

[TODO: Other static semantics]

</emu-clause>
</ins>

<emu-clause id=sec-arrow-function-definitions>
<h1>Arrow Function Definitions</h1>

<emu-clause id=sec-arrow-function-definitions-static-semantics-contains>
<h1>Static Semantics: Contains</h1>

<emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
<emu-alg>
1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, <del>`super` or `this`</del> <ins>`super`, `this`, or `#`</ins>, return *false*.
2. If _ArrowParameters_ Contains _symbol_ is *true*, return *true*.
3. Return |ConciseBody| Contains _symbol_.

<emu-note>
Normally, Contains does not look inside most function forms. However, Contains is used to detect `new.target`, <ins>`this`, `super`, and `#`</ins> usage within an ArrowFunction.
</emu-note>

</emu-alg>
</emu-clause>

</emu-clause>

