<pre class=metadata>
title: Smart Pipelines
status: proposal
stage: −1
location: https://github.com/js-choi/proposal-smart-pipelines
copyright: false
contributors: J. S. Choi
</pre>
<script src=ecmarkup.js defer></script>
<link rel=stylesheet href=ecmarkup.css>

<emu-intro id=introduction>
<h1>Introduction</h1>
<p>This is the formal specification for a proposed "smart pipeline operator" <code>|&gt;</code> in JavaScript. See <a href=https://github.com/js-choi/proposal-smart-pipelines/blob/master/readme.md>the proposal's explainer</a> for the proposal's background, motivation, usage examples, explanation, and information on planned add-on proposals.</p>
</emu-intro>

<emu-clause id=executable-code-and-execution-contexts>
<h1>Executable Code and Execution Contexts</h1>

<emu-clause id="sec-lexical-environments">
<h1>Lexical Environments</h1>

<ins class=block>

<emu-note type=editor>
<p>This section amends the <a href=https://tc39.github.io/ecma262/#sec-lexical-environments>original Lexical Environments clause</a>.</p>
</emu-note>

<emu-clause id="sec-lexical-topics">
<h1>Lexical Topics</h1>

<emu-note type=editor>
<p>This is a new subsection of the <a href=https://tc39.github.io/ecma262/#sec-lexical-environments>original Lexical Environments clause</a>.</p>
</emu-note>

<p>The <dfn>topic binding</dfn> of a Lexical Environment immutably binds the topic reference `#` to one value of any ECMAScript language type (called the <dfn>topic value</dfn> or simply the <dfn>topic</dfn>), within that Lexical Environment, at the Lexical Environment's time of instantiation. The topic of a Lexical Environment conceptually serves as the value that the lexical context is “about”. Many Lexical Environments do not have topic bindings: in particular, object and global environments never have topic bindings.</p>

<p>A <dfn>topic-binding environment</dfn> is a Lexical Environment that establishes a topic binding. The <dfn>topic environment</dfn> of the running execution context is its Lexical Environment's nearest outer environment that is a topic-binding environment, as defined by the abstract operator GetTopicEnvironment.</p>

<emu-note>
<p>The only Lexical Environments that are topic-binding environments are those that are associated with |PipelineTopicBody| and which were created with the TopicPipelineBodyInstantiation abstract operation.</p>

<p>In general, syntax productions that define top-level or inner program scopes containing nested |Statement|s (such as |IfStatement|, |WithStatement|, |FunctionDeclaration|, |MethodDefinition|, |Script|, and |Module|) <strong>may not</strong> contain the topic reference `#`. Such productions create topic-binding environments that bind topic to *undefined* (the default value of the topic binding), but any use of the topic reference within them (as detected by the static semantic rule Contains) would trigger early errors defined for those productions.</p>

<p>However syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; within their scopes, such topic references would not trigger those early errors.</p>
</emu-note>

</emu-clause>
</ins>

<!-- es6num="8.1.1" -->
<emu-clause id="sec-environment-records">
<h1>Environment Records</h1>

<emu-note type=editor>
<p>This section amends the <a href=https://tc39.github.io/ecma262/#sec-environment-records>original Environment Records clause</a>.</p>
</emu-note>

<emu-table id="table-15" caption="Abstract Methods of Environment Records">
<table>
<tbody>
<tr>
<th>
Method
</th>
<th>
Purpose
</th>
</tr>
<tr>
<td>
<ins>HasTopic()</ins>
</td>
<td>
<ins>Determine the status of an Environment Record's topic binding (`#` binding). Return *true* if it establishes a topic binding and *false* if it does not.</ins>
</td>
</tr>
</tbody>
</table>
</emu-table>

<!-- es6num="8.1.1.1" -->
<emu-clause id="sec-declarative-environment-records">
<h1>Declarative Environment Records</h1>

<emu-note type=editor>
<p>This section amends the <a href=https://tc39.github.io/ecma262/#sec-declarative-environment-records>original Declarative Environment Records clause</a>.</p>
</emu-note>

<p>Each declarative Environment Record is associated with an ECMAScript program scope containing variable, constant, let, class, module, import, and/or function declarations. A declarative Environment Record binds the set of identifiers defined by the declarations contained within its scope.</p>

<ins class=block>
<p>Declarative Environment Records have the additional state fields listed in <emu-xref href="#table-61"></emu-xref>.</p>

<emu-table id="table-61" caption="Additional Fields of Declarative Environment Records">
<table>
<tbody>
<tr>
<th>
Method
</th>
<th>
Value
</th>
<th>
Purpose
</th>
</tr>
<tr>
<td>
[[TopicBindingStatus]]
</td>
<td>
*false* | *true*
</td>
<td>
If [[TopicBindingStatus]]'s value is *false*, the Environment Record binds the topic (that is, it binds `#`) to a value. If the value is *false*, the Environment Record has no topic binding. [[TopicBindingStatus]]'s default value is *false*. Its value may be changed from *false* to *true* but never vice versa.
</td>
</tr>
<tr>
<td>
[[TopicValue]]
</td>
<td>
Any
</td>
<td>
If the value of [[TopicBindingStatus]] is *true*, [[TopicValue]] is the topic value of the Environment Record (that is, the value of `#` within its program scope). The default value for [[TopicValue]] is *undefined*.
</td>
</tr>
</tbody>
</table>
</emu-table>

<p>Declarative Environment Records support all of the abstract methods of Environment Records listed in <emu-xref href="#table-15"></emu-xref>. In addition, declarative Environment Records support the methods listed in <emu-xref href="#table-62"></emu-xref>.</p>

<emu-table id="table-62" caption="Additional Methods of Declarative Environment Records">
<table>
<tbody>
<tr>
<th>
Method
</th>
<th>
Purpose
</th>
</tr>
<tr>
<td>
BindTopicValue(V)
</td>
<td>
Establish the immutable topic binding (that is, the `#` binding) of this Environment Record and set the topic binding's value. _V_ is the value for the binding and is a value of any ECMAScript language type. Afterward, the value returned by the Environment Record's HasTopicBinding method is *true*. This method cannot be called more than once on any single Environment Record.
</td>
</tr>
<tr>
<td>
<ins>GetTopicBinding()</ins>
</td>
<td>
<ins>Return the value of the topic binding (`#` binding) of this Environment Record. This method is never called when the HasTopic method would return *false*.</ins>
</td>
</tr>
</tbody>
</table>
</emu-table>
</ins>

<p>The behaviour of the concrete <ins>and additional</ins> specification methods for declarative Environment Records is defined by the following algorithms.</p>

<ins class=block>
<emu-clause id="sec-declarative-environment-records-hastopic">
<h1>HasTopic ( )</h1>
<p>The concrete Environment Record method HasTopic for declarative Environment Records returns the value of the record's field [[TopicBindingStatus]], which is *false* by default. The value may instead be *true* if its BindTopicValue method has been called.</p>
<emu-alg>
1. Let _envRec_ be the function Environment Record for which the method was invoked.
2. Return _envRec_.[[TopicBindingStatus]].
</emu-alg>
</emu-clause>

<emu-clause id="sec-declarative-environment-records-gettopicbinding">
<h1>GetTopicBinding ( )</h1>
<p>The method GetTopicBinding for declarative Environment Records returns the value of the record's topic binding. It must not be called when the record's topic binding has not already been established.</p>
<emu-note>
<p>That is, Environment Records will never be called on an Environment Record before the BindTopicValue method has been called.</p>
</emu-note>
<emu-alg>
1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
2. Assert: _envRec_.[[TopicBindingStatus]] is *true*.
3. Return _envRec_.[[TopicValue]].
</emu-alg>
</emu-clause>

<emu-clause id="sec-declarative-environment-records-bindtopicvalue">
<h1>BindTopicValue ( )</h1>
<p>The method BindTopicValue for declarative Environment Records is guaranteed to be called only when the Environment Records still have void topic bindings.</p>
<emu-alg>
1. Let _envRec_ be the declarative Environment Record for which the method was invoked.
2. Assert: _envRec_.[[TopicBindingStatus]] is *false*.
3. Set _envRec_.[[TopicValue]] to _V_.
4. Set _envRec_.[[TopicBindingStatus]] to *true*.
4. Return NormalCompletion(~empty~).
</emu-alg>
</emu-clause>
</ins>

<!-- es6num="8.1.1.2" -->
<emu-clause id="sec-object-environment-records">
<h1>Object Environment Records</h1>

<ins class=block>

<emu-note type=editor>
<p>This section amends the <a href=https://tc39.github.io/ecma262/#sec-object-environment-records>original Object Environment Records clause</a>.</p>
</emu-note>

<emu-clause id="sec-object-environment-records-hastopic">
<h1>HasTopic ( )</h1>
<p>Regular object Environment Records never have topic bindings.</p>
<emu-alg>
1. Return *false*.
</emu-alg>
</emu-clause>
</ins>

</emu-clause>

<!-- es6num="8.1.1.4" -->
<emu-clause id="sec-global-environment-records">
<h1>Global Environment Records</h1>

<ins class=block>

<emu-note type=editor>
<p>This section amends the <a href=https://tc39.github.io/ecma262/#sec-object-environment-records>original Global Environment Records clause</a>.</p>
</emu-note>

<emu-clause id="sec-global-environment-records-hastopic">
<h1>HasTopic ( )</h1>
<p>Global Environment Records never have topic bindings.</p>
<emu-alg>
1. Return *false*.
</emu-alg>
</emu-clause>
</ins>
</emu-clause>

</emu-clause>
</emu-clause>
</emu-clause>
</emu-clause>

<emu-clause id=sec-ecmascript-language-lexical-grammar>
<h1>ECMAScript Language: Lexical Grammar</h1>

<ins class=block>
<emu-note type=editor>
<p>See also the <a href=https://tc39.github.io/ecma262/#sec-ecmascript-language-lexical-grammar>original ECMAScript Language: Lexical Grammar clause</a>.</p>
</emu-note>
</ins>

<emu-clause id=sec-punctuators>
<h1>Punctuators</h1>

<ins class=block>
<emu-note type=editor>
<p>This section amends the <a href=https://tc39.github.io/ecma262/#sec-punctuators>original Punctuators clause</a>.</p>
</emu-note>

<emu-grammar>
Punctuator :: one of
  `{` `(` `)` `[` `]` `.` `...` `;` `,` `<` `>` `<=` `>=` `==` `!=` `===` `!==` `+` `-` `*` `%` `**` `++` `--` `<<` `>>` `>>>` `&` `|` `^` `!` `~` `&&` `||` `?` `:` <ins>`|&gt;` `#`</ins> `=` `+=` `-=` `*=` `%=` `**=` `<<=` `>>=` `>>>=` `&=` `|=` `^=` `=>`
</emu-grammar>
</ins>

<del class=block>
<emu-grammar>
Punctuator :: one of
  `{` `(` `)` `[` `]` `.` `...` `;` `,` `<` `>` `<=` `>=` `==` `!=` `===` `!==` `+` `-` `*` `%` `**` `++` `--` `<<` `>>` `>>>` `&` `|` `^` `!` `~` `&&` `||` `?` `:` `=` `+=` `-=` `*=` `%=` `**=` `<<=` `>>=` `>>>=` `&=` `|=` `^=` `=>`
</emu-grammar>
</del>

</emu-clause>
</emu-clause>

<emu-clause id=sec-ecmascript-language-expressions>
<h1>ECMAScript Language: Expressions</h1>

<emu-clause id=sec-primary-expression>
<h1>Primary Expression</h1>
<h2>Syntax</h2>

<emu-grammar>
PrimaryExpression[Yield, Await] :
  `this`
  <ins>`#`</ins>
  IdentifierReference[?Yield, ?Await]
  Literal
  ArrayLiteral[?Yield, ?Await]
  ObjectLiteral[?Yield, ?Await]
  FunctionExpression
  ClassExpression[?Yield, ?Await]
  GeneratorExpression
  AsyncFunctionExpression
  AsyncGeneratorExpression
  RegularExpressionLiteral
  TemplateLiteral[?Yield, ?Await, ~Tagged]
  CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
</emu-grammar>

<ins class=block>
<emu-clause id="sec-topic-reference">
<h1>The Topic Reference `#`</h1>
<p>The <dfn>topic reference</dfn>, which is the token `#`, is a nullary operator that evaluates to the value of the current Lexical Environment's topic. The topic reference acts as if it were a special variable: implicitly bound to the topic value, yet still lexically scoped. But `#` is not actually an |IdentifierName| and the topic reference is not a variable, and it cannot be bound by typical assignment; instead, it is immutably bound to a value during the instantiation of certain topic-binding environments.</p>
<p>The concept of lexical topic binding is further discussed in <emu-xref href="#sec-lexical-topics">Lexical Topics</emu-xref> and in <emu-xref href="#sec-declarative-environment-records">Declarative Environment Records</emu-xref>.</p>

<emu-note>
<p>The only Lexical Environments that are topic-binding environments are those that are associated with |PipelineTopicBody| and which were created with the TopicPipelineBodyInstantiation abstract operation.</p>

<p>In general, syntax productions that define top-level or inner program scopes containing nested |Statement|s (such as |IfStatement|, |WithStatement|, |FunctionDeclaration|, |MethodDefinition|, |Script|, and |Module|) <strong>may not</strong> contain the topic reference `#`. Such productions create topic-binding environments that bind topic to *undefined* (the default value of the topic binding), but any use of the topic reference within them (as detected by the static semantic rule Contains) would trigger early errors defined for those productions.</p>

<p>However syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; within their scopes, such topic references would not trigger those early errors.</p>
</emu-note>

<emu-clause id="sec-gettopicenvironment" aoid="GetTopicEnvironment">
<h1>Runtime Semantics: GetTopicEnvironment</h1>
<emu-note>
<p>GetTopicEnvironment finds the Environment Record that currently supplies the topic binding (the binding of `#`) or that voids the topic binding. That is, it finds the running execution topic's nearest-ancestral topic-binding environment, which is the nearest-ancestral outer environment that has a topic binding status of *true*. It is <strong>never</strong> called when there is no topic environment.</p>
</emu-note>
<p>When the abstract operation GetTopicEnvironment is called the following steps are performed:</p>
<emu-alg>
1. Let _lex_ be the running execution context's Lexical Environment.
2. Repeat,
  1. Let _envRec_ be _lex_'s EnvironmentRecord.
  2. Let _status_ be _envRec_.HasTopic().
  3. If _status_ is *true*, return _envRec_.
  4. Assert: _lex_ is not a global environment.
  4. Let _outer_ be the value of _lex_'s outer environment reference.
  6. Set _lex_ to _outer_.
3. Return _lex_.
</emu-alg>

<emu-note>
<p>The loop in step 2 will always terminate because the list of environments will always end before reaching the global environment. GetTopicEnvironment will never be called when there is no topic-binding environment in the list of environments.</p>
<p>This is because how, in general, syntax productions that define top-level scopes (such as |Script| and |Module|) are syntactically forbidden to contain the topic reference `#`. Any use of the topic reference within those productions (as detected by the static semantic rule Contains) would trigger early errors defined for those productions. It is only within productions that hide the topic reference from Contains (such as |PipelineTopicBody|) that the topic reference is syntactically permitted.</p>
</emu-note>
</emu-clause>

<emu-clause id="sec-gettopicenvironment" aoid="GetTopicEnvironment">
<h1>Runtime Semantics: ResolveTopicBinding</h1>
<emu-note>
<p>ResolveTopicBinding returns the value to which the topic reference `#` is bound, using the Lexical Environment of the running execution context. It is <strong>never</strong> called when there is no topic environment.</p>
</emu-note>
<p>When the abstract operation GetTopicEnvironment is called the following steps are performed:</p>
<emu-alg>
1. Let _envRec_ be GetTopicEnvironment().
2. Assert: _envRec_.HasTopic() is true.
3. Return ? _envRec_.GetTopicBinding().
</emu-alg>
</emu-clause>

<emu-clause id=sec-topic-reference-runtime-semantics-evaluation>
<h1>Runtime Semantics: Evaluation</h1>

<emu-grammar>PrimaryExpression : `#`</emu-grammar>
<emu-alg>
1. Return ? ResolveTopicBinding().
</emu-alg>
</emu-clause>

</emu-clause>
</ins>
</emu-clause>

<ins class=block>
<emu-clause id=sec-pipeline-operator>
<h1>Pipeline Operator</h1>
<h2>Syntax</h2>
<emu-grammar type=definition>
PipelineExpression[In, Yield, Await] :
  ConditionalExpression[?In, ?Yield, ?Await]
  PipelineExpression[?In, ?Yield, ?Await] `|&gt;` PipelineBody[?In, ?Yield, ?Await]

PipelineBody[In, Yield, Await] :
  PipelineBareFunctionCall
  PipelineBareConstructorCall
  PipelineTopicBody[?In, ?Yield, ?Await]

PipelineBareFunctionCall :
  SimpleReference

PipelineBareConstructorCall :
  `new` SimpleReference

SimpleReference :
  IdentifierReference
  SimpleReference `.` IdentifierName

PipelineTopicBody[In, Yield, Await] :
  ConditionalExpression[?In, ?Yield, ?Await]
</emu-grammar>

<emu-clause id=sec-pipeline-operator-static-semantics-early-errors>
<h1>Static Semantics: Early Errors</h1>

<emu-grammar>PipelineTopicBody : ConditionalExpression</emu-grammar>
<emu-alg>
* It is a Syntax Error if _ConditionalExpression_ Contains `#` is *false*.
* It is a Syntax Error if _ConditionalExpression_ is covering a _YieldExpression_.
</emu-alg>
</emu-clause>

<emu-clause id=sec-pipeline-operator-static-semantics-contains>
<h1>Static Semantics: Contains</h1>
With parameter _symbol_.

<emu-grammar>PipelineBareFunctionCall : SimpleReference</emu-grammar>
<emu-alg>
1. If symbol is `#`, return *false*.
2. For each child node _child_ of this Parse Node, do
  1. If _child_ is an instance of _symbol_, return *true*.
  2. If _child_ is an instance of a nonterminal, then
    1. Let _contained_ be the result of _child_ Contains _symbol_.
    2. If _contained_ is *true*, return *true*.
2. Return *false*.
</emu-alg>
</emu-clause>

<emu-clause id=sec-pipeline-operator-runtime-semantics-evaluation>
<h1>Runtime Semantics: TopicPipelineBodyInstantiation</h1>
<emu-note>
<p>This abstract operation constructs, instantiates, then returns a new declarative Lexical Environment for a topic pipeline body. It creates an immutable topic binding in that declarative environment using the given _topic_.</p>
</emu-note>
<p>Topic Pipeline Instantiation is performed as follows using arguments code, env, and topic.</p>
<ul>
<li>_topic_ is the value to which _env_'s topic reference will be bound.</li>
<li>_env_ is the Lexical Environment in which the topic binding is to be created.</li>
</ul>

<emu-grammar>PipelineExpression : PipelineExpression `|&gt;` PipelineBody</emu-grammar>
<emu-alg>
1. Let _envRec_ be env's Environment Record.
2. Assert: _envRec_ is a declarative Environment Record.
3. Assert: _envRec_.HasTopic() is *false*.
4. Assert: _envRec_.GetTopicBinding() is *undefined*.
5. Perform ! _envRec_.BindTopicValue(_topic_).
</emu-alg>
</emu-clause>

<emu-clause id=sec-pipeline-operator-runtime-semantics-pipelinebodyevaluation>
<h1>Runtime Semantics: PipelineBodyEvaluation</h1>
<p>With parameter _headValue_.</p>

<emu-grammar>PipelineBareFunctionCall : SimpleReference</emu-grammar>
<p>This algorithm is an altered version of the algorithm of <emu-xref href="#sec-function-calls-runtime-semantics-evaluation">Function Calls, Runtime Semantics: Evaluation</emu-xref>, modified as follows:</p>
<p>Steps 1 and 2 are removed.</p>
<p>Step 3 is replaced by:</p>
<emu-alg type="i">
1. Let _arguments_ be a List containing the one element which is _headValue_.
</emu-alg>
<p>Step 4 is replaced by:</p>
<emu-alg type="i">
2. Let _functionExpr_ be the |MemberExpression| that is covered by |SimpleReference|.
3. Let _ref_ be the result of evaluating _functionExpr_.
</emu-alg>

<emu-grammar>PipelineBareConstructorCall : `new` SimpleReference</emu-grammar>
<emu-alg>
1. Let _constructExpr_ be the |NewExpression| that is covered by |SimpleReference|.
2. Return ? EvaluateNew(NewExpression, ~empty~).
</emu-alg>

<emu-grammar>PipelineTopicBody : ConditionalExpression</emu-grammar>
<emu-alg>
1. Let _oldEnv_ be the running execution context's Lexical Environment.
2. Let _pipelineBodyEnv_ be New Declarative Environment(_oldEnv_).
3. Perform TopicPipelineBodyInstantiation(_headValue_, _pipelineBodyEnv_).
4. Set the running execution context's Lexical Environment to _pipelineBodyEnv_.
5. Let _pipelineValue_ be the result of evaluating |ConditionalExpression|.
6. Set the running execution context's Lexical Environment to _oldEnv_.
7. Return _pipelineValue_.
</emu-alg>

</emu-clause>

<emu-clause id=sec-pipeline-operator-runtime-semantics-evaluation>
<h1>Runtime Semantics: Evaluation</h1>

<emu-grammar>PipelineExpression : PipelineExpression `|&gt;` PipelineBody</emu-grammar>
<emu-alg>
1. Let _headRef_ be the result of evaluating |PipelineExpression|.
2. Let _headValue_ be the result of ? GetValue(_headRef_).
3. Let _bodyRef_ be PipelineBodyEvaluation of |PipelineBody| with argument _headValue_.
4. Return ? GetValue(_bodyRef_).
</emu-alg>
</emu-clause>

</emu-clause>
</emu-clause>
</ins>

<emu-clause id=sec-assignment-operators>
<h1>Assignment Operators</h1>
<h2>Syntax</h2>

<emu-grammar>
AssignmentExpression[In, Yield, Await] :
  <del>ConditionalExpression[?In, ?Yield, ?Await]</del>
  <ins>PipelineExpression[?In, ?Yield, ?Await]</ins>
  [+Yield] YieldExpression[?In, ?Await]
  ArrowFunction[?In, ?Yield, ?Await]
  AsyncArrowFunction[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
</emu-grammar>

<ins class=block>
<emu-note type=editor>
<p>A planned add-on proposal would add a pipeline-function operator |PipelineFunctionExpression| to |AssignmentExpression|, which would replace |PipelineExpression|.</p>
</emu-note>
</ins>

</emu-clause>
</emu-clause>

<emu-clause id=sec-ecmascript-language-statements-and-declarations>
<h1>ECMAScript Language: Statements and Declarations</h1>

<emu-clause id=sec-block>
<h1>Block</h1>

<emu-clause id=sec-block-static-semantics-early-errors>
<h1>Static Semantics: Early Errors</h1>
<emu-grammar>BlockStatement : Block</emu-grammar>
<ul>
<li>
  <ins>It is a Syntax Error if |Block| Contains `#` is *true*.</ins>
</li>
</ul>

<ins class=block>
<emu-note>
<p>In general, syntax productions that define inner program scopes containing nested |Statement|s, including |BlockStatement|, may <strong>not</strong> contain a topic reference `#`. However, syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; such topic references would not trigger the early error above.</p>
<p>Although |BlockStatement| cannot contain topic reference `#`, |Block| itself can. Certain uses of |Block| in statement-level productions, such as |Block| in |TryStatement|, also allow the topic reference.</p>
</emu-note>
</ins>

</emu-clause>
</emu-clause>

<emu-clause id=sec-if-statement>
<h1>The `if` statement</h1>

<emu-clause id=sec-if-statement-static-semantics-early-errors>
<h1>Static Semantics: Early Errors</h1>
<emu-grammar>
IfStatement :
  `if` `(` Expression `)` Statement `else` Statement
  `if` `(` Expression `)` Statement
</emu-grammar>
<ul>
<li>
<ins>It is a Syntax Error if |StatementList| Contains `#` is *true*.</ins>
</li>
</ul>

<ins class=block>
<emu-note>
<p>In general, syntax productions that define inner program scopes containing nested |Statement|s, including |IfStatement|, may <strong>not</strong> contain a topic reference `#`. However, syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; within their scopes, such topic references would not trigger the early error above.</p>
</emu-note>

<emu-note type=editor>
<p>This early error is forward compatible with a planned add-on proposal to make `if` statements bind the topic reference to the value of |Expression|.</p>
</emu-note>
</ins>

</emu-clause>
</emu-clause>

<emu-clause id=sec-iteration-statements>
<h1>Iteration Statements</h1>

<emu-clause id="sec-semantics-static-semantics-early-errors">
<h1>Static Semantics: Early Errors</h1>
<emu-grammar>
IterationStatement :
  `do` Statement `while` `(` Expression `)` `;`
  `while` `(` Expression `)` Statement
  `for` `(` Expression? `;` Expression? `;` Expression? `)` Statement
  `for` `(` `var` VariableDeclarationList `;` Expression? `;` Expression? `)` Statement
  `for` `(` LexicalDeclaration Expression? `;` Expression? `)` Statement
  `for` `(` LeftHandSideExpression `in` Expression `)` Statement
  `for` `(` `var` ForBinding `in` Expression `)` Statement
  `for` `(` ForDeclaration `in` Expression `)` Statement
  `for` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
  `for` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  `for` `(` ForDeclaration `of` AssignmentExpression `)` Statement
  `for` `await` `(` LeftHandSideExpression `of` AssignmentExpression `)` Statement
  `for` `await` `(` `var` ForBinding `of` AssignmentExpression `)` Statement
  `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
</emu-grammar>
<ul>
<li><ins>It is a Syntax Error if |Statement| Contains `#` is *true*.</ins></li>
</ul>

<ins class=block>
<emu-note>
<p>In general, syntax productions that define inner program scopes containing nested |Statement|s, including iteration statements, may <strong>not</strong> contain a topic reference `#`. However, syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; within their scopes, such topic references would not trigger the early error above.</p>
</emu-note>

<emu-note type=editor>
<p>This early error is forward compatible with a planned add-on proposal to make `for`-`of` and `for`-`in` statements bind the topic reference to the value of each iterator value or object property key.</p>
</emu-note>
</ins>
</emu-clause>

</emu-clause>

<emu-clause id=sec-with-statement>
<h1>The `with` statement</h1>

<emu-clause id=sec-with-statement-static-semantics-early-errors>
<h1>Static Semantics: Early Errors</h1>
<emu-grammar>WithStatement : `with` `(` Expression `)` Statement</emu-grammar>
<ul>
<li>
<ins>It is a Syntax Error if |Statement| Contains `#` is *true*.</ins>
</li>
</ul>

<ins class=block>
<emu-note>
<p>In general, syntax productions that define inner program scopes containing nested |Statement|s, including |WithStatement|, may <strong>not</strong> contain a topic reference `#`. However, syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; within their scopes, such topic references would not trigger the early error above.</p>
</emu-note>

<emu-note type=editor>
<p>This early error is not planned to be removed by an add-on proposal.</p>
</emu-note>
</ins>

</emu-clause>
</emu-clause>

<emu-clause id=sec-switch-statement>
<h1>The `switch` statement</h1>

<emu-clause id=sec-switch-statement-static-semantics-early-errors>
<h1>Static Semantics: Early Errors</h1>
<emu-grammar>SwitchStatement : `switch` Expression StatementList</emu-grammar>
<ul>
<li>
<ins>It is a Syntax Error if |StatementList| Contains `#` is *true*.</ins>
</li>
</ul>

<ins class=block>
<emu-note>
<p>In general, syntax productions that define inner program scopes containing nested |Statement|s, including |CaseBlock|, may <strong>not</strong> contain a topic reference `#`. However, syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; within their scopes, such topic references would not trigger the early error above.</p>
</emu-note>

<emu-note type=editor>
<p>This early error is forward compatible with a planned add-on proposal to make `switch` statements bind the topic reference to the value of |Expression|.</p>
</emu-note>
</ins>

</emu-clause>
</emu-clause>

<emu-clause id=sec-try-statement>
<h1>The `try` statement</h1>

<emu-clause id=sec-try-statement-static-semantics-early-errors>
<h1>Static Semantics: Early Errors</h1>
<emu-grammar>
Catch : `catch` `(` CatchParameter `)` Block</emu-grammar>
<ul>
<li>
<ins>It is a Syntax Error if |Block| Contains `#` is *true*.</ins>
</li>
</ul>

<emu-grammar>
Finally : `finally` Block</emu-grammar>
<ul>
<li>
<ins>It is a Syntax Error if |Block| Contains `#` is *true*.</ins>
</li>
</ul>

<ins class=block>
<emu-note>
<p>In general, syntax productions that define inner program scopes containing nested |Statement|s, including |Catch| and |Finally|, may <strong>not</strong> contain a topic reference `#`. However, syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; within their scopes, such topic references would not trigger the early errors above.</p>
<p>Furthermore, the `try` block itself (|Block| in |TryStatement|) <strong>may</strong> contain topic references, assuming that |TryStatement| is contained within a parse that is also allowed to contain the topic reference. During runtime, such topic references would refer to the outer environment's topic binding. Along with arrow functions (that is, |FunctionBody| in |ConciseBody|), this behaviour is unlike that of any other syntax production containing |Statement|.</p>
</emu-note>

<emu-note type=editor>
<p>This early error is forward compatible with a planned add-on proposal to make `catch` statements bind the topic reference to the value of their caught errors.</p>
</emu-note>
</ins>

</emu-clause>

</emu-clause>
</emu-clause>

<emu-clause id=sec-ecmascript-language-functions-and-classes>
<h1>ECMAScript Language: Functions and Classes</h1>

<emu-clause id=sec-function-definitions>
<h1>Function Definitions</h1>

<emu-clause id=sec-function-definitions-static-semantics-early-errors>
<h1>Static Semantics: Early Errors</h1>
<emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
<ul>
<li>
<ins>If |FunctionStatementList| is not the |FunctionBody| of a |ConciseBody|, it is a Syntax Error if |FunctionStatementList| Contains `#` is *true*.</ins>
</li>
</ul>

<ins class=block>
<emu-note>
<p>Arrow functions' |ConciseBody| <strong>may</strong> contain the topic reference `#`, as long as |ConciseBody| is within a parse that is also allowed to contain the topic reference. During runtime, such topic references would refer to the outer environment's topic binding.</p>
<p>Along with |Block| in |TryStatement|, this behaviour is <strong>unlike</strong> that of any other syntax production containing |Statement|. In general, syntax productions that define inner program scopes containing nested |Statement|s, including |FunctionBody|, may <strong>not</strong> contain a topic reference `#`.</p>
</emu-note>
</ins>

</emu-clause>
</emu-clause>

<emu-clause id=sec-arrow-function-definitions>
<h1>Arrow Function Definitions</h1>

<emu-clause id=sec-arrow-function-definitions-static-semantics-contains>
<h1>Static Semantics: Contains</h1>

<emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
<emu-alg>
1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, <del>`super` or `this`</del> <ins>`super`, `this`, or `#`</ins>, return *false*.
2. If _ArrowParameters_ Contains _symbol_ is *true*, return *true*.
3. Return |ConciseBody| Contains _symbol_.
</emu-alg>

<emu-note>
Normally, Contains does not look inside most function forms. However, Contains is used to detect `new.target`, <ins>`this`, `super`, and `#`</ins> usage within an ArrowFunction.
</emu-note>

</emu-clause>
</emu-clause>
</emu-clause>

<emu-clause id=sec-ecmascript-language-scripts-and-modules>
<h1>ECMAScript Language: Scripts and Modules</h1>

<emu-clause id=sec-scripts>
<h1>Scripts</h1>

<emu-clause id=sec-scripts-static-semantics-early-errors>
<h1>Scripts: Early Errors</h1>
<emu-grammar>ScriptBody : StatementList</emu-grammar>
<ul>
<li>
<ins>It is a Syntax Error if |StatementList| Contains `#` is *true*.</ins>
</li>
</ul>

<ins class=block>
<emu-note>
<p>In general, top-level program scope, including |Script|, may <strong>not</strong> contain a topic reference `#`. However, syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; within their scopes, such topic references would not trigger the early error above.</p>
</emu-note>

<emu-note type=editor>
<p>This early error is not planned to be removed by an add-on proposal.</p>
</emu-note>
</ins>

</emu-clause>
</emu-clause>

<emu-clause id=sec-modules>
<h1>Modules</h1>

<emu-clause id=sec-modules-static-semantics-early-errors>
<h1>Scripts: Early Errors</h1>
<emu-grammar>ModuleItem : StatementListItem</emu-grammar>
<ul>
<li>
<ins>It is a Syntax Error if |StatementListItem| Contains `#` is *true*.</ins>
</li>
</ul>

<ins class=block>
<emu-note>
<p>In general, a top-level program scope, including |Module|, may <strong>not</strong> contain a topic reference `#`. However, syntax productions associated with topic-binding environments (such as |PipelineTopicBody|) hide their own inner topic references from Contains; within their scopes, such topic references would not trigger the early error above.</p>
</emu-note>

<emu-note type=editor>
<p>This early error is not planned to be removed by an add-on proposal.</p>
</emu-note>
</ins>

</emu-clause>
</emu-clause>

</emu-clause>
