<pre class=metadata>
title: Smart Pipelines
status: proposal
stage: −1
location: https://github.com/js-choi/proposal-smart-pipelines
copyright: false
contributors: J. S. Choi
</pre>
<script src=ecmarkup.js defer></script>
<link rel=stylesheet href=ecmarkup.css>

<emu-intro id=introduction>
<h1>Introduction</h1>
<p>This is the formal specification for a proposed “smart pipe operator” <code>|&gt;</code> in JavaScript. <a href=https://github.com/js-choi/proposal-smart-pipelines/blob/master/readme.md>See the proposal’s explainer for an introduction</a>.</p>
</emu-intro>

[TODO: Environments]

<emu-clause id=sec-punctuators>
<h1>Punctuators</h1>

<ins class=block>
<emu-grammar>
Punctuator :: one of
  `{` `(` `)` `[` `]` `.` `...` `;` `,` `<` `>` `<=` `>=` `==` `!=` `===` `!==` `+` `-` `*` `%` `**` `++` `--` `<<` `>>` `>>>` `&` `|` `^` `!` `~` `&&` `||` `?` `:` <ins>`|>` `#`</ins> `=` `+=` `-=` `*=` `%=` `**=` `<<=` `>>=` `>>>=` `&=` `|=` `^=` `=>`
</emu-grammar>
</ins>

<del class=block>
<emu-grammar>
Punctuator :: one of
  `{` `(` `)` `[` `]` `.` `...` `;` `,` `<` `>` `<=` `>=` `==` `!=` `===` `!==` `+` `-` `*` `%` `**` `++` `--` `<<` `>>` `>>>` `&` `|` `^` `!` `~` `&&` `||` `?` `:` `=` `+=` `-=` `*=` `%=` `**=` `<<=` `>>=` `>>>=` `&=` `|=` `^=` `=>`
</emu-grammar>
</del>

</emu-clause>

<emu-clause id=sec-primary-expression>
<h1>Primary Expression</h1>
<h2>Syntax</h2>

<emu-grammar>
PrimaryExpression[Yield, Await] :
  `this`
  <ins>`#`</ins>
  IdentifierReference[?Yield, ?Await]
  Literal
  ArrayLiteral[?Yield, ?Await]
  ObjectLiteral[?Yield, ?Await]
  FunctionExpression
  ClassExpression[?Yield, ?Await]
  GeneratorExpression
  AsyncFunctionExpression
  AsyncGeneratorExpression
  RegularExpressionLiteral
  TemplateLiteral[?Yield, ?Await, ~Tagged]
  CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await]
</emu-grammar>

</emu-clause>

<emu-clause id=sec-assignment-operators>
<h1>Assignment Operators</h1>
<h2>Syntax</h2>

<emu-grammar>
AssignmentExpression[In, Yield, Await] :
  <del>ConditionalExpression[?In, ?Yield, ?Await]</del>
  <ins>PipelineExpression[?In, ?Yield, ?Await]</ins>
  [+Yield] YieldExpression[?In, ?Await]
  ArrowFunction[?In, ?Yield, ?Await]
  AsyncArrowFunction[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] `=` AssignmentExpression[?In, ?Yield, ?Await]
  LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]
</emu-grammar>

</emu-clause>

<ins class=block>
<emu-clause id=sec-pipeline-operator>
<h1>Pipeline Operator</h1>
<h2>Syntax</h2>

<emu-grammar>
PipelineExpression[In, Yield, Await] :
  ConditionalExpression[?In, ?Yield, ?Await]
  PipelineExpression[?In, ?Yield, ?Await] `|>` PipelineBody[?In, ?Yield, ?Await]

PipelineBody[In, Yield, Await] :
  PipelineBareFunctionCall
  PipelineBareConstructorCall
  PipelineTopicBody[?In, ?Yield, ?Await]

PipelineBareFunctionCall :
  SimpleReference

PipelineBareConstructorCall :
  `new` SimpleReference

SimpleReference :
  IdentifierReference
  SimpleReference `.` IdentifierName

PipelineTopicBody[In, Yield, Await] :
  ConditionalExpression[?In, ?Yield, ?Await]
</emu-grammar>

<emu-clause id=sec-pipeline-operator-static-semantics-contains>
<h1>Static Semantics: Contains</h1>
With parameter _symbol_.

<emu-grammar>PipelineBareFunctionCall : SimpleReference</emu-grammar>
<emu-alg>
1. If symbol is `#`, return *false*.
2. For each child node _child_ of this Parse Node, do
  1. If _child_ is an instance of _symbol_, return *true*.
  2. If _child_ is an instance of a nonterminal, then
    1. Let _contained_ be the result of _child_ Contains _symbol_.
    2. If _contained_ is *true*, return *true*.
2. Return *false*.
</emu-alg>
</emu-clause>

<emu-clause id=sec-pipeline-operator-static-semantics-early-errors>
<h1>Static Semantics: Early Errors</h1>

<emu-grammar>PipelineTopicBody : ConditionalExpression</emu-grammar>
<emu-alg>
* It is a Syntax Error if _ConditionalExpression_ Contains `#` is *false*.
* It is a Syntax Error if _ConditionalExpression_ is covering a _YieldExpression_.
</emu-alg>
</emu-clause>

<emu-clause id=sec-pipeline-operator-runtime-semantics-evaluation>
<h1>Runtime Semantics: Evaluation</h1>

<emu-grammar>PipelineExpression : PipelineExpression</emu-grammar>
<emu-alg>
1. Let _envRec_ be _env_'s Environment Record.
2. Assert: _envRec_ is a declarative Environment Record.
3. Assert: _envRec_.GetTopicBindingStatus() is *"void"*.
4. Assert: _envRec_.GetTopic() is *undefined*.
5. Perform ! _envRec_.BindTopicValue(_topic_).
</emu-alg>
</emu-clause>

<emu-clause id=sec-pipeline-operator-runtime-semantics-pipelinebodyevaluation>
<h1>Runtime Semantics: PipelineBodyEvaluation</h1>
With parameter _headValue_.

<emu-grammar>PipelineBareFunctionCall : SimpleReference</emu-grammar>
<emu-alg>
1. Let_ref_ be the result of evaluating _SimpleReference_.
2. Let_func_ be ? GetValue(_ref_).
3. Let_thisCall_ be this |PipelineBareFunctionCall|.
4. Let_tailCall_ be IsInTailPosition(_thisCall_).
5. Let_Arguments_ be a List containing the one element which is _headValue_.
6. Return ? EvaluateCall(_func_, _ref_, _Arguments_, _tailCall_).
</emu-alg>

[TODO: More body evaluations]

</emu-clause>

[TODO: Other static semantics]

</emu-clause>
</ins>

<emu-clause id=sec-arrow-function-definitions>
<h1>Arrow Function Definitions</h1>

<emu-clause id=sec-arrow-function-definitions-static-semantics-contains>
<h1>Static Semantics: Contains</h1>

<emu-grammar>ArrowFunction : ArrowParameters `=>` ConciseBody</emu-grammar>
<emu-alg>
1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, <del>`super` or `this`</del> <ins>`super`, `this`, or `#`</ins>, return *false*.
2. If _ArrowParameters_ Contains _symbol_ is *true*, return *true*.
3. Return |ConciseBody| Contains _symbol_.

<emu-note>
Normally, Contains does not look inside most function forms. However, Contains is used to detect `new.target`, <ins>`this`, `super`, and `#`</ins> usage within an ArrowFunction.
</emu-note>

</emu-alg>
</emu-clause>

</emu-clause>

