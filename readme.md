<nav><details>
<summary><strong>Table of Contents</strong></summary>

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [Smart pipelines](#smart-pipelines)
  - [Background](#background)
  - [Motivation](#motivation)
  - [Goals](#goals)
    - [“Don’t break my code.”](#dont-break-my-code)
      - [Backward compatibility](#backward-compatibility)
      - [Zero runtime cost](#zero-runtime-cost)
      - [Forward compatibility](#forward-compatibility)
    - [“Don’t make me overthink.”](#dont-make-me-overthink)
      - [Syntactic locality](#syntactic-locality)
      - [Cyclomatic simplicity](#cyclomatic-simplicity)
      - [Expressive versatility](#expressive-versatility)
    - [“Don’t shoot me in the foot.”](#dont-shoot-me-in-the-foot)
      - [Simple scoping](#simple-scoping)
      - [Static analyzability](#static-analyzability)
      - [Arbitrary associativity](#arbitrary-associativity)
    - [“Make my code easier to read.”](#make-my-code-easier-to-read)
      - [Untangled flow](#untangled-flow)
      - [Distinguishable punctuators](#distinguishable-punctuators)
      - [Terse parentheses](#terse-parentheses)
      - [Terse variables](#terse-variables)
      - [Terse function calls](#terse-function-calls)
    - [Other Goals](#other-goals)
      - [Conceptual generality](#conceptual-generality)
      - [Human writability](#human-writability)
      - [Novice learnability](#novice-learnability)
  - [Nomenclature](#nomenclature)
    - [Pipe operator, pipeline, pipeline-level expression](#pipe-operator-pipeline-pipeline-level-expression)
    - [Head, head value, body, pipeline value, topic style, bare style](#head-head-value-body-pipeline-value-topic-style-bare-style)
    - [Topic, topic reference](#topic-topic-reference)
  - [Grammar](#grammar)
    - [Lexical grammar](#lexical-grammar)
    - [Grammar parameters](#grammar-parameters)
    - [Syntactic grammar](#syntactic-grammar)
    - [Operator precedence](#operator-precedence)
    - [Topic reference • Grammar](#topic-reference-%E2%80%A2-grammar)
    - [Pipeline-level expressions • Grammar](#pipeline-level-expressions-%E2%80%A2-grammar)
    - [Smart body syntax](#smart-body-syntax)
      - [Bare style • Grammar](#bare-style-%E2%80%A2-grammar)
        - [Bare function call • Grammar](#bare-function-call-%E2%80%A2-grammar)
        - [Bare constructor call • Grammar](#bare-constructor-call-%E2%80%A2-grammar)
        - [Simple reference • Grammar](#simple-reference-%E2%80%A2-grammar)
        - [Practical consequences](#practical-consequences)
      - [Topic style • Grammar](#topic-style-%E2%80%A2-grammar)
  - [Static semantics](#static-semantics)
    - [Static Contains](#static-contains)
    - [Static Early Errors](#static-early-errors)
      - [Topical pipelines must use the topic](#topical-pipelines-must-use-the-topic)
      - [Topical pipelines that are yield expressions must be parenthesized](#topical-pipelines-that-are-yield-expressions-must-be-parenthesized)
    - [Other static semantic rules](#other-static-semantic-rules)
  - [Runtime semantics](#runtime-semantics)
    - [Environment Records](#environment-records)
      - [Method • Get Topic Binding Status](#method-%E2%80%A2-get-topic-binding-status)
      - [Method • Get Topic Binding](#method-%E2%80%A2-get-topic-binding)
      - [Method • Clear Topic Value](#method-%E2%80%A2-clear-topic-value)
      - [Method • Bind Topic Value](#method-%E2%80%A2-bind-topic-value)
    - [Abstract • Get Topic Environment](#abstract-%E2%80%A2-get-topic-environment)
    - [Abstract • Resolve Topic Binding](#abstract-%E2%80%A2-resolve-topic-binding)
    - [Topic reference • Evaluation](#topic-reference-%E2%80%A2-evaluation)
    - [Topic style • Topic Pipeline Body Instantiation](#topic-style-%E2%80%A2-topic-pipeline-body-instantiation)
    - [Topic style • Evaluation](#topic-style-%E2%80%A2-evaluation)
    - [Simple reference • Evaluation](#simple-reference-%E2%80%A2-evaluation)
    - [Bare function call • Evaluation](#bare-function-call-%E2%80%A2-evaluation)
    - [Bare constructor call • Evaluation](#bare-constructor-call-%E2%80%A2-evaluation)
    - [Pipeline-level expressions](#pipeline-level-expressions)
  - [Relations to other work](#relations-to-other-work)
    - [Possible future extensions to the topic concept](#possible-future-extensions-to-the-topic-concept)
    - [Alternative solutions explored](#alternative-solutions-explored)
  - [Appendix • Explanation of nomenclature](#appendix-%E2%80%A2-explanation-of-nomenclature)
  - [Appendix • Term rewriting](#appendix-%E2%80%A2-term-rewriting)
    - [Term rewriting topic style](#term-rewriting-topic-style)
      - [Term rewriting with autogenerated variables](#term-rewriting-with-autogenerated-variables)
      - [Term rewriting with single dummy variable](#term-rewriting-with-single-dummy-variable)
    - [Term rewriting • Arbitrary associativity](#term-rewriting-%E2%80%A2%C2%A0arbitrary-associativity)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->
</details></nav>

# Smart pipelines
ECMAScript Stage-(−1) Proposal by J. S. Choi, 2018-02.

This repository contains the formal specification for a proposed “smart pipe
operator” `|>` in JavaScript. It is currently not even in Stage 0 of the [TC39
process][TC39 process] but it may eventually be presented to TC39.

## Background
The concept of a pipe operator appears in numerous other languages, variously
called “pipeline”, “threading”, and “feed” operators. This is because developers
find the concept useful.

<details>
<summary>Table of languages</summary>
<table>
<tr>
<th>

`|`

<td>

[Unix shells, PowerShell][Unix pipe]

<tr>
<th>

`|>`

<td>

[Elixir and Erlang][Elixir pipe], [Elm][Elm pipe], [F# / F-sharp][F# pipe],
[Hack][Hack pipe], [Julia][Julia pipe], [LiveScript][LiveScript pipe], [OCaml][OCaml pipe],

<tr>
<th>

`|>` with `$$`

<td>

[Hack][Hack pipe]

<tr>
<th>

`%>%`

<td>

[R with magrittr][R pipe]

<tr>
<th>

`==>`

<td>

[Perl 6][Perl 6 pipe]

<tr>
<th>

`->` `->>`\
`as->` `as->>`\
`some->` `some->>`\
`cond->` `cond->>`

<td>

[Clojure][Clojure pipe]

<tr>
<th>

[Term concatenation][concatenative programming]

<td>

Factor, Forth, Joy, Onyx, PostScript, RPL

</table>

Pipe operators are also conceptually similar to [WHATWG-stream piping][] and
[Node-stream piping][].

</details>

The binary smart pipe operator proposed here would provide a backwards- and
forwards-compatible style of chaining nested expressions into a readable,
left-to-right manner. Nested transformations become untangled into short steps
in a zero-cost abstraction.

The proposal is a variant of the [first pipe-operator proposal][] championed by
[Daniel “littledan” Ehrenberg of Igalia][]. This variant is listed as
[Proposal 4: Smart Mix on the pipe-proposal wiki][]. The variant resulted from
[previous discussions about pipeline placeholders in the previous pipe-operator
proposal][previous pipeline-placeholder discussions], which culminated in an
[invitation by Ehrenberg to try writing a specification draft][littledan
invitation]. A prototype Babel plugin is also privately brewing.

You can take part in the discussions on the [GitHub issue tracker][]. When you
file an issue, please note in it that you are talking specifically about
“Proposal 4: Smart Mix”.

**This specification uses `#`** as its [“topic token”][nomenclature]. However,
this is not set in stone. In particular, **`?` and `@` could also be used**.
Either would be similarly terse and typeable.
Bikeshedding over what characters to use for the topic token is occurring on
GitHub at [tc39/proposal-pipeline-operator, issue #91][topic-token bikeshedding].

## Motivation
Nested, deeply composed expressions occur often in JavaScript. They occur
whenever any single value must be processed by a series of transformations,
whether they be operations, functions, or constructors. Unfortunately, these
deeply nested expressions often result in messy spaghetti code, due to their
mixing of prefix, infix, and postfix expressions together. Writing such code
requires many nested levels of indentation. Reading the such requires checking
both the left and right of each subexpression to understand its data flow.

```js
new User.Message(
  capitalize(
    doubledSay(
      (await stringPromise)
        ?? throw new TypeError(`Expected string from ${stringPromise}`)
    )
  ) + '!'
)
```

With the smart pipe operator, the code above could be terser and, literally,
straightforward. Prefix, infix, and postfix expressions would be less tangled
together in threads of spaghetti. Instead, data values would be piped from left
to right through a **single flat thread of postfix expressions**, essentially
forming a [Reverse Polish notation][].
```js
stringPromise
  |> await #
  |> # ?? throw new TypeError()
  |> doubleSay(#, ', ')
  |> capitalize // a bare unary function call
  |> # + '!'
  |> new User.Message // a bare unary constructor call
```

Each such postfix expression (called a **pipeline body**) is in its own inner
lexical scope, within which a special token `#` is defined. This `#` is a
reference to the **topic** of the pipeline (`#` itself is called the **topic
reference**). When the pipeline’s head (the expression at its left-hand side) is
evaluated, it then becomes the pipeline’s topic. A new lexical environment it
created, within which `#` is bound to the topic, and within which the pipeline’s
body (the expression at its righthand side) is evaluated using that topic
binding.

The pipeline’s value is whatever the pipeline body evaluated into. For instance,
`5 |> # - 3 |> # * 2` is precisely the same as `((5 - 3)) * 2`. The syntax
statically is [term rewritable into already valid code][term rewriting] with
theoretically zero runtime cost.

The resulting code’s terseness and flatness may be both easier for the
JavaScript developer to read and to edit. The reader may follow the flow of data
more easily through this single flattened thread of postfix operations. And the
developer may more easily add or remove operations at the beginning, end, or
middle of the thread, without changing the indentation of many unrelated lines.

Similar use cases appear numerous times in JavaScript code, whenever any value
is transformed by expressions of any type: function calls, property calls,
method calls, object constructions, arithmetic operations, logical operations,
bitwise operations, `typeof`, `instanceof`, `await`, `yield` and `yield *`, and
`throw` expressions. In particular, the styles of [functional programming][],
[dataflow programming][], and [tacit programming][] may benefit from pipelining.
The smart pipe operator can simply handle them all.

Note also that it was not necessary to include parentheses for `capitalize` or
`new User.Message`; they were implicitly included as a unary function call and a
unary constructor call, respectively.
In othe words, the preceding example is equivalent to:
```js
'hello'
  |> await #
  |> # ?? throw new TypeError(`Expected string from ${#}`)
  |> doubleSay(#, ', ')
  |> capitalize(#)
  |> # + '!'
  |> new User.Message
```

Being able to automatically detect this **“bare style”** is the [**smart** part
of this “smart pipe operator”][smart body syntax].

[TODO: Link to Goals.]\
[TODO: Add Lodash, jQuery, vanilla DOM, and search NPM top packages for more examples.]

<table>
<thead>
<tr>
<th>With smart pipes
<th>Status quo

<tbody>
<tr>
<td>

```js
value
  |> f
  |> # + 2
  |> # * 3
  |> -#
  |> g(#, x)
```
This pipeline is relatively flat, with only one level of indentation, and with
each transformation step on its own line.

Note that `|> f` is a bare unary function call. This is the same as `|> f(#)`,
but the `#` is unnecessary; it is invisibly, tacitly implied.

This is the [smart part of the pipe operator][smart body syntax], which can
distinguish between two syntax styles (bare vs. topic) by using a simple rule:
bare style uses only identifiers, dots, and `new`, and never parentheses,
brackets, braces, or other operators.

<td>

```js
g(
  -(f(value) + 2)
    * 3,
  x
)
```
In contrast to the version with pipes, this code is deeply nested, not flat.

The expression has two levels of indentation instead of one.
Reading its data flow requires checking both the beginning and end of each
expression, and each step expression gradually increases in size.

Inserting or removing any step of the data flow also requires changes to the
indentation of any previous steps’ lines.

<tr>
<td>

```js
function doubleSay (str, separator) {
  return `${str}${separator}${string}`
}

function capitalize (str) {
  return str[0].toUpperCase()
    + str.substring(1)
}

stringPromise
  |> await #
  |> # ?? throw new TypeError()
  |> doubleSay(#, ', ')
  |> capitalize |> # + '!'
  |> new User.Message
```
This pipeline is relatively flat, with only one level of indentation, and with
each transformation step on its own line.

`|> capitalize` is a bare unary function call, equivalent to `|> capitalize(#)`.
Similarly, `|> new User.Message` is a bare unary constructor call, abbreviated
from `|> new User.Message(#)`.

<td>

```js
function doubleSay (str, separator) {
  return `${str}${separator}${str}`
}

function capitalize (str) {
  return str[0].toUpperCase()
    + str.substring(1)
}

new User.Message(
  capitalizedString(
    doubledSay(
      (await stringPromise)
        ?? throw new TypeError()
    )
  ) + '!'
)
```
This deeply nested expression has four levels of indentation instead of two.
Reading its data flow requires checking both the beginning and end of each expression.

<tr>
<td>

```js
stringPromise
  |> await #
  |> # ?? throw new TypeError()
  |> `${#}, ${#}`
  |> #[0].toUpperCase() + #.substring(1)
  |> # + '!'
  |> new User.Message
```
When tiny functions are only used once, and their bodies would be obvious and
self-documenting in meaning, they might be ritual boilerplate that a developer
may prefer to inline, trading off self-documentation for localization of meaning.

<td>″″

<tr>
<td>

```js
value
  |> f(#, #)
```
The topic reference may be used multiple times in a pipeline body. Each use
refers to the same value (wherever the topic reference is not overridden by
another, inner pipeline’s topic scope). Because it is bound to the result of the
topic, the topic is still only ever evaluated once.

<td>

```js
const $ = …;
f($, $)
```
This is equivalent to storing the topic value in a unique variable, then using
that variable multiple times in an expression. But the variable declaration is
unnecessary.

<tr>
<td>

```js
value
  |> [#, # * 2, # * 3]
```

<td>

```js
const $ = value;
[$, $ * 2, $ * 3]
```

<tr>
<td>

```js
value
  |> x => # + x
```
The body of a pipeline may contain an inner arrow function but no other
type of block expression. Both versions of this code return an arrow function.

<td>

```js
const $ = value;
x => $ + x
```
The arrow function lexically closes over the topic value, takes one parameter,
and returns the sum of the topic value and the parameter.

<tr>
<td>

```js
value
  |> settimeout(() => # * 5)
```
This ability to create arrow functions, which do not lexically shadow the topic,
can be useful for using callbacks in a pipeline.

<td>

```js
const $ = value;
settimeout(() => $ * 5)
```
The topic value (here represented by a normal variable `$`) is still lexically
accessible within the arrow function’s body in both examples.

<tr>
<td>

```js
value
  |> (() => # * 5)
  |> settimeout
```
The arrow function can also be created on a separate pipeline step.

<td>

```js
const $ = value;
settimeout(() => $ * 5)
```
The result is the same.

<tr>
<td colspan=2>

```js
value
  |> () => # * 5
  |> settimeout
// 🚫 SyntaxError:
// Unexpected token '=>'.
// Cannot parse base expression.
```
Note, however, that arrow functions have looser precedence than the pipe
operator. This means that if a pipeline creates an arrow function alone in one
of its steps’ bodies, then the arrow-function expression must be parenthesized.
(The same applies to assignment and yield operators, which are also looser than
the pipe operator.) The example above is being parsed as if it were:
```js
(value |> ()) => (# * 5 |> settimeout)
```

<tr>
<td>

```js
value
  |> f(() => f(#) * 5)
```

<td>

```js
const $ = value;
f(x => f($) * 5)
```

<tr>
<td>

```js
value
  |> (x => # + x |> g |> # * 2)
  |> f |> #.toString()
```
Both the head and the body of a pipeline may contain nested inner pipelines.
Nested pipelines in the body is not encouraged, but it is still permitted.

<td>

```js
const $ = value;
f(x => g($ + x) * 2)
  .toString()
```
A nested pipeline works consistently. It merely shadows the topic
reference within its own body.

<tr>
<td>

```js
value
  |> # ** 2
  |> (x => #
      |> g(#, x)
      |> [# * 3, # * 5])
  |> f
```
Again, this code style is not encouraged. It is almost certainly better
to isolate the expression in the callback into its own function.

<td>

```js
const $ = value ** 2;

f(x => {
  const _$ = g($, x);
  return [_$ * 3, _$ * 5]
})
```
But the code still behaves consistently.

<tr>
<td>

```js
value |> function () { return # }
// 🚫 SyntaxError:
// Pipeline body binds but never uses topic.
```
Arrow functions are special in that they do not shadow the topic. Every other
block prevents you from using an outside context’s topic. You cannot use use
topic references inside of other types of blocks: function, async function,
generator, async generator, or class.

<td>

<tr>
<td>

```js
value |> class { m: () { return # }}
// 🚫 SyntaxError:
// Pipeline body binds but never uses topic.
```
More precisely, all block expressions (other than arrow functions) shadow any
outer lexical context’s topic with its own *absence* of a topic. This behavior
is in order to fulfill the [Goals][] of [simple scoping][] and of [“don’t shoot
me in the foot”][]: it makes the origin of a topic easier to find.

(If `do` expressions come in the future, they will be like arrow functions in
that they will not shadow topics either. See [other ECMAScript proposals][].)

<td>

<tr>
<th colspan=2>

[Underscore.js][]

<tr>
<td>

```js
function (obj, pred, context) {
  return obj
    |> isArrayLike(#)
      ? _.findIndex
      : _.findKey
    |> #(obj, pred, context)
    |> (# !== void 0 && # !== -1)
      ? obj[#] : undefined;
}
```

<td>

```js
function (obj, pred, context) {
  var key;
  if (isArrayLike(obj)) {
    key = _.findIndex(obj, pred, context);
  } else {
    key = _.findKey(obj, pred, context);
  }
  if (key !== void 0 && key !== -1)
    return obj[key];
}
```

<tr>
<td>

```js
function (obj, pred, context) {
  return pred
    |> cb
    |> _.negate
    |> _.filter(obj, #, context)
}
```

<td>

```js
function (obj, pred, context) {
  return _.filter(obj,
    _.negate(cb(pred)),
    context
  )
}
```

<tr>
<td>

```js
function (
  srcFn, boundFn, ctxt, callingCtxt, args
) {
  if (!(callingCtxt instanceof boundFn))
    return srcFn.apply(ctxt, args);
  var self = srcFn
    |> #.prototype |> baseCreate;
  return self
    |> srcFn.apply(#, args)
    |> _.isObject(#) ? # : self;
}
```

<td>

```js
function (
  srcFn, boundFn,
  ctxt, callingCtxt, args
) {
  if (!(callingCtxt instanceof boundFn))
    return srcFn.apply(ctxt, args);
  var self = baseCreate(srcFn.prototype);
  var result = srcFn.apply(self, args);
  if (_.isObject(result)) return result;
  return self
}
```

<tr>
<td>

```js
function (obj) {
  if (obj == null) return 0;
  return (obj |> isArrayLike)
    ? (obj |> #.length)
    : (obj |> _.keys |> #.length);
}
```

<td>

```js
function (obj) {
  if (obj == null) return 0;
  return isArrayLike(obj)
    ? obj.length
    : _.keys(obj).length;
}
```

<tr>
<th colspan=2>

[Pify][]

<tr>
<td>

```js
'package.json'
  |> await pify(fs.readFile)(#, 'utf8')
  |> JSON.parse |> #.name
  |> console.log
```

<td>

```js
pify(fs.readFile)('package.json', 'utf8')
  .then(data => {
    console.log(JSON.parse(data).name)
  })
```

<tr>
<th colspan=2>

[Fetch Standard][]

<tr>
<td>

```js
'/music/pk/altes-kamuffel'
  |> await fetch(#)
  |> await #.blob()
  |> playBlob
```

<td>

```js
fetch('/music/pk/altes-kamuffel')
  .then(res => res.blob())
  .then(playBlob)
```

<tr>
<td>

```js
'https://example.com/'
  |> await fetch(#, { method: 'HEAD' })
  |> #.headers.get('content-type')
  |> log
```

<td>

```js
fetch('https://example.com/',
  { method: 'HEAD' }
).then(res =>
  log(res.headers.get('content-type'))
)
```

<tr>
<td>

```js
'https://pk.example/berlin-calling'
  |> await fetch(#, { mode: 'cors' });
response
  |> #.headers.get('content-type')
  |> #??.toLowerCase()
  |> #.indexOf('application/json')
  |> # >= 0
  |> # ? response : throw new TypeError()
  |> await #.json()
  |> processJSON
```

<td>

```js
fetch('https://pk.example/berlin-calling',
  { mode: 'cors' }
).then(response => {
  if (response.headers.get('content-type')
    ??.toLowerCase()
    .indexOf('application/json') >= 0
  ) {
    return response.json()
  } else {
    throw new TypeError()
  }
}).then(processJSON)
```

</table>

## Goals

There are seventeen ordered Goals that the smart body syntax tries to fulfill,
which may be summarized,<br>
“Don’t break my code,”<br>
“Don’t make me overthink,”<br>
“Don’t shoot me in the foot,”<br>
“Make my code easier to read,”<br>
and a few other Goals.

<table>
<tr>
<td>

**“Don’t break my code.”**

 1. [Backward compatibility](#backward-compatibility)
 2. [Zero runtime cost](#zero-runtime-cost)
 3. [Forward compatibility](#forward-compatibility)

<td>

**“Don’t make me overthink.”**

 4. [Syntactic locality](#syntactic-locality)
 5. [Cyclomatic simplicity](#cyclomatic-simplicity)
 6. [Expressive versatility](#expressive-versatility)

<td>

**“Don’t shoot me in the foot.”**

 7. [Simple scoping](#simple-scoping)
 8. [Static analyzability](#static-analyzability)
 9. [Arbitrary associativity](#arbitrary-associativity)

<tr>
<td>

**“Make my code easier to read.”**

10. [Untangled flow](#untangled-flow)
11. [Distinguishability](#distinguishability)
12. [Terse parentheses](#terse-parentheses)
13. [Terse variables](#terse-variables)
14. [Terse function calls](#terse-function-calls)

<td>

**Other**

15. [Conceptual generality](#conceptual-generality)
16. [Human writability](#human-writability)
17. [Novice learnability](#novice-learnability)

</table>

### “Don’t break my code.”
The syntax should not break any existing code; it should also be forward
compatible with future code.

#### Backward compatibility
The syntax must avoid stepping on the toes of existing code, including but not
limited to JavaScript libraries such as jQuery and Underscore.js. In particular,
the topic reference should not be an existing identifier such as `$` or `_`,
which both may cause surprising results to a developer who adopts pipelines
while also using a globally bound convenience variable. It is a common pattern
to do this even without a library: `var $ = document.querySelectorAll`”. The
silent shadowing of such outer-context variables may silently cause bugs, which
may also be difficult to debug (see Goal 6).

Nor can it cause previously valid code to become invalid. This includes, to a
lesser extent, common nonstandard extensions to JavaScript: for instance, using
`<>` for the topic reference would retroactively invalidate existing E4X and JSX
code.

This proposal uses `#` for its topic reference. This is compatible with all
known previous JavaScript code. `?` and `@` could be chosen instead, which are
each also backwards compatible.

#### Zero runtime cost
This could be considered a specific type of backward compatibility. When
translating old code into the new syntax, doing so should not cause unexpected
performance regression. For instance, the new syntax should not require memory
allocation for newly created functions that were not necessary in the old code.
Instead, it should, at least theoretically, perform as well the old code did for
both memory and CPU. And it should be able to do this without dramatically
rearranging code logic or relying on hidden, uncontrollable compiler
optimization.

For instance, in order to apply the syntax to the logic of an async functions, a
hypothetical new pipeline syntax might not support using `await` in the same
async context as the pipeline itself. Such a syntax would, for each of its
pipelines’ steps, require inner async functions that would return wrapper
promises and pass them between consecutive steps. Such an approach would be be
unnecessarily expensive to naively evaluate for both CPU and memory. But
inlining these async functions may be internally complicated, and such
optimizations would be difficult for the developer to correctly predict and
might differ widely between JavaScript engines.

Instead, this proposal’s use of a topic reference enables the zero-cost
rewriting of any expression within the current environmental context, including
`await` operations in async functions, without having to create unnecessary
inner async functions, and without having to wrap values in unnecessary promises.

#### Forward compatibility
The syntax should not preclude other proposals: both already-proposed features,
such as [syntactic partial application][] and [private class fields][] – as well
as [possible future extensions to the topic concept][], such as topic-binding
versions of `function`, `for`, and `catch` blocks.

This proposal is forward compatible with all these proposals, in both its choice
of topic reference and in its prohibition of topic references within any block
(other than arrow functions).

Forward compatibility is elaborated in the section on [relations to other
work][]. See also Goal 9 below. See also [inner blocks in pipelines][inner
blocks].

### “Don’t make me overthink.”
The syntax should not make a developer overthink about the syntax, rather than
their product.

#### Syntactic locality
The syntax should minimize the parsing lookahead that the compiler must check.
If the grammar makes [garden-path syntax][] common, then this increases the
dependency that pieces of code have on other code. This long lookahead in turn
makes it more likely that the code will exhibit developer-unintended behavior.

This is true particularly for [distinguishing between different styles of
pipeline body syntax][smart body syntax]. A pipeline’s meaning would often be
ambiguous between these styles – at least without checking the pipeline’s body
carefully to see in which style it is written. And the pipeline body may be a
very long expression.

By restricting the space of valid bare-style pipeline bodies (that is, without
topic references), the rule minimizes garden-path syntax that would otherwise be
possible – such as `value |> compose(f, g, h, i, j, k, #)`. Syntax becomes more
locally readable. It becomes easier to reason about code without thinking about
code elsewhere.

#### Cyclomatic simplicity
Each edge case of the grammar increases the [cyclomatic complexity][] of parsing
the new syntax, increasing cognitive burden on both machine compiler and human
reader in writing and reading code without error. If edge cases and branching
are minimized, then the resulting syntax will be uniform and consistent. The
reduced complexity would hopefully reduce the probability that the developer
will misunderstand the code they read or write.

Similarly, reducing edge cases reduces the amount of trivia that a developer
must learn and remember in order to use the syntax. The more uniform and
simple the syntax’s rules, the more the developer may focus on the actual
meaning of their code.

#### Expressive versatility
JavaScript is a language rich with [expressions of numerous kinds][MDN
operator predecence], each of which may usefully transform data from one
form to another. There is **no single type** of expression that forms a
**majority of used expressions**.

<table>
<tr>
<td>

 1. `undefined` and `null`.
 2. Boolean literals.
 3. String literals.
 4. Regular-expression literals.

<td>

 5. Template literals.
 6. Array literals.
 7. Object literals.

<tr>
<td>

 8. Variable references.
 9. Property accessors.
10. `this`.
11. `new.target`.

<td>

13. Arithmetic operations.
14. Bitwise operations.
15. Logical operations.

<tr>
<td>

16. Equality operations.
17. `instanceof` and `in` operations.
18. Conditional operations.

<td>

19. Unary function calls.
20. Unary constructor calls.
21. N-ary function calls.
22. N-ary constructor calls.
23. `super` calls.

<tr>
<td>

23. Arrow functions.
24. Function definitions.
25. Generator definitions.

<td>

26. Async-function definitions.
27. Async-generator definitions.
28. Class definitions.

<tr>
<td>

29. `typeof` operations.
30. `void` expressions.
31. `await` expressions.
32. `yield` expressions.

<td>

33. Functional partial application?
34. Unary-function composition?
35. Function binding?

</table>

The goal of the pipe operator is to untangle deeply nested expressions into flat
threads of postfix expressions. To limit it to only one type of expression, even
a common type, truncates its benefits to that one type only and compromises its
expressivity and versatility.

In particular, relying on immediately invoked function expressions ([IIFEs][])
to accomodate non-unary function is insufficient for idiomatic JavaScript code.
JavaScript functions have never fulfilled the [Tennent correspondence
principle][]. Several common types of expressions cannot be equivalently used
within inner functions, particularly `await` and `yield`. In these frequent
cases, attempting to replacing code with “equivalent” IIFEs may cause different
behavior, may cause different performance behavior (see example in Goal 2), or
may require dramatic rearrangement of logic to conserve the old code’s behavior.

It would be possible to add ad-hoc handling, for selected other expression
types, to the operator’s grammar. This would expand its benefits to that type.
However, this conflicts with Goal 5 (adding cyclomatic complexity to the parsing
process, proportional to the number of ad-hoc handled cases). It also does not
fulfill this Goal well either: excluding, perhaps arbitrarily, whatever classes
its grammar’s branches do not handle.

Such new [incidental complexity][] makes code less readable and distracts the
developer from the program’s [essential logic][essential complexity]. A pipeline
operator that improves readability should be versatile (this Goal) but
conceptually and cyclomatically simple (Goal 5). Such an operator should be able
to handle **all** expressions, in a **single** manner **uniformly**
**universally** applicable to **all** expressions. It is the hope of this
proposal’s authors that its [smart body syntax][] fulfills both criteria.

### “Don’t shoot me in the foot.”
The syntax should not be a footgun: it should not easy for a developer to
accidentally shoot themselves in the foot with it.

#### Simple scoping
It should not be easy to accidentally shadow a reference from an outer lexical
scope. When the developer does so, any use of that reference could result in
subtle, pernicious bugs.

The rules for when the topic is bound should be simple and consistent. It should
be clear and obvious when a topic is bound and in what scope it exists. And
forgetting these rules should result in early, compile-time errors, not subtle
runtime bugs.

The rules of topic scoping is simple: **Topic references are bound in the bodies
of pipelines, and they cannot be used within any block other than arrow
functions.** See the section on [inner blocks][].

#### Static analyzability
[Early errors][] help the editing JavaScript developer avoid common [footguns][]
at compile time, such as preventing them from accidentally omitting a topic
reference where they meant to put one. For instance, if `x |> 3` were not an
error, then it would be a useless operation and almost certainly not what the
developer intended. Situations like these should be statically detectable and
cause compile-time [early errors][].

#### Arbitrary associativity
[TODO]

### “Make my code easier to read.”
The new syntax should increase the human readability and writability of much
common code. It should be simpler to read and comprehend. And it should be
easier to compose and update. Otherwise, the new syntax would be useless.

Making JavaScript expressions more ergonomic for humans is the prime, original
purpose of this proposal. To a computer, the form of complex expressions –
whether as deeply nested groups or as flat threads of postfix steps – should not
matter. But to a human, it can make a significant difference.

#### Untangled flow
When a human reads deeply nested groups of expressions – which are very common
in JavaScript code – their attention must switch between the start and end of
each nested expression. And these expressions will dramatically differ in
length, depending on their level in the syntactic tree. To use the example above:
```js
new User.Message(
  capitalize(
    doubledSay(
      (await stringPromise)
        ?? throw new TypeError(`Expected string from ${stringPromise}`)
    )
  ) + '!'
)
```
…the deep inner expression `await stringPromise` is relatively short. In
contrast, the shallow outer expression `` capitalize(doubledSay((await
stringPromise) ?? throw new TypeError(`Expected string from
${stringPromise}`))) + '!'`) `` is very long. Yet both are
quite similar: they are transformations of a string into another. This
insight is lost in the deeply nested noise.

With pipelines, the code forms a flat thread of postfix steps. It is much
easier for a human to read and comprehend. Each of its steps are roughly the
same length. In order to understand what occurs before a given step, one
only need to scan left, rather than in both directions as the deeply nested
tree would require. To read the whole thing, a reader may simply follow
along left to right, not back and forth.
```js
stringPromise
  |> await #
  |> # ?? throw new TypeError()
  |> doubleSay(#, ', ')
  |> capitalize
  |> # + '!'
  |> new User.Message
```

The introduction to this [motivation][] section already explained much of
the readability rationale.

#### Distinguishable punctuators
Another important aspect of code readability is the visual distinguishability of
its most important words or symbols. Visually similar punctuators can distract
or even mislead the human reader, as they attempt to figure out the true meaning
of their code.

Any new punctuator should be easily distinguishable from existing symbols and should
not be visually confusable with unrelated syntax. This is particularly true for
choosing the topic-reference token, which would appear often in a wide variety
of expressions. If the topic reference hypothetically were `?`, and it were used
anywhere near the visually similar [optional-chaining syntax proposal][], then
the topic reference might be lost or unnoticed by the developer: for example,
`?.??m(?)`.

#### Terse parentheses
Terseness also aids distinguishability by obviating the need for boilerplate
syntactic noise. Parentheses are a prominent example: as long as operator
precedence is clear, then reducing parentheses always would JavaScript code more
visually terse and less cluttered.

The example above demonstrates how numerous verbose parentheses could become
unnecessary with pipelines. In these cases the [“data-to-ink” visual ratio][]
would significantly increase, emphasizing the program’s essential information.
The developer’s cognitive burden – of ignoring unimportant incidental symbols as
they read – has hopefully lightened.

#### Terse variables
Similarly, terseness of code may also be increased by removing variables where
possible. This in turn would increase the data-to-ink visual ratio of the text
and the distinguishability of important symbols. This style of programming is
known as [tacit or point-free programming][tacit programming] (where “point”
refers to function arguments). Jeremy Gibbons, a computer scientist, expressed
its claimed benefits in a 1970 paper as such:

> Our calculations got completely bogged down using [function arguments]. In
> attempting to rephrase [function] definitions […] in particular, eliminating
> as many variables as possible and performing point-free (or ‘pointless‘)
> calculations at the level of functino compisition instead of point-wise
> calculations at the level of application, suddenly the calculations became
> almost trivial. This is the point of [point-free] calculations: when you
> travel light – discarding variables that do not contribute to the calculation
> – you can sometimes step lightly across the surface of the quagmire.

This sort of terseness, in which the explicit is made tacit and implicit, must
be balanced with Goals 4 and 5. Excessive implicitness compromises
comprehensibility, at least without low-level tracing of tacit arguments’
invisible paths, rather than the actual, high-level meaning of the code. Yet at
the same time, excessive explicitness generates ritual, verbose boilerplate that
also interferes with reading comprehension. Therefore, Goal 10 must be balanced
with Goals 1, 4, and 5.

[The Zen of Python][PEP 20] famously says, “Explicit is better than implicit,”
but it also says, “Flat is better than nested,” and, “Sparse is better than
dense.”

#### Terse function calls
Unary function / constructor calls are a particularly frequent type of
expression and a good target for especial human optimization. However, such
extra shortening might dramatically reduce the verbosity of unary function
calls, but again this must be balanced with Goals 1, 4, and 5.

It is the hope of this proposal’s authors that its [smart body syntax][] reaches
a good balance between this Goal and Goals 4 and 5, in the same manner that
[Huffman coding][] optimizes textual symbols’ length for their frequency of use:
more commonly used symbols are shorter.

### Other Goals
Although these have been prioritized last, they are still important.

#### Conceptual generality
If a concept is uniformly generalizable to many other cases, then this
multiplies its usefulness. The more versatile its concepts, the more it may be
applied to other syntax, including existing syntax and future syntax (compare
with Goal 3).

This proposal’s concept of a **topic reference does not need to be coupled only
to pipelines**. The [topic concept is **generalizable to many syntactic
forms**][possible future extensions to the topic concept]. These generalizations
are **out of scope** of this proposal, which is only for the smart pipe
operator; they are **deferred** to [other, future proposals][possible future
extensions to the topic concept].

#### Human writability
Writability of code is less important a priority than readability of code. Code
is usually written a few days, perhaps by a few authors – but code will be read
dozens or hundreds of times, perhaps by many more people. However, ease of
writing and editing is still a good goal, and it often naturally increases when
code also becomes more readable. A useful heuristic for writability is assessing
the probability that a single edit to one piece of code will necessitate changes
to other parts of code that are not directly related to the edit.

The simple addition or removal of a deeply nested expression may necessitate the
indentation, de-indentation, parenthetical grouping, and parenthetical
flattening of many lines of code; the tedium of these incidental changes is a
major factor in the general popularity of automatic code formatters.

Achieving Goal 8 therefore also improves the ease of composing and editing code.
By flattening deeply nested expression trees into single threads of postfix
steps, a step may be added oredited in isolation on a single line, it may be
rearranged up or down, it may be removed – all without affecting the pipeline’s
other steps in the lines above or below it.

#### Novice learnability
Learnability of the syntax is a desirable Goal: the more intuitive the syntax
is, the more rapidly it might be adopted by developers. However, learnability in
of itself is not more desirable than the other Goals above. Most JavaScript
developers would be novices to this syntax at most once, during which the
intuitiveness of the syntax will dominate their experience. But after that
honeymoon period, the syntax’s usability in workaday programming will instead
affect their reading and writing most.

So instead, readability, comprehensibility, locality, simplicity,
expressiveness, and terseness are prioritized first, where they would conflict
with learnability itself. However, a syntax that is simple but expressive – and,
most of all, readable – could well be easier to learn. Its up-front cost in
learning could be small, particularly in comparison to the large gains in
readability and comprehensibility that it might bring to code in general.

## Nomenclature
Because this proposal introduces several new concepts, it is important
to use a consistent set of terminology.

### Pipe operator, pipeline, pipeline-level expression
The binary operator itself `|>` may be referred to as a **pipe**, a **pipe
operator**, or a **pipeline operator**; all these names are equivalent. This
specification will prefer the term “pipe operator”.

A pipe operator between two expressions forms a **pipe expression**. One or more
pipe expressions in a chain form a **pipeline**, and each pipe expression is
a **step** of the pipeline.

A **pipeline-level expression** is an expression at the same [precedence level
of the pipe operator][operator precedence]. Although all pipelines are
pipeline-level expressions, most pipeline-level expressions are not actually
pipelines. Conditional operations, logical-or operations, or any other
expressions that have tighter [operator precedence][] than the pipe operation –
those are also pipeline-level expressions.

### Head, head value, body, pipeline value, topic style, bare style
For each pipe expression, the expression before the pipe is the pipeline’s
**head**. A pipeline’s head may also be called its **left-hand side (LHS)**,
because it’s left to the pipe. (The head could also be referred to as the pipe’s
**[antecedent][]** , its **topic expression**, or its **[binder][binding]**.)
The *value* to which the head evaluates may be referred to as the **topic
value**, **head value**, or **LHS value**.

The expression after a pipe is the pipeline’s **body**. A pipeline’s body may
also be called its **right-hand side (RHS)**, because it’s to the right of the
pipe. When the body is evaluated according to its [runtime semantics][], that
value may be referred to the **pipeline’s value**.

Where “pipeline” is used as a verb, the pipe operator is said **to pipeline its
topic through its body**, resulting in the pipeline’s value.

A pipeline’s body may be in one of two **styles**:\
topic style and\
bare style.

**Topic style** is the default style. A pipeline body in topic style forms
an inner lexical scope – called the pipeline’s **topic scope** – within which
a special token is bound to the value of the head; the section below explains.

Alternatively, you may omit the topic references entirely, if the body is just a
**simple reference** to a function or constructor, such as with `… |>
capitalize` and `… |> new User.Message`. Such a pipeline body is in **[bare
style][]**; bare style is described in more detail below.

### Topic, topic reference
The **topic** (or **topic value**) of a lexical context is a value that the
lexical context is “about”. Not all lexical contexts has a topic. But in each
lexical context that does, its topic is bound to `#`, a special token called the
**topic reference**, aka the **topic bindee**, **topic placeholder** or **topic
anaphor**. `#` is a nullary operator that acts like a special variable:
implicitly bound to the topic value, but still lexically scoped.

The topic reference could also be called a “**topic variable**” or “**topic
identifier**”, [as they are called in other programming languages][topic
variables in other languages]. But in JavaScript, these phrases would be
misnomers. The topic reference is *not* actually a variable identifier and
cannot be manually declared (`const #` is a syntax error), nor can it be
assigned with a value (`# = 3` is a syntax error). Instead, the topic reference
is implicitly, lexically bound only within pipeline bodies.

### Topic-opaque and topic-clear environments
[TODO]

## Grammar
This grammar of the pipeline operator juxtaposes brief rules written for the
JavaScript developer with formally written changes to the ECMAScript standard.
The grammar itself is a [context-free grammar supplemented with static
semantics][syntax and static semantics]. The ECMAScript specification explains:

> A context-free grammar consists of a number of **productions**. Each
> production has an abstract symbol called a **nonterminal** as its left-hand
> side, and a sequence of zero or more nonterminal and **terminal** symbols as
> its right-hand side. For each grammar, the terminal symbols are drawn from a
> specified alphabet.

This proposal uses the [grammatical notation as that from the ECMAScript
standard][ECMAScript Notational Conventions, § Grammars] to denote its lexical
and syntactic grammars, with three modifications for human readability:

* “camelCase” is spaced out as “camel Case” for all variables, production
  names, and rule names.

* Adjacent variables, production names, and rule names are separated by the
  middle dot “·”. This prevents two adjacent identifiers from being confused as
  the same identifier separated by spaces. (Middle dot is omitted between code
  literals, which are obviously separate through their formatting.)

* References to rules are written in a method style: “… . _Rule Name_ (…)”,
  rather than “_Rule Name_ of … with arguments …” or “… Contains …”.

### Lexical grammar
The smart pipe operator adds two new tokens to JavaScript: `|>` the binary pipe,
and `#` the topic reference. [TODO: Link to spec lexical grammar.]

The lexical rule for punctuator tokens would be modified so that these two
tokens are added.

The _Punctuators_ production is defined in [ECMAScript Punctuators][]. This
production would be changed from this:

* **_Punctuator_** :: one of\
  `{` `(` `)` `[` `]` `.` `...` `;` `,`\
  `<` `>` `<=` `>=` `==` `!=` `===` `!==`\
  `+` `-` `*` `%` `**` `++` `--`\
  `<<` `>>` `>>>` `&` `|` `^` `!` `~` `&&` `||` `?` `:`\
  `=` `+=` `-=` `*=` `%=` `**=`\
  `<<=` `>>=` `>>>=` `&=` `|=` `^=` `=>`

…to this:

* **_Punctuator_** :: one of\
  `{` `(` `)` `[` `]` **`#`** `.` `...` `;` `,`\
  `<` `>` `<=` `>=` `==` `!=` `===` `!==`\
  `+` `-` `*` `%` `**` `++` `--`\
  `<<` `>>` `>>>` `&` `|` `^` `!` `~` `&&` `||` `?` `:` **`|>`**\
  `=` `+=` `-=` `*=` `%=` `**=`\
  `<<=` `>>=` `>>>=` `&=` `|=` `^=` `=>`

### Grammar parameters
In the ECMAScript standard, the rules that produce expressions are often
parameterized with three flags, which are then recursively passed into their
constituent rules. These parameters thus must also be used by the new rules in
this proposal.

* **_In_**: Whether the current context allows the [`in` relational operator][],
  which is false only in the headers of [`for` iteration statements][].
* **_Yield_**: Whether the current context allows a `yield`
  expression/statement (that is, is the current function context a generator?).
* **_Await_**: Whether the current context allows an `await`
  expression/statement (that is, is the current function context an async
  function/generator?).

### Syntactic grammar
The syntactic grammar of JavaScript can transform token sequences (defined by
the [lexical grammar][]) into **parse trees**: rooted tree data structures made
of **Parse Nodes**. This is described further in [ECMAScript § The Syntactic Grammar][].

### Operator precedence
As a binary operation forming compound expressions, the [operator precedence and
associativity][MDN operator precedence] of pipelining must be determined, relative
to other operations.

Precedence is tighter than arrow functions (`=>`), assignment (`=`, `+=`, …),
generator `yield` and `yield *`, and sequence `,`; and it is looser than every
other type of expression. If the pipe operation were any tighter than this
level, its body would have to be parenthesized for many frequent types of
expressions. However, the result of a pipeline is also expected to often serve
as the body of an arrow function or a variable assignment, so it is tighter than
both types of expressions.

The pipe operator actually has [arbitrary associativity][]. However, for the
purposes of this grammar, it will have left associativity.

<details open>
<summary>A table shows how the topic reference and the pipe operator are
integrated into the hierarchy of operators.</summary>

All expression levels in JavaScript are listed here, from **tightest to
loosest**. Each level includes all the expression types listed for that
level – **as well as** any expression types from any precedence level that is
listed **above** it.

| Level          | Type                    | Form           | Associativity / fixity   |
| -------------- | ----------------------- | -------------- | ------------------------ |
| Primary        | This                    |`this`          | Nullary                  |
| ″″             | **Topic**               |**`#`**         | ″″                       |
| ″″             | Identifiers             |`a` …           | ″″                       |
| ″″             | Null                    |`null`          | ″″                       |
| ″″             | Booleans                |`true` `false`  | ″″                       |
| ″″             | Numerics                |`0` …           | ″″                       |
| ″″             | Arrays                  |`[…]`           | Circumfix                |
| ″″             | Object                  |`{…}`           | ″″                       |
| ″″             | Function                |                | ″″                       |
| ″″             | Classes                 |`class … {…}`   | ″″                       |
| ″″             | Generators              |                | ″″                       |
| ″″             | Async functions         |                | ″″                       |
| ″″             | Regular expression      |`/…/…`          | ″″                       |
| ″″             | Templates               |```…```         | ″″                       |
| ″″             | Parentheses             |`(…)`           | ″″                       |
| LHS            | Dynamic properties      |`…[…]`          | LTR infix with circumfix |
| ″″             | Static properties       |`….…`           | ″″                       |
| ″″             | Tagged templates        |`` …`…` ``      | ″″                       |
| ″″             | Super properties        |`super.…`       | ″″                       |
| ″″             | Meta properties         |`meta.…`        | Unchainable prefix       |
| ″″             | Super call op.s         |`super(…)`      | ″″                       |
| ″″             | New                     |`new …`         | RTL prefix               |
| ″″             | Normal calls            |`…(…)`          | LTR infix with circumfix |
| Postfix unary  | Postfix increments      |`…++`           | Postfix                  |
| ″″             | Postfix decrements      |`…--`           | ″″                       |
| Prefix unary   | Prefix increments       |`++…`           | RTL prefix               |
| Prefix unary   | Prefix decrements       |`--…`           | ″″                       |
| ″″             | Deletes                 |`delete …`      | ″″                       |
| ″″             | Voids                   |`void …`        | ″″                       |
| ″″             | Unary `+`/`-`           |`+…`            | ″″                       |
| ″″             | Bitwise NOT `~…`        |`~…`            | ″″                       |
| ″″             | Logical NOT `!…`        |`!…`            | ″″                       |
| ″″             | Await                   |`await …`       | ″″                       |
| Exponentiation | Exponentiation          |`… ** …`        | RTL infix                |
| Multiplicative | Multiplication          |`… * …`         | LTR infix                |
| ″″             | Division                |`… / …`         | ″″                       |
| ″″             | Modulus                 |`… % …`         | ″″                       |
| Additive       | Addition                |`… + …`         | ″″                       |
| ″″             | Subtraction             |`… - …`         | ″″                       |
| Bitwise shift  | Left shift              |`… << …`        | ″″                       |
| ″″             | Right shift             |`… >> …`        | ″″                       |
| ″″             | Signed right shift      |`… >> …`        | ″″                       |
| Relational     | Greater than            |`… < …`         | ″″                       |
| ″″             | Less than               |`… > …`         | ″″                       |
| ″″             | Greater than / equal to |`… >= …`        | ″″                       |
| ″″             | Less than / equal to    |`… <= …`        | ″″                       |
| ″″             | Containment             |`… in …`        | ″″                       |
| ″″             | Instance of             |`… instanceof …`| ″″                       |
| Equality       | Abstract equality       |`… == …`        | ″″                       |
| ″″             | Abstract inequality     |`… != …`        | ″″                       |
| ″″             | Strict equality         |`… === …`       | ″″                       |
| ″″             | Strict inequality       |`… !== …`       | ″″                       |
| Bitwise AND    |                         |`… & …`         | ″″                       |
| Bitwise XOR    |                         |`… ^ …`         | ″″                       |
| Bitwise OR     |                         |`… \| …`        | ″″                       |
| Logical AND    |                         |`… ^^ …`        | ″″                       |
| Logical OR     |                         |`… \|\| …`      | ″″                       |
| Conditional    |                         |`… ? … : …`     | RTL ternary infix        |
| **Pipeline**   |                         |**`… \|> …`**   | LTR infix                |
| Assignment     | Arrow functions         |`… => …`        | RTL infix                |
| ″″             | Async arrow functions   |`async … => …`  | RTL infix                |
| ″″             | Reference assignments   |`… = …`         | ″″                       |
| ″″             |                         |`… += …`        | ″″                       |
| ″″             |                         |`… -= …`        | ″″                       |
| ″″             |                         |`… *= …`        | ″″                       |
| ″″             |                         |`… %= …`        | ″″                       |
| ″″             |                         |`… **= …`       | ″″                       |
| ″″             |                         |`… <<= …`       | ″″                       |
| ″″             |                         |`… >>= …`       | ″″                       |
| ″″             |                         |`… >>>= …`      | ″″                       |
| ″″             |                         |`… &= …`        | ″″                       |
| ″″             |                         |`… \|= …`       | ″″                       |
| Yield level    |                         |`yield …`       | RTL prefix               |
| ″″             |                         |`yield * …`     | ″″                       |
| Ultimate level | Comma                   |`…, …`          | LTR infix                |

</details>

### Topic reference • Grammar
The topic reference integrates into the ECMAScript syntax as one of the
[ECMAScript Primary Expressions][], just like `this`. Their production rule
needs to be modified so that the `#` appears as one of the types of primary
expressions.

An assignment-level expression currently may be a this reference, identifier
reference, null / undefined / true / false literal, array / object /
regular-expression / template literal, function / async-function / generator /
class expression. These possibilities are given the same parameters that the
assignment-level expression happens to have also gotten, except where they would
be unnecessary, such as for the this token.

The old version:

* **_Primary Expression_** [_Yield_, _Await_]:
  * `this`
  * _Identifier Reference_ [? _Yield_, ? _Await_]
  * _Literal_
  * _Array Literal_ [? _Yield_, ? _Await_]
  * _Object Literal_ [? _Yield_, ? _Await_]
  * _Function Expression_
  * _Class Expression_ [? _Yield_, ? _Await_]
  * _Generator Expression_
  * _Async Function Expression_
  * _Regular Expression Literal_
  * _Template Literal_ [? _Yield_, ? _Await_, ~ _Tagged_]
  * _Cover Parenthesized Expression and Arrow Parameter List_ [? _Yield_, ? _Await_]

Added to this list would be the topic token.

The new version:

* **_Primary Expression_** [_Yield_, _Await_]:
  * `this`
  * **`#`**
  * _Identifier Reference_ [? _Yield_, ? _Await_]
  * …

### Pipeline-level expressions • Grammar
The production rule for [ECMAScript Assignment-level Expressions][] needs to be
modified so that pipe expressions slip in between it and conditional-level
expressions in the hierarchy. Then the conditional-expression rule would be used
in the production for pipeline-level expressions (also defined soon), preserving
the unbroken recursive hierarchy of expression types.

An assignment-level expression currently may be a conditional expression, yield
expression, arrow function, async arrow function, or assignment. These
possibilities are given the same parameters with which the assignment-level
expression happens to have been also called.

The old version:

* **_Assignment Expression_** [_In_, _Yield_, _Await_] :
  * _Conditional Expression_ [? _In_, ? _Yield_, ? _Await_]
  *  [+ _Yield_] _Yield Expression_ [? _In_, ? _Await_]
  * _Arrow Function_ [? _In_, ? _Yield_, ? _Await_]
  * _Async Arrow Function_ [? _In_, ? _Yield_, ? _Await_]
  * _Left Hand Side Expression_ [? _Yield_, ? _Await_]\
    `=` _Assignment Expression_ [? _In_, ? _Yield_, ? _Await_]
  * _Left Hand Side Expression_ [? _Yield_, ? _Await_]\
    · _Assignment Operator_ · _Assignment Expression_ [? _In_, ? _Yield_, ? _Await_]

In this proposal, the conditional-expression production rule would be replaced
with one for pipeline-level expressions, which will be defined next.

The new version:

* **_Assignment Expression_** [_In_, _Yield_, _Await_] :
  * _Pipeline Expression_ [? _In_, ? _Yield_, ? _Await_]
  * [+ _Yield_] _Yield Expression_ [? _In_, ? _Await_]
  * _Arrow Function_ [? _In_, ? _Yield_, ? _Await_]
  * …

An expression is a pipeline-level expression (given the usual three [grammar
parameters][]) only if:

* It is either also a conditional-level expression, with the same parameters
  used by the pipeline-level expression;
* Or it is another pipeline-level expression, followed by a `|>` token, then a
  pipeline body (defined next), with the same parameters as above.

This would be defined in a new production rule.

* **_Pipeline Expression_** [_In_, _Yield_, _Await_] :
  * _Conditional Expression_ [? _In_, ? _Yield_, ? _Await_]
  * _Pipeline Expression_ [? _In_, ? _Yield_, ? _Await_] `|>`\
    _Pipeline Body_ [? _In_, ? _Yield_, ? _Await_]

### Smart body syntax
Most pipelines will use the topic reference `#` in their bodies. As already
explained above in [nomenclature][], this style of pipeline is called **topic
style**.

But for two certain simple cases – unary functions and constructors – you may
omit the topic reference from the body. This is called **bare style**.

When a pipe is in bare style, we refer to the body as a **bare function** or a
**bare constructor**, depending on the rules in [bare style • syntactic
grammar][]. The body acts as just a simple reference to a function or
constructor, such as with `… |> capitalize` and `… |> new User.Message`. The
body’s value would then be called as a unary function or constructor, without
having to use the topic reference as an explicit argument.

The two bare-style productions require no parameters, because they can only
be made up of identifiers, `.`, and `new`.

* **_Pipeline Body_** [_In_, _Yield_, _Await_] :
  * _Pipeline Bare Function Call_
  * _Pipeline Bare Constructor Call_
  * _Pipeline Topic Body_ [? _In_, ? _Yield_, ? _Await_]

| Valid topic style       | Valid bare style                  | Invalid bare style
| ----------------------- | --------------------------------- | --------------------
|`… \|> o(#)`             |`… \|> o`                          |  `… \|> o()` 🚫
| ″″                      | ″″                                | `… \|> (o)` 🚫
| ″″                      | ″″                                | `… \|> (o())` 🚫
|`… \|> new o(#)`         |`… \|> new o`                      | `… \|> new o()` 🚫
| ″″                      | ″″                                | `… \|> (new o)` 🚫
| ″″                      | ″″                                | `… \|> (new o())` 🚫
| ″″                      | ″″                                | `… \|> new (o)` 🚫
| ″″                      | ″″                                | `… \|> new (o())` 🚫
|`… \|> o.m(#)`           |`… \|> o.m`                        | `… \|> o.m()` 🚫
| ″″                      |`const m = o::m; … \|> m`          | `… \|> o.m()` 🚫
|`… \|> new o.m(#)`       |`… \|> new o.m`                    | `… \|> o.m()` 🚫
| ″″                      |`const m = o::m; … \|> m`          | `… \|> o.m()` 🚫
|`… \|> o.m(arg, #)`      |`const m = o::m(arg); … \|> m`     | `… \|> o.m(arg)` 🚫
|`… \|> new o.m(arg, #)`  |`const m = new o::m(arg); … \|> m` | `… \|> new o.m(arg)` 🚫
|`… \|> o[symbol](#)`     |`const m = o[symbol]; … \|> m`     | `… \|> o[symbol]` 🚫
|`… \|> new o[symbol](#)` |`const m = new o[symbol]; … \|> m` | `… \|> new o[symbol]` 🚫
|`… \|> o.makeFn()(#)`    |`const m = o.makeFn(); … \|> m`    | `… \|> o.makeFn()` 🚫
|`… \|> new o.makeFn()(#)`|`const m = new o.makeFn(); … \|> m`| `… \|> new o.makeFn()` 🚫

#### Bare style • Grammar
The **bare style** supports using simple identifiers, possibly with chains of
simple property identifiers. If there are any operators, parentheses (including
for method calls), brackets, or anything other than identifiers and dot
punctuators, then it is in topic style, not in bare style.

##### Bare function call • Grammar
If the body is a merely a simple reference, then that identifier is interpreted
to be a **bare function call**. The pipeline’s value will be the result of
calling the body with the current topic as its argument.

That is: **if a pipeline** is of the form **_topic_ `|>` _identifier_**\
or _topic_ `|>` _identifier0_`.`_identifier1_\
or _topic_ `|>` _identifier0_`.`_identifier1_`.`_identifier2_\
or …,\
then the pipeline is a **bare function call**.

* **_Pipeline Bare Function Call_** :
  * _Simple Reference_

##### Bare constructor call • Grammar
If the body starts with `new`, followed by mere identifier, optionally with a
chain of properties, and with no parentheses or brackets, then that identifier
is interpreted to be a **bare constructor**.

That is: **if a pipeline** is of the form **_topic_ `|>` new _identifier_**\
or _topic_ `|> new` _identifier0_`.`_identifier1_\
or _topic_ `|> new` _identifier0_`.`_identifier1_`.`_identifier2_\
or …,\
then the pipeline is a **bare constructor call**.

* **_Pipeline Bare Constructor Call_** :
  * `new` _Simple Reference_

##### Simple reference • Grammar
A **simple reference** is an identifier reference, optionally with a chain of
properties, and with no parentheses, brackets, braces, or operators.

**If an expression** is of the form **_identifier_**\
or _topic_ `|>` _identifier0_`.`_identifier1_\
or _topic_ `|>` _identifier0_`.`_identifier1_`.`_identifier2_\
or …), then the pipeline is a **simple reference**.

This is achieved by defining the _Simple Reference_ production using [ECMAScript
_Identifier Reference_][], [ECMAScript _Identifier Name_][], and left recursion,
in imitation of how [ECMAScript _Member Expression_][] handles method chains.

* **_Simple Reference_** :
  * _Identifier Reference_
  * _Simple Reference_ `.` _Identifier Name_

##### Practical consequences
Therefore, a pipeline in **bare style *never*** has **parentheses `(…)` or
brackets `[…]`** in its body. Neither `… |> object.method()` nor `… |>
object.method(arg)` nor `… |> object[symbol]` nor `… |> object.createFunction()`
are in bare style (in fact, they all have invalid syntax, due to their being in
topic style without any topic references).

**When a body needs parentheses or brackets**, then **don’t use bare style**,
and instead **use a topic reference** in the body……or **assign the body to a
variable**, then **use that variable as a bare body**.

The JavaScript developer is encouraged to use topic references and avoid bare
style, where bare style may be visually confusing to the reader.

#### Topic style • Grammar
**If a pipeline** of the form _topic_ |> _body_ does ***not* match the [bare
style • grammar][]** (that is, it is *not* a bare function call or bare
constructor call), then it **must be in topic style**.

A topic pipeline body is an expression at the [precedence level once tighter
than pipeline-level expressions][operator precedence] – that is, it is a
conditional-level expression.

* **_Pipeline Topic Body_** [_In_, _Yield_, _Await_] :
  * _Conditional Expression_ [? _In_, ? _Yield_, ? _Await_]

## Static semantics
The syntactic grammar of JavaScript further relies upon several functions that
analyze its syntactic structures. These functions are polymorphic on the types
of their input syntactic structures, and their definitions are often also
recursive. The ECMAScript specification goes into more detail on these **static
semantic rules** in [ECMAScript Static Semantic Rules][].

> Context-free grammars are not sufficiently powerful to express all the rules
> that define whether a stream of input elements form a valid ECMAScript Script
> or Module that may be evaluated. In some situations additional rules are
> needed that may be expressed using either ECMAScript algorithm conventions or
> prose requirements. Such rules are always associated with a production of a
> grammar and are called the static semantics of the production.
>
> Static semantic rules have names and typically are defined using an algorithm.
> Named static semantic rules are associated with grammar productions and a
> production that has multiple alternative definitions will typically have for
> each alternative a distinct algorithm for each applicable named static
> semantic rule.

This specification defines additions for the following static semantic rules:

| Form                              | Notes                                             |
| --------------------------------- | ------------------------------------------------- |
| [Contains][]                      | Already defined in ES for nearly all nodes        |
| Is Function Definition            | Already defined in ES: all expressions            |
| Is Identifier Reference           | Already defined: primary- & LHS-level expressions |
| Is Valid Simple Assignment Target | Already defined: primary- & LHS-level expressions |
| [Early Errors][]                  | Already defined in ES for nearly all nodes        |

It should be noted that, in the ECMAScript standard, the Contains rule is
currently written as an infix operator: “… Contains …” for historical reasons.
This is unlike any other static semantic rule, which would be written as prefix
operators “_Rule Name_ of … with arguments …”. There are plans to change all
static semantic rules to instead have a consistent infix syntax resembling
method calls: “…._Rule Name_(…)”. For self-consistency, this proposal will use
that planned method-like syntax.

### Static Contains
The ECMAScript standard implicitly defines the Contains rule for all parse nodes
except where explicitly overridden. Conceptually, a node Contains another node
if the latter is somewhere in the former.

[This quotation from the ECMAScript standard][ECMAScript static semantic rules] is
modified to use the new method-like syntax.

> Unless otherwise specified every grammar production alternative in this
> specification implicitly has a definition for a static semantic rule named
> **Contains** which takes an argument named _symbol_ whose value is a terminal
> or nonterminal of the grammar that includes the associated production. The
> default definition of Contains is:
>
> 1. For each child node _child_ of this Parse Node, do
>    1. If _child_ is an instance of _symbol_, return true.
>    2. If _child_ is an instance of a nonterminal, then
>       1. Let _contained_ be the result of _child_ . Contains (_symbol_).
>       2. If _contained_ is true, return true.
>
> 2. Return false.
>
> The above definition is explicitly overridden for specific productions.

In the ECMAScript standard, the Contains rule is used by many other Static
Semantic Rules, such as [object initializers’ Computed Property Contains
rule][]. The rule is also generally overridden by methods definitions and other
function definitions, such that they hide their substructure from the rule.

(Uniquely among the static semantic rules, Contains is written as an infix
operator in the ECMAScript specification – “… Contains …” – for historical
reasons. This proposal will instead use the planned future new syntax
“… . Contains (…)”.)

**This proposal will use Contains to determine whether an expression uses its
lexical environment’s topic.** This will be important to [statically
ensure][static analyzability] that [topical pipelines always use their topic
references][TODO].

Contains does **not** penetrate the bodies of function and method definitions
for any symbol, hiding them from the rules in outside contexts. All definitions
for functions, generators, methods, and so forth override Contains to always
return false, with this note:

> Static semantic rules that depend upon substructure generally do not look into
> function definitions.

There is **one exception**: arrow functions expose the use of `new.target`, `this`,
and `super`, because, unlike other functions, they do no rebind those three
forms; they use the outer context to evaluate them. (See [ECMAScript arrow
functions, § SS: Contains][]).

Likewise, Contains does **not** penetrate into syntax structures establishing
**[topic-opaque lexical scopes][TODO]**. Topic-opaque lexical scopes are those
that shadow the outer context’s topic, either by [rebinding the topic to a new
value][TODO] (as topical pipeline bodies do) or by [voiding (that is, hiding)
the outer topic][TODO] (like as [almost all blocks do][TODO]).

The logic of this is that, because topic-opaque lexical scopes establish their
own topic binding, structures that create topic-opaque scopes would never use
the topic references of their outer context.

Therefore, this proposal leaves alone the definition of Contains for function
and method blocks. But it further extends the **arrow-function exceptions**, so
that arrow functions also reveal any use of `#` within their bodies. This is
because arrow functions, alone among functions, also do not rebind or clear the
outer context’s topic. (`#` cannot be used within arrow-function parameter lists
or any function’s parameter list.) See [TODO: Topics and inner functions].

[ECMAScript arrow functions, § SS: Contains][] is amended thus:

* **Contains**\
  With parameter _symbol_.

  * **_Arrow Function_** : _Arrow Parameters_ `=>` _Concise Body_

    1. If _symbol_ is not one of _New Target_, _Super Property_, _Super Call_,
      `super`, `this` or `#`, return false.
    2. If _Arrow Parameters_ . Contains (_symbol_) is true, return true.
    3. Return _Concise Body_ . Contains (_symbol_).

***

In addition, Contains for _Pipeline Body_ is also overridden. This is important:
**Topical pipeline bodies’ hide any of their use of `#` from the outside**. The
`#` that pipeline bodies contain is rebound to the pipeline bodies’ lexical
scopes, and it is not the same `#` as any `#` that might be within scope from
the outside.

* **Contains**\
  With parameter _symbol_.

  * **_Pipeline Body_** : _Pipeline Topic Body_

    1. If _symbol_ is `#`, return false.
    2. For each child node _child_ of this Parse Node, do
       1. If _child_ is an instance of _symbol_, return true.
       2. If _child_ is an instance of a nonterminal, then
          1. Let _contained_ be the result of _child_ . Contains (_symbol_).
          2. If _contained_ is true, return true.

<table>
<thead>
<tr>
<td>

<th>

Does use outer topic

<th>

Does **not** use outer topic

<tbody>
<tr>
<th>

_node_ . Contains (`#`)

<td>

True

<td>

False

<tr>
<th>Examples

<td>

```js
#
```
```js
# + 2
```
```js
() => # + 2
```
```js
# |> a + 2
```
```js
# |> # + 2
```

<td>

```js
a
```
```js
{ # + 2 }
```
```js
if (true) { # }
```
```js
function () { # + 2 }
```
```js
a |> # + 2
```

</table>

***

All other new productions that are introduced in this proposal use the unchanged
implicit Contains algorithm defined above for productions in general.

### Static Early Errors
Certain syntax errors cannot be detected by the context-free grammar alone yet
must still be detected at compile time. Early Error Rules are Static Semantic
Rules that define when such extra syntax errors occur. [TODO: Spec link.]

The two static early errors in this proposal are designed to prevent ambiguity
of the developer’s intention from shooting the developer in the foot. They force
the developer to clarify their intent. Together they fulfill the goals of [don’t
shoot me in the foot][] and [static analyzability][].

#### Topical pipelines must use the topic
Pipelines that are in topic style but that do not ever use their topics anywhere
in their bodies, such as `x |> 3`, are an early error. Such expressions would be
always useless and almost certainly not what the author had intended.

* **Early Errors**
  * **_Pipeline Topic Body_** : _Conditional Expression_
    * It is a Syntax Error if _Conditional Expression_ does not contain `#`.

[TODO: Link to here in static analyzability.]

#### Topical pipelines that are yield expressions must be parenthesized
Just as with pipeline heads, pipeline bodies that start with `yield` must be
parenthesized. Otherwise they are early errors.

The `yield` operator is the only unary operator with a looser precedence than
`|>`. Its precedence is so loose that `x |> yield # |> f` is a footgun. It is
very likely that the developer meant `(x |> (yield #)) |> f` here, but because
`yield` has such loose precedence, without parentheses, the pipeline will be
parsed instead as `x |> (yield (# |> f))`, which has a very different meaning.

With this early error, the developer is forced to clarify their pipeline as
either `x |> (yield #) |> f` or `x |> (yield # |> f)`.

* **Early Errors**
  * **_Pipeline Topic Body_** : _Conditional Expression_
    * It is a Syntax Error if _Conditional Expression_ is covering a _Yield Expression_.

The concept of **covering** refers to when an expression’s parse node would also
completely fulfill another production. “Is covering” is formally defined in
[ECMAScript § The Syntactic Grammar][].\
_Yield Expression_ is formally defined in [ECMAScript Functions and Classes
§ Generator Function Definitions][].

#### Only pipeline bodies may contain topic references
[TODO: Write error algorithm.]

### Other static semantic rules

All new productions defined in this proposal are neither function definitions
nor identifier references. This is the same as almost every other expression. In
particular, the `#` topic reference is not an identifier reference; it is a
topic reference, its own thing.

* **Is Identifier Ref**
  * **_Primary Expression_** : `#`\
    Return false.

  * **_Pipeline Expression_** : _Pipeline Expression_ `|>` _Pipeline Body_\
    Return false.

* **Is Valid Simple Assignment Target**
  * **_Primary Expression_** : `#`\
    Return false.

  * **_Pipeline Expression_** : _Pipeline Expression_ `|>` _Pipeline Body_\
    Return false.

  * **_Simple Reference_** : _Simple Reference_ `.` _Identifier Name_ \
    Return false.

  * **_Pipeline Bare Constructor Call_** : `new` _Simple Reference_\
    Return false.

  * **_Pipeline Body_** : _Pipeline Topic Body_\
    Return false.

## Runtime semantics
[ECMAScript Notational Conventions, § Algorithm Conventions][] and [ECMAScript
Notational Conventions, § Runtime Semantics][] explain the notation used here
for runtime algorithms, which always return “[completion records][]”.

This section defines the algorithms for the syntax-directed operation
**Evaluation** from the ECMAScript specification. It also defines an abstract
operation that may be reused by other proposals: **Resolve Topic**.

### Environment Records

[ECMAScript Lexical Environments][] defines an abstract data structure called a
“**Lexical Environment**” that associates Identifiers with variables or
functions for the context within a lexical scope. A Lexical Environment is
actually a **linked list** of Lexical Environments. A single piece of the chain
of Lexical Environments is called an **Environment Record**. Syntactic
structures such as functions and blocks each have their own Lexical
Environments, created whenever such code is evaluated at runtime.

The only environments that **bind** their topic are those created by **topic
pipeline bodies**. Almost every other Lexical Environment **voids** outer topic
bindings from their scope. Voiding does not affect the visibility of outer
bindings in any environments other than the topic-voiding environment and those
that inside it.

The only Lexical Environments that neither establish nor hide topic bindings are
those created by **arrow functions** and by **`try` statements**. For these
environments, called **topic-clear environments**, their Records’ topic binding
status is “clear”. The word “clear” refers to how these Lexical Environments are
**transparent to** their outer environment’s topic binding.

Whether a Lexical Environment binds or voids their topic can be queried by a new
abstract method for all Environment Records: Get Topic Binding Status. Any
Environment whose Record has a topic binding status that is **bound or void**
and **not clear** is called a **topic-opaque environment**: no expression within
its scope can use the outside’s topic.

| Method                        | Description
| ----------------------------- | --------------------------------------------
| Get Topic Binding Status ()   | Returns “bound”, “void”, or “clear”.

The **topic environment of** another environment is the latter’s **nearest
ancestral topic-opaque environment**: that is, the environment that either
supplies the latter environment’s topic binding or voids its topic binding. This
concept is formally defined below in the [abstract operation Get Topic
Environment][Abstract • Get Topic Environment].

[ECMAScript **declarative Environment Records**][] are the Records of the usual
Lexical Environments that are declared by syntax blocks `{`…`}`. [ECMAScript
function Environment Records][] are a special type of declarative Environment
Record. The rest of the types of Environment Records don’t matter in this
proposal.

Declarative Environment Records have two additional new fields and implement
three additional new concrete methods.

| Name                     | Description
| ------------------------ | -------------------------------------------------------------
| [[Topic Binding Status]] | “bound” or “void” or “clear”. Default value is “void”.
| [[Topic Value]]          | Default value is undefined.
| Get Topic Value ()       | “What is the value of the topic binding?” See below.
| Clear Topic Binding ()   | Sets the topic binding status to “clear”.
| Bind Topic Value (_V_)   | Sets the topic value to _V_; also sets the status to “bound”.

#### Method • Get Topic Binding Status
In general, this version returns “void”, because most Environment Records
**void** any topic binding from their outside.

However, declarative and function Environment Records return the value of their
field [[Topic Binding Status]], which is **“void”** by default. It may also be
**“clear”** (if the Clear Topic Binding method was called) or **“bound”** (if
the Bind Topic Value method was called). An Environment Record with a **void**
topic binding may **change** its status to “clear” or “bound” but **never vice
versa**.

* **Get Topic Binding Status** ()
  * **Declarative Environment Record**
    1. Let _env Rec_ be the function Environment Record for which the method was
    invoked.
    3. Return _env Rec_ . [[Topic Binding Status]].
  * **Object Environment Record**\
    Return “void”.
  * **Function Environment Record**\
    Inherited from Declarative Environment Record . Get Topic Binding Status ().
  * **Global Environment Record**\
    Return “void”.
  * **Module Environment Record**\
    Return “void”.
  * **Lexical Environment Record**\
    Return “void”.

#### Method • Get Topic Binding
* **Get Topic Binding** ()
  * **Declarative Environment Record**\
    1. Let _env Rec_ be the declarative Environment Record for which the method
       was invoked.
    2. Assert: _env Rec_ . [[Topic Binding Status]] is “bound”.
    3. Return _env Rec_ . [[Topic Value]].
  * **Function Environment Record**\
    Inherited from Declarative Environment Record . Get Topic Binding ().

#### Method • Clear Topic Value
* **Clear Topic Value**
  * **Declarative Environment Record**\
    1. Let _env Rec_ be the declarative Environment Record for which the method
       was invoked.
    2. Assert: _env Rec_ . [[Topic Binding Status]] is “void”.
    3. Set _env Rec_.[[Topic Binding Status]] to “clear”.
    4. Return _V_.
  * **Function Environment Record**\
    Inherited from Declarative Environment Record . Clear Topic Value ().

#### Method • Bind Topic Value
* **Bind Topic Value** (_V_)
  * **Declarative Environment Record**\
    1. Let _env Rec_ be the declarative Environment Record for which the method
       was invoked.
    2. Assert: _env Rec_ . [[Topic Binding Status]] is “void”.
    3. Set _env Rec_.[[Topic Value]] to _V_.
    4. Set _env Rec_.[[Topic Binding Status]] to “bound”.
    5. Return _V_.
  * **Function Environment Record**\
    Inherited from Declarative Environment Record . Bind Topic Value (_V_).

### Abstract • Get Topic Environment
The new abstract operation Get Topic Environment finds the Environment Record
that currently supplies the topic binding or that voids the topic binding: that
is, the **nearest [topic-opaque][TODO]** ancestral environment, which would **not** have
a topic binding status of **clear**. Its definition has been adapted from
[ECMAScript Get This Environment][].

1. Let _lex_ be the running execution context’s Lexical Environment.
2. Repeat,
    1. Let _env Rec_ be _lex_’s Environment Record.
    2. Let _status_ be _env Rec_ . Get Topic Binding Status ().
    3. If _status_ is not “clear”, return _env Rec_.
    4. Let _outer_ be the value of _lex_’s outer environment reference.
    5. Set _lex_ to _outer_.

The loop in step 2 will always terminate because the list of environments always
ends with the global environment, which always has a void (that is, not-clear)
topic binding status.

### Abstract • Resolve Topic Binding
**Resolve Topic Binding** is a new abstract operation. It determines the binding
of the topic `#` using the Lexical Environment of the running execution context.
It must **never** be called when the nearest ancestral topic environment has a
topic binding status of **void**. (The nearest ancestral topic environment also,
by definition, never has a topic binding status of “clear”.)

1. Let _env Rec_ be Get Topic Environment ().
2. Assert _env Rec_ . Get Topic Binding Status () is “bound”.
3. Return ? _env Rec_ . Get Topic Binding ().

### Topic reference • Evaluation
When evaluated during runtime, the topic reference uses the Resolve Topic
abstract operation on the running execution context’s lexical environment.

* **Evaluation**
  * **_Primary Expression_ : `#`**
    * Return ? Resolve Topic ()

### Topic style • Topic Pipeline Body Instantiation
This algorithm was adapted from [ECMAScript Blocks, § RS: Block Declaration
Instantiation][].

**Topic Pipeline Instantiation** is performed as follows using arguments _code_,
_env_, and _topic_.\
_code_ is the Parse Node corresponding to the body of the pipeline.\
_env_ is the Lexical Environment in which the topic binding is to be created.\
_topic_ is the value that will be bound to _env_’s topic.

1. Let _env Rec_ be _env_’s Environment Record.
2. Assert: _env Rec_ is a declarative Environment Record.
3. Assert: _env Rec_ . Get Topic Binding Status () is “void”.
4. Assert: _env Rec_ . Get Topic () is undefined.
5. Perform ! _env Rec_ . Bind Topic Value (_topic_).

### Topic style • Evaluation
This algorithm was adapted from [ECMAScript Blocks, § RS: Evaluation][].

* **Evaluation**
  * **_Pipeline Topic Body_** : _Conditional Expression_
    1. Let _old Env_ be the running execution context’s Lexical Environment.
    2. Let _pipeline Body Env_ be New Declarative Environment (_old Env_).
    3. Perform Topic Pipeline Body Instantiation (_Statement List_, _pipeline Body Env_).
    4. Set the running execution context’s Lexical Environment to _pipeline Body Env_.
    5. Let _pipeline Value_ be the result of evaluating _Conditional Expression_.
    6. Set the running execution context’s Lexical Environment to _old Env_.
    7. Return _pipeline Value_.

No matter how control leaves the _Pipeline Topic Body_ the Lexical Environment
is always restored to its former state.

Topic style behaves like **`do { const ` _topic Identifier_ `=` _topic_`;
`_substituted Body_` }`**, where:

* _topic Variable_ is any [identifier that is *not* already used by any
  variable][lexically hygienic], in the outer lexical context or the body’s
  inner topic context,
* And _substituted Body_ is _body_ but with every instance of outside of
  the topic reference replaced by _topic Variable_.

[TODO: Add link to term-rewriting appendix.]

### Simple reference • Evaluation
Simple references’ runtime semantics are exactly the same as the member
expressions they resemble.

This section is adapted from [ECMAScript Property Accessors, § RS: Evaluation][].

* **Evaluation**
  * _Simple Reference_ : _Simple Reference_ `.` _Identifier Name_
    * Is evaluated in exactly the same manner as [_Member Expression_ `:`
      _Member Expression_ `.` _Identifier Name_][ECMAScript Property Accessors,
      § RS: Evaluation] except that the contained _Simple Reference_ is evaluated
      in step 1.

### Bare function call • Evaluation
If the body is a merely a simple reference, then that identifier is interpreted
to be a **bare function call**. The pipeline’s value will be the result of
calling the body with the current topic as its argument.

This algorithm was adapted from [ECMAScript Function Calls, § RS: Evaluation][].

* **Pipeline Body Evaluation**\
  With parameter _head Value_.
  Note that this Pipeline Body Evaluation rule is used in the evaluation of
  _Pipeline Expression_, defined previously.
  * _Pipeline Bare Function Call_ : _Simple Reference_
    1. Let _ref_ be the result of evaluating _Simple Reference_.
    2. Let _func_ be ? Get Value(_ref_).
    3. Let _this Call_ be this _Pipeline Bare Function Call_.
    4. Let _tail Call_ be Is In Tail Position(_this Call_).
    5. Let _Arguments_ be a [List][ECMAScript Lists and Records] containing
       the one element which is _head Value_.
    6. Return ? Evaluate Call(_func_, _ref_, Arguments, _tail Call_).

### Bare constructor call • Evaluation
This algorithm was adapted from [ECMAScript `new` operator, § RS: Evaluation][].

* **_Pipeline Body Evaluation_**\
  With parameter _head Value_.

  Note that this Pipeline Body Evaluation rule is used in the evaluation of
  _Pipeline Expression_, defined previously.

  * **_Pipeline Bare Constructor Call_** : `new` _Simple Reference_
    * [TODO: Can we use Evaluate New if _Simple Reference_ is technically not the
      same as Member Expression? Should we just use Member Expression with some
      limitations?]

### Pipeline-level expressions
During runtime, [TODO]

* **Evaluation**
  * **_Pipeline Expression_** : _Pipeline Expression_ `|>` _Pipeline Body_
    1. Let _head Ref_ be the result of evaluating ? _Pipeline Expression_.
    2. Let _head Value_ be the result of ? Get Value (_head Ref_).
    3. Let _body Ref_ be Pipeline Body Evaluation of _Pipeline Body_ with argument
       _head Value_.
    4. Return ? Get Value(_body Ref_).

## Relations to other work

<!--
[TODO: https://github.com/gajus/babel-plugin-transform-function-composition]

[TODO: refer to #background list of programming languages]
 -->

<!--
### Other ECMAScript proposals
[TODO: `do` expressions]

[TODO: Partial application: “topic reference” vs. “placeholder”.]

[TODO: Private class fields and `#`.]

[TODO: Class decorators and `@`.]

[TODO: Block params: https://github.com/samuelgoto/proposal-block-params]

[TODO: Function bind: https://github.com/zenparsing/es-function-bind]

[TODO: pattern matching https://github.com/tc39/proposal-pattern-matching]

 -->

### Possible future extensions to the topic concept
The [concept of the “topic variable” already exists in many other programming
languages][topic variables in other languages], commonly named with an
underscore `_` or `$_`. These languages often integrate their topic variables
into their function-call control-flow syntaxes, with [Perl 6 as perhaps the most
extensive, unified example][Perl 6 topicization]. Integration of topic with
syntax enables especially pithy, terse [tacit programming][].

In addition, many JavaScript console [REPLs][], such as those of the WebKit Web
Inspector and the Node.js interactive console… [TODO]

Several disadvantages to these prior approaches may increase the probability of
developer surprise, in which “surprise” refers to behavior difficult to predict
by the developer.

One disadvantage arises from their frequent dynamic binding rather than lexical
binding, as the former is not [statically analyzable][static analyzability] and is more stateful than
the latter. It may also cause surprising results when coupled with bare/tacit
calls: it becomes more difficult to tell whether a bare identifier `print` is
meant to be a simple variable reference or a bare function call on the topic
value.

Another disadvantage arises from the ability to clobber or overwrite the value of the
topic variable, which may affect code in surprising ways.

However, JavaScript’s topic reference `#` is different than this prior art. It
is lexically bound and statically analyzable. It is also cannot be accidentally
bound; the developer must opt into binding it by using the pipe operator.

The topic also cannot be accidentally used; it is a syntax error when `#` is used
outside of a pipeline body. [TODO: Link to pertinent grammar sections.]

The topic is [conceptually general][conceptual generality] and could be extended
to other forms. This proposal is [forward compatible][forward compatibility]
with such extensions, which would increase its [expressive versatility][], and
potentially multiplying its benefits toward [untangled flow][], [terse
variables][], and [human writability][], while still preserving [simple
scoping][] and [static analyzability][].

<table>

<tr>
<th>

Pipe functions

<td>

A new type of function, the pipe function `->` …, would act as if it were `$ =>
$ |> …`, where `$` is a hygienically unique variable. A pipe function does not
take a parameter list; it is essentially a unary operator on an expression.
(Whether it could optionally take a parameter list is up for debate. It would be
confusing if skinny arrows were allowed to include or omit parameters while fat
arrows still always required parameters. See also [Brian Terlson’s proposal for
headless fat-arrow functions][ECMAScript headless-arrow proposal]).

A pipe function would bind its first argument to the topic reference within its
body. It would also parse its body using the same smart body syntax that the
pipe operator uses.

**More than any other** possible extension in this table, pipe functions would
dramatically increase the potential of tacit programming. Just this single
additional operator seems to solve:\
tacit unary-**functional composition**,\
tacit unary-functional **partial application**,\
and tacit **method extraction**,\
…all with a single additional concept.

<tr>
<td>

```js
-> #
```

<td>

```js
$ => $ |> #
```
```js
$ => $
```

<tr>
<td>

```js
-> # + 2
```

<td>

```js
$ => $ |> # + 2
```
```js
$ => $ + 2
```

<tr>
<td>

```js
-> x + 2 // 🚫
```

<td>

This is a syntax error, because the topic is not used anywhere in the pipe
function’s body – just like with `… |> x + 2`. [TODO: Link to early error.]

<tr>
<td>

```js
=> # + 2 // 🚫
```

<td>

If the skinny arrow `->` is typoed as a fat arrow `=>` instead, then this is
a syntax error.
This is a syntax error if not within a topic context.
function’s body – just like with `… |> x + 2`. [TODO: Link to early error.]

<tr>
<td>

```js
-> f(2, #)
```

<td>

```js
$ => $ |> f(2, #)
```
```js
$ => f(2, $)
```

<tr>
<td>

```js
-> f |> g |> h(2, #) |> # + 2
```
**Functional composition** on unary functions is equivalent to piping a value
through several function calls, within a unary function, starting with the outer
function’s single tacit parameter.

<td>

```js
$ => $
```
```js
$ => h(2, g(f($))) + 2
```

<tr>
<td>

```js
const doubleThenSquareThenHalfAsync =
  -> double |> await squareAsync # |> half
```
Unlike the other version, this syntax does not need to give implicit special
treatment to async functions and generators.

<td>

```js
const doubleThenSquareThenHalfAsync =
  double +> squareAsync +> half
```
From the proposal for [syntactic functional composition][]
by [Gilbert “mindeavor”][mindeavor].

<tr>
<td>

```js
const addOne = -> add(1, #)
addOne(2) // 3
```
**Partial application into a unary function** is equivalent to piping a tacit
parameter into a function-call expression, within which the one parameter is
resolvable.

<td>

```js
const addOne = add(1, ?)
addOne(2) // 3
```
Pipe functions look similar to the proposal for [syntactic partial
application][] by [Ron Buckton][], except that partial-application expressions
are simply pipeline bodies that are prefixed by a topic arrow.

<tr>
<td>

```js
const addTen = -> add(#, 10)
addTen(2) // 12
```

<td>

```js
const addTen = add(?, 10)
addTen(2) // 12
```

<tr>
<td>

```js
let newScore = player.score
  |> add(7, #)
  |> clamp(0, 100, #)
```

<td>

```js
let newScore = player.score
  |> add(7, ?)
  |> clamp(0, 100, ?)
```

<tr>

<tr>
<td>

```js
Promise.resolve(123).then(-> console.log)
```
**Method extraction** can be addressed by pipe functions alone, as a natural
result of their pipe-operator-like semantics.\
`-> console.log` is equivalent to `$ => $ |> console.log`, which is a pipeline in
bare style. This in turn is `$ => console.log($)`…

<td>

```js
Promise.resolve(123).then(::console.log)
```
…and `$ => console.log($)` is just a wordier version of which evaluates into a
function equivalent to `console.log.bind(console)`.

<tr>
<td>

```js
$('.some-link').on('click', -> view.reset)
```

<td>

```js
$('.some-link').on('click', ::view.reset)
```

<tr>
<td>

```js
const { hasOwnProperty } = Object.prototype
const x = { key: 5 }
x::hasOwnProperty
x::hasOwnProperty('key')
```
To do terse **method calling/binding**, the `::` operator would still be required.

<td>

```js
const { hasOwnProperty } = Object.prototype
const x = { key: 5 }
x::hasOwnProperty
x::hasOwnProperty('key')
```
But the `::` would only need to handle method calls. No operator overloading of
`::` for method extraction would be needed.

<tr>

<tr>
<th>

Multiple lexical topics

<td>

Lexical environments could extended to support multiple topics at once. Regular
pipelines would still have only one topic at a time. But pipe functions could
bind multiple parameters to multiple topic references. `#` (as an alias for
`#0`) would already represent its first parameters. But then `#1`, `#2`, … would
represent its second, third, fourth, etc. parameters. Parameters in positions
after the maximum-number topic used in the lexical context could be put into an
array, to which the rest-topic reference (`...` or perhaps `...#`) would be
bound in turn.

This would be somewhat akin to Clojure’s compact anonymous functions, which use
`%` aka `%1`, then `%2`, `%3`, … for its parameters within the compact
functions’ bodies.

Developers may be expected not to use pipe functions for functions with many
parameters. But an alternative to `#`, `##`, `###`, …, not shown here, would be
to use `#` or `#0`, then `#1`, `#2`, … for topic references instead.

<tr>
<td>

```js
numbers.sort(-> # - ##)
```

<td>

```js
numbers.sort(function (a, b) {
  return a - b
})
```

<tr>
<td>

```js
[ { x: 22 }, { x: 42 } ]
  .map(-> #.x)
  .reduce(-> Math.max(#, ##),
    -Infinity)
```

<td>

```js
[ { x: 22 }, { x: 42 } ]
  .map(el => el.x)
  .reduce((x0, x1) => Math.max(x0, x1),
    -Infinity)
```

<tr>

<tr>
<td>

```js
const f = (x, y, z) => [x, y, z]
const g = f(#, 4, ##)
g(1, 2) // [1, 4, 2]
```
**Partial application into an n-ary function** is solved by pipe functions with
multiple topics.

<td>

```js
const f = (x, y, z) => [x, y, z]
const g = f(?, 4, ?)
g(1, 2) // [1, 4, 2]
```
[R. Buckton’s current proposal][syntactic partial application] assumes that each
use of its `?` placeholder token represents a different parameter: a fundamental
difference in conceptual models.

<tr>
<td>

```js
const maxGreaterThanZero =
  -> Math.max(0, ...)
maxGreaterThanZero(1, 2) // 2
maxGreaterThanZero(-1, -2) // 0
```
Partial application into a variadic function requires a multi-topic environment
and a rest-topic reference `...`.

<td>

```js
const maxGreaterThanZero =
  Math.max(0, ...)
maxGreaterThanZero(1, 2) // 2
maxGreaterThanZero(-1, -2) // 0
```
In this case, the topic function version looks once again nearly identical to
the other proposal’s code.

<tr>

<th>

Topic `for` loops

<td>

With this smart-pipe proposal only, `for`–`of` statements would prohibit the use
of `#` within their bodies, except where `#` is inside an inner pipeline inside
the `for` loop.

With another, future proposal, all `for`–`of` loops would implicitly bind each
iterator value to `#`. This implicit binding would be in addition to the
explicit binding of a normal variable `i` declared within the parenthesized
antecedent `for (const i of … { … })`.

An additional tacit `for` loop form, completely lacking a parenthesized
antecedent, would also be added. This tacit form is what is used in this example.
[TODO: Link to section on deep nesting.] This example also uses the hypothetical
headless pipelining syntax from above.

<tr>
<td>

```js
for (range(0, 50)) {
  log(# ** 2);
  log(#|> Math.sqrt);
}
```

<td>

```js
for (const i of range(0, 50)) {
  log(i |> # ** 2);
  log(i |> Math.sqrt);
}
```

<tr>
<th>

Topic `for`–`await` loops

<td>

This is similar to the tacit topic synchronous `for` loop above. With this
proposal only, `for`–`await`–`of` statements would prohibit the use of `#`
within their bodies, except where `#` is inside an inner pipeline inside the
`for` loop.

With another, future proposal, all `for`–`await`–`of` loops would implicitly bind
each iterator value to `#`. This implicit binding would be in addition to the
explicit binding of a normal variable `i` declared within the parenthesized
antecedent `for await (const i of …) { … }`.

An additional tacit `for await` loop form, completely lacking a parenthesized
antecedent, would also be added. This tacit form is what is used in this
example. [TODO: Link to section on deep nesting.] This example also uses the
hypothetical headless pipelining syntax from above.

<tr>
<td>

```js
for await (stream) {
  yield #
    |> f
    |> # + 3
}
```

<td>

```js
for await (const c of stream) {
  yield c
    |> f
    |> # + 3
}
```

<tr>

<th>

Topic block parameters

<td>

The proposed syntax of [ECMAScript block parameters][] may greatly benefit from
using the topic concept. As with topic function definitions, making all block
parameters topic would enable the use of the topic reference as an implicit
first parameter.

<tr>
<td>

```js
materials.map { #|> f |> .length }
```
(Here, `#|> f` is just a stylistic variant of `# |> f`, which is already valid
in this proposal’s rules.)

Note that this would be the same as:
```js
materials.map(-> f |> .length)
```

<td>

```js
materials.map { f(???).length }
```

The block-parameter proposal itself has not yet settled on how to parameterize
its block parameters. The topic reference may be the key to solving this
problem, making other, special block parameters unnecessary. This example also
uses the hypothetical headless property syntax and headless pipelining syntax
from above.

<tr>
<td>

```js
server(app) {
  #.get('/') do (response) {
    request()
      |> .get('param1')
      |> `hello world ${#}`
      |> response.send
  }

  #.listen(3000) {
    log('hello')
  }
}
```

<td>

```js
server(app) {
  ???.get('/') do (response) {
    request()
      |> #.get('param1')
      |> `hello world ${#}`
      |> response.send
  }

  ???.listen(3000) {
    log('hello')
  }
}
```

<tr>

<tr>
<th>

Topic pattern matching

<td>
The proposed syntax of [ECMAScript pattern matching][] would bind the topic
reference within the scope of a successful match clause’s scope. The topic value
would be the truthy result of the successful `Symbol.matches` call. This example
also uses the hypothetical headless property syntax from above.

<tr>
<td>

```js
match (x) {
  100: #
  Array:
    .length
  /(\d)(\d)(\d)/:
    #.groups |> #[0] + #[1] + #[2]
}
```

<td>

```js
match (x) {
  100: x
  Array:
    x.length
  /(\d)(\d)(\d)/ -> m:
    m.groups |> #[0] + #[1] + #[2]
}
```

<tr>
<th>

Tacit pattern matching

<td>

[ECMAScript pattern matching] could also have a completely tacit version, in
which the parenthesized antecedent is completely omitted in favor of tacitly
using the outer context’s topic. (This would have to somehow be distinguishable
from a call to a function named `match` with a [bare block argument][ECMAScript
block parameters].) This example also uses the hypothetical headless pipelining
syntax from above.

<tr>
<td>

```js
… |> f
  |> match {
    { x, y }:
      (x ** 2 + y ** 2)
        |> Math.sqrt
    [...]:
      #.length
    else:
      throw new Error(#)
  }
}
```

<td>

```js
… |> f
  |> match (#) {
    { x, y }:
      (x ** 2 + y ** 2)
        |> Math.sqrt
    [...]:
      #.length
    else:
      throw new Error(vector)
  }
}
```

<tr>
<th>

Tacit error capture

<td>

With this smart-pipe proposal only, all `try` statements’ `catch` clauses would
prohibit the use of `#` within their bodies, except where `#` is inside an inner
pipeline inside the `catch` clause. [TODO: Link to sections explaining these
inner block rules.]

With another, future proposal, all `catch` causes would implicitly bind
their caught errors to `#`. This implicit binding would be in addition to the
explicit binding of a normal variable `error` declared within the parenthesized
antecedent `try { … } catch (error) { … }`.

An additional bare `catch` form, completely lacking a parenthesized antecedent,
has already been proposed as [ECMAScript optional catch binding][]. This bare
form would also support implicit `#` binding, serving as the fully tacit form
used in this example. [TODO: Link to section on deep nesting.] The bare form,
along with the hypothetical headless property syntax from above, are
demonstrated here.

<tr>
<td>

```js
try {
  …
} catch {
  log(.message)
} finally {
  …
}
```

<td>

```js
try {
  …
} catch (error) {
  log(#.message)
} finally {
  …
}
```

<tr>
<td>

```js
try {
  …
} catch {
  match {
    MyError:
      #|> f
    TypeError:
      #|> g
    SyntaxError:
      #|> f |> g
    Error:
      `Error: ${#.message}`
  }
}
```

<td>

```js
try {
  …
} catch (error) {
  match (error) {
    MyError:
      error |> f
    TypeError:
      error |> g
    SyntaxError:
      error |> f |> g
    Error:
      `Error: ${error.message}`
  }
}
```

<tr>

<tr>
<th>

Topic metaprogramming references

<td>

In the event that TC39 seriously considers the topic function definitions
shown above, a **`function.topic`** metaprogramming operator, in the style of
the [`new.target`][] operator, could be useful in creating topic-aware functions.

This might be especially useful in creating APIs resembling [domain-specific
languages][DSLs] with [ECMAScript block parameters][]. This example creates
three functions that form an API resembling [Visual Basic’s `select`
statement][]. Two of these functions (`when` and `otherwise`) that are expected
to be called always within the third function (`select`)’s callback block.

An alternate solution without metaprogramming topics is not yet specified by the
current proposal for [ECMAScript block parameters][].

<tr>
<td colspan=2>

```js
class CompletionRecord { [[TODO]] }

function select (value, callback) {
  const contextTopic =
    [[TODO: create completion record]]
  return callback(topic) // TO DO
}

function otherwise (callback) { [[TODO]] }

function when (testValue, callback) {
  const contextTopic = function.topic
  return match (contextTopic) {
    [TODO]:
      |> applyWhen(#, testValue, callback)
    else:
      throw new Error('when clause was used outside select block')
  }
}

function applyWhen (contextTopic, testValue) {
  match (.value) {
    [...]: |> applyWhenArray
    else: |> applyWhenValue
  }
}

function applyWhenArray (contextTopic, testArray) {
  .some(arrayValue =>
    contextTopic |> when(arrayValue, callback))
}

function applyWhenValue (contextTopic, testArray) {
  return #[Symbol.matches](contextValue)
    ? contextTopic |> callback |> [[TODO]]
    : [[TODO: Pass to next when]]
}
```
***
```js
select ('world') {
  when ([Boolean, Number]) {
    log(#)
  }
  when (String) {
    log(`Hello ${#}`)
  }
  otherwise {
    throw new Error(`Error: ${#|> format}`)
  }
}
```

</table>

### Alternative solutions explored
There are a number of other ways of potentially accomplishing the above use
cases. However, the authors of this proposal believe that the smart pipe
operator may be the best choice. [TODO]

## Appendix • Explanation of nomenclature
The term [“**topic**” comes from linguistics][topic and comment] and have
precedent in prior programming languages’ use of “topic variables”.

The term “**head**” is preferred to “**topic expression**” because, in the
future, the [topic concept could be extended to other syntaxes such as
`for`][possible future extensions to the topic concept], not just pipelines.

In addition, “head” is preferred to “**LHS**”, because “LHS” in the ECMAScript
specification usually refers to the [LHS of assignments][ECMAScript LHS expressions],
which may be confusing. However, “topic expression” and “LHS” are still fine and
acceptable, if not imprecise, names for a pipeline’s head.

The term “**topic reference**” is preferred to the phrase “**topic variable**”
because the latter is a misnomer. The topic reference is *not* a variable
identifier. Unlike variables, it cannot be manually declared (`const #` is a
syntax error), nor can it be assigned with a value (`# = 3` is a syntax error).

“Topic reference” is also preferred to “**topic placeholder**”, to avoid
confusion with the placeholders of another TC39 proposal – [syntactic partial
application][]. These placeholders (currently denoted by nullary `?`) are of a
different nature than topic references. Instead of referring to a single value
bound earlier in the surrounding lexical context, these **parameter
placeholders** act as the parameter to a new function. When this new function is
called, those parameter placeholders will be bound to multiple argument values.

The term “**body**” is preferred instead of “**RHS**” because “topic” is
preferred to “LHS”. However, “RHS” is still a fine and acceptable name for the
body of the pipeline operator.

“**Bare style**” can also be called “**tacit style**”, but the former is
preferred to the latter. Eventually, certain [possible future extensions to the
topic concept][] may enable [tacit programming][] even without using bare-style
pipelines.

## Appendix • Term rewriting
### Term rewriting topic style
Pipe bodies in topic style can be rewritten into a nested `do` expression.
There are two ways to illustrate this equivalency. The first way is to [replace
each pipe expression’s topic references with an autogenerated variable][term
rewriting with autogenerated variables], which must be guaranteed to be
[lexically hygienic][] and to not conflict with other variables. The alternative
way is to [use two variables – the topic reference `#` and a single dummy
variable][term rewriting with single dummy variable] – which also preserves
[lexical hygiene][lexically hygienic].

#### Term rewriting with autogenerated variables
The first way to illustrate the operator’s semantics is to replace each pipe
expression’s topic references with an autogenerated variable, which must be
guaranteed to not conflict with other variables.

Let us pretend that each pipe expression autogenerates a new, [lexically
hygienic][] variable (`#₀`, `#₁`, `#₂`, `#₃`, …), which in turn replaces each
topic reference `#` in each pipeline body. (These `#ₙ` variables are not true
syntax; it is merely for illustrative purposes. You cannot actually assign or
use `#ₙ` variables.) Let us also group the expressions with left associativity
(although this is arbitrary, because [right associativity would also
work][arbitrary associativity]).

With this notation, each line in this example would be equivalent to the other lines.

```js
1 |> # + 2 |> # * 3

// Static term rewriting
(1 |> # + 2) |> # * 3
do { const #₀ = 1; # + 2 } |> # * 3
do { const #₁ = do { const #₀ = 1; # + 2 }; #₁ * 3 }

// Runtime evaluation
do { const #₀ = do { 1 + 2 }; #₀ * 3 }
do { const #₀ = 3; #₀ * 3 }
do { do { 3 * 3 } }
9
```

Consider also the motivating first example above:

```js
stringPromise
  |> await #
  |> # ?? throw new TypeError()
  |> doubleSay // a bare unary function call
  |> capitalize // also a bare unary function call
  |> # + '!'
```

Under left associativity, this would be statically equivalent to the following:

```js
do {
  const #₃ = do {
    const #₂ = do {
      const #₁ = do {
        const #₀ = await stringPromise;
        #₀ ?? throw new TypeError()
      };
      doubleSay(#₁)
    };
    capitalize(#₂)
  };
  #₃ + '!'
}
```

In general, for each pipe expression `topic |> body`, assuming that `body` is in
topic style, that is, assuming that `body` contains an unshadowed topic
reference:

* Let _#<sub>n</sub>_ be a [hygienically autogenerated][lexically hygienic] topic
  reference, _#<sub>n</sub>_, where <var>n</var> is a number that would not conflict with
  the name of any other autogenerated topic reference in the scope of the
  entire pipe expression.
* Also let _substituted Body_ be `body` but with all instances of `#` replaced
  with _#<sub>n</sub>_.
* Then the static term rewriting (left associative and inside to outside) would
  simply be: `do { const ` _#<sub>n</sub>_ `= topic; ` _substituted Body_ `}`.
  This `do` expression would act as at the topic scope.

#### Term rewriting with single dummy variable
The other way to demonstrate topic style is to use two variables: the topic
reference `#` and single [lexically hygienic][] dummy variable `•`. It should be
noted that `const # = …` is not a valid statement under this proposal’s actual
syntax; likewise, `•` is not a part of the proposal’s syntax. Both forms are for
illustrative purposes here only.

With this notation, no variable autogeneration is required; instead, the nested
`do` expressions will redeclare the same variables `#` and `•`, shadowing the
external variables of the same name as needed. The number example above becomes
the following. Each line is still equivalent to the other lines.
```js
1 |> # + 2 |> # * 3

// Static term rewriting
(1 |> # + 2) |> # * 3
do { const • = 1; do { const # = •; # + 2 } } |> # * 3
do { const • = (do { const • = 1; do { const # = •; # + 2 } }); do { const # = •; # * 3 } }

// Runtime evaluation
do { const • = do { do { const # = 1; # + 2 } }; do { const # = •; # * 3 } }
do { const • = do { do { const 1 + 2 } }; do { const # = •; # * 3 } }
do { const • = 3; do { const # = •; # * 3 } }
do { do { const # = 3; # * 3 } }
do { do { 3 * 3 } }
9
```

Consider also the motivating first example above:
```js
stringPromise
  |> await #
  |> # ?? throw new TypeError()
  |> doubleSay // a bare unary function call
  |> capitalize // also a bare unary function call
  |> # + '!'
```

Under left associativity, this would be statically equivalent to the following:
```js
do {
  const • = do {
    const • = do {
      const • = do {
        const • = await stringPromise;
        do { const # = •; # ?? throw new TypeError() }
      };
      do { const # = •; doubleSay(#) }
    };
    do { const # = •; capitalize(#) }
  };
  do { const # = •; # + '!' }
}
```

For each pipe expression, evaluated left associatively and inside to outside,
the steps of the computation would be:

1. The head is first evaluated in the current lexical context.
2. The topic’s result is bound to a hidden special variable `•`.
3. In a new inner lexical context (the topic scope), the value of `•` is
  bound to the topic reference `#`.
4. The pipe’s body is evaluated within this inner lexical context.
5. The pipe’s result is the result of the body.

### Term rewriting • Arbitrary associativity
The pipe operator is presented above as a left-associative operator. However, it
is theoretically [arbitrarily associative][associative property]: how a
pipeline’s expressions are particularly grouped is functionally arbitrary. One
could force right associativity by parenthesizing a pipeline, such that it
itself becomes the body of another, outer pipeline.

Consider the above example `1 |> # + 2 |> # * 3`, whose terms were statically
rewritten using left associativity and autogenerated, [lexically hygienic][]
variables.
```js
// With left associativity and autogenerated hygienic variables.
1 |> # + 2 |> # * 3

// Static term rewriting
(1 |> # + 2) |> # * 3
do { const #₀ = 1; # + 2 } |> # * 3
do { const #₁ = do { const #₀ = 1; # + 2 }; #₁ * 3 }

// Runtime evaluation
do { const #₀ = do { 1 + 2 }; #₀ * 3 }
do { const #₀ = 3; #₀ * 3 }
do { do { 3 * 3 } }
9
```

But if right associativity is forced with `1 |> (# + 2 |> # * 3)`, then the
result would be the same: `9`:
```js
// With right associativity and autogenerated hygienic variables.
1 |> # + 2 |> # * 3

// Static term rewriting
1 |> (# + 2 |> # * 3)
1 |> do { const #₀ = # + 2; #₀ * 3 }
do { const #₁ = 1; do { const #₀ = #₁ + 2; #₀ * 3 } }

// Runtime evaluation
do { do { const #₀ = 1 + 2; #₀ * 3 } }
do { do { const #₀ = 3; #₀ * 3 } }
do { do { 3 * 3 } }
9
```

Similarly, `1 |> # + 2 |> # * 3` was also statically term rewritten using a
different method: under left associativity and a single dummy variable.
```js
// With left associativity and single dummy variable.
1 |> # + 2 |> # * 3

// Static term rewriting
(1 |> # + 2) |> # * 3
do { const • = 1; do { const # = •; # + 2 } } |> # * 3
do { const • = (do { const • = 1; do { const # = •; # + 2 } }); do { const # = •; # * 3 } }

// Runtime evaluation
do { const • = do { do { const # = 1; # + 2 } }; do { const # = •; # * 3 } }
do { const • = do { do { const 1 + 2 } }; do { const # = •; # * 3 } }
do { const • = 3; do { const # = •; # * 3 } }
do { do { const # = 3; # * 3 } }
do { do { 3 * 3 } }
9
```

If right associativity is forced with `1 |> (# + 2 |> # * 3)`, then the result
would be the same: `9`:
```js
// With right associativity and single dummy variable.
1 |> # + 2 |> # * 3

// Static term rewriting
1 |> (# + 2 |> # * 3)
1 |> do { const • = # + 2; do { const # = •; # * 3 } }
do { • = 1; do { const # = •; do { const • = # + 2; do { const # = •; # * 3 } } } }

// Runtime evaluation
do { do { const # = 1; do { const • = # + 2; do { const # = •; # * 3 } } }
do { do { do { const • = 1 + 2; do { const # = •; # * 3 } } }
do { do { do { const • = 3; do { const # = •; # * 3 } } }
do { do { do { do { const # = 3; # * 3 } } }
do { do { do { do { 3 * 3 } } }
9
```

[“data-to-ink” visual ratio]: https://www.darkhorseanalytics.com/blog/data-looks-better-naked
[“don’t break my code”]: #dont-break-my-code
[“don’t make me overthink”]: #dont-make-me-overthink
[“don’t shoot me in the foot”]: #dont-shoot-me-in-the-foot
[“make my code easier to read”]: #make-my-code-easier-to-read
[`for` iteration statements]: https://tc39.github.io/ecma262/#sec-iteration-statements
[`in` relational operator]: https://tc39.github.io/ecma262/#sec-relational-operators
[`new.target`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target
[Abstract • Get Topic Environment]: #abstract-get-topic-environment
[annevk]: https://github.com/annevk
[antecedent]: https://en.wikipedia.org/wiki/Antecedent_(grammar)
[arbitrary associativity]: #arbitrary-associativity
[associative property]: https://en.wikipedia.org/wiki/Associative_property
[background]: #background
[backward compatibility]: #backward-compatibility
[bare style • Grammar]: #bare-style-syntactic-grammar
[binding]: https://en.wikipedia.org/wiki/Binding_(linguistics)
[Clojure pipe]: https://clojuredocs.org/clojure.core/as-%3E
[completion records]: https://timothygu.me/es-howto/#completion-records-and-shorthands
[concatenative programming]: https://en.wikipedia.org/wiki/Concatenative_programming_language
[conceptual generality]: #conceptual-generality
[Contains]: #static-contains
[cyclomatic complexity]: https://en.wikipedia.org/wiki/Cyclomatic_complexity#Applications
[cyclomatic simplicity]: #cyclomatic-simplicity
[Daniel “littledan” Ehrenberg of Igalia]: https://github.com/littledan
[dataflow programming]: https://en.wikipedia.org/wiki/Dataflow_programming
[distinguishable punctuators]: #distinguishable-punctuators
[DSLs]: https://en.wikipedia.org/wiki/Domain-specific_language
[early errors]: #static-early-errors
[ECMAScript _Identifier Name_]: https://tc39.github.io/ecma262/#prod-IdentifierName
[ECMAScript _Identifier Reference_]: https://tc39.github.io/ecma262/#prod-IdentifierReference
[ECMAScript _Member Expression_]: https://tc39.github.io/ecma262/#prod-MemberExpression
[ECMAScript § The Syntactic Grammar]: https://tc39.github.io/ecma262/#sec-syntactic-grammar
[ECMAScript `new` operator, § RS: Evaluation]: https://tc39.github.io/ecma262/#sec-new-operator-runtime-semantics-evaluation
[ECMAScript arrow functions, § SS: Contains]: https://tc39.github.io/ecma262/#sec-arrow-function-definitions-static-semantics-contains
[ECMAScript Assignment-level Expressions]: https://tc39.github.io/ecma262/#sec-assignment-operators
[ECMAScript block parameters]: https://github.com/samuelgoto/proposal-block-params
[ECMAScript Blocks, § RS: Block Declaration Instantiation]: https://tc39.github.io/ecma262/#sec-blockdeclarationinstantiation
[ECMAScript Blocks, § RS: Evaluation]: https://tc39.github.io/ecma262/#sec-block-runtime-semantics-evaluation
[ECMAScript Declarative Environment Records]: https://tc39.github.io/ecma262/#sec-declarative-environment-records
[ECMAScript Function Calls, § RS: Evaluation]: https://tc39.github.io/ecma262/#sec-function-calls-runtime-semantics-evaluation
[ECMAScript Function Environment Records]: https://tc39.github.io/ecma262/#sec-function-environment-records
[ECMAScript Functions and Classes § Generator Function Definitions]: https://tc39.github.io/ecma262/#sec-generator-function-definitions
[ECMAScript Get This Environment]: https://tc39.github.io/ecma262/#sec-getthisenvironment
[ECMAScript headless-arrow proposal]: https://bterlson.github.io/headless-arrows/
[ECMAScript Lexical Environments]: https://tc39.github.io/ecma262/#sec-lexical-environments
[ECMAScript Lexical Grammar]: https://tc39.github.io/ecma262/#sec-ecmascript-language-lexical-grammar
[ECMAScript LHS expressions]: https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
[ECMAScript Lists and Records]: https://tc39.github.io/ecma262/#sec-list-and-record-specification-type
[ECMAScript Notational Conventions, § Algorithm Conventions]: https://tc39.github.io/ecma262/#sec-algorithm-conventions-abstract-operations
[ECMAScript Notational Conventions, § Grammars]: https://tc39.github.io/ecma262/#sec-syntactic-and-lexical-grammars
[ECMAScript Notational Conventions, § Lexical Grammar]: https://tc39.github.io/ecma262/#sec-lexical-and-regexp-grammars
[ECMAScript Notational Conventions, § Runtime Semantics]: https://tc39.github.io/ecma262/#sec-runtime-semantics
[ECMAScript optional catch binding]: https://github.com/tc39/proposal-optional-catch-binding
[ECMAScript pattern matching]: https://github.com/tc39/proposal-pattern-matching
[ECMAScript Primary Expressions]: https://tc39.github.io/ecma262/#prod-PrimaryExpression
[ECMAScript Property Accessors, § RS: Evaluation]: https://tc39.github.io/ecma262/#sec-property-accessors-runtime-semantics-evaluation
[ECMAScript Punctuators]: https://tc39.github.io/ecma262/#sec-punctuators
[ECMAScript static semantic rules]: https://tc39.github.io/ecma262/#sec-static-semantic-rules
[Elixir pipe]: https://elixir-lang.org/getting-started/enumerables-and-streams.html
[Elm pipe]: http://elm-lang.org/docs/syntax#infix-operators
[essential complexity]: https://en.wikipedia.org/wiki/Essential_complexity
[examples]: #examples
[expressions and operators (MDN)]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators
[expressive versatility]: #expressive-versatility
[F# pipe]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/index#function-composition-and-pipelining
[Fetch Standard]: https://fetch.spec.whatwg.org
[first pipe-operator proposal]: https://github.com/tc39/proposal-pipeline-operator/blob/37119110d40226476f7af302a778bc981f606cee/README.md
[footguns]: https://en.wiktionary.org/wiki/footgun
[formal grammar]: #grammar
[forward compatibility]: #forward-compatibility
[functional programming]: https://en.wikipedia.org/wiki/Functional_programming
[garden-path syntax]: https://en.wikipedia.org/wiki/Garden_path_sentence
[GitHub issue tracker]: https://github.com/tc39/proposal-pipeline-operator/issues
[goals]: #goals
[grammar parameters]: #grammar-parameters
[Hack pipe]: https://docs.hhvm.com/hack/operators/pipe-operator
[Huffman coding]: https://en.wikipedia.org/wiki/Huffman_coding
[human writability]: #human-writability
[IIFEs]: https://en.wikipedia.org/wiki/Immediately-invoked_function_expression
[incidental complexity]: https://en.wikipedia.org/wiki/Incidental_complexity
[inner blocks]: #inner-blocks
[jashkenas]: https://github.com/jashkenas
[Julia pipe]: https://docs.julialang.org/en/stable/stdlib/base/#Base.:|>
[lexical grammar]: #lexical-grammar
[lexically hygienic]: https://en.wikipedia.org/wiki/Hygienic_macro
[littledan invitation]: https://github.com/tc39/proposal-pipeline-operator/issues/89#issuecomment-363853394
[LiveScript pipe]: http://livescript.net/#operators-piping
[MDN operator precedence]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
[mindeavor]: https://github.com/gilbert
[motivation]: #motivation
[Node-stream piping]: https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options
[nomenclature]: #nomenclature
[novice learnability]: #novice-learnability
[object initializers’ Computed Property Contains rule]: https://tc39.github.io/ecma262/#sec-object-initializer-static-semantics-computedpropertycontains
[OCaml pipe]: http://blog.shaynefletcher.org/2013/12/pipelining-with-operator-in-ocaml.html
[operator precedence]: #operator-precedence
[optional-chaining syntax proposal]: https://github.com/tc39/proposal-optional-chaining
[other ECMAScript proposals]: #other-ecmascript-proposals
[other goals]: #other-goals
[PEP 20]: https://www.python.org/dev/peps/pep-0020/
[Perl 6 pipe]: https://docs.perl6.org/language/operators#infix_==&gt;
[Perl 6 topicization]: https://www.perl.com/pub/2002/10/30/topic.html/
[Pify]: https://github.com/sindresorhus/pify
[pipeline syntax]: #pipeline-syntax
[possible future extensions to the topic concept]: #possible-future-extensions-to-topic-concept
[previous pipeline-placeholder discussions]: https://github.com/tc39/proposal-pipeline-operator/issues?q=placeholder
[private class fields]: https://github.com/tc39/proposal-class-fields/
[Proposal 4: Smart Mix on the pipe-proposal wiki]: https://github.com/tc39/proposal-pipeline-operator/wiki#proposal-4-smart-mix
[R pipe]: https://cran.r-project.org/web/packages/magrittr/index.html
[relations to other work]: #relations-to-other-work
[REPLs]: https://en.wikipedia.org/wiki/Read–eval–print_loop
[resolving topics]: #resolve-topic
[reverse Polish notation]: https://en.wikipedia.org/wiki/Reverse_Polish_notation
[Ron Buckton]: https://github.com/rbuckton
[runtime semantics]: #runtime-semantics
[simple scoping]: #simple-scoping
[sindresorhus]: https://github.com/sindresorhus
[smart body syntax]: #smart-body-syntax
[smart pipelines]: #smart-pipelines
[static analyzability]: #static-analyzability
[syntactic functional composition]: https://github.com/TheNavigateur/proposal-pipeline-operator-for-function-composition
[syntactic locality]: #syntactic-locality
[syntactic partial application]: https://github.com/tc39/proposal-partial-application
[tacit programming]: https://en.wikipedia.org/wiki/Tacit_programming
[TC39 process]: https://tc39.github.io/process-document/
[Tennent correspondence principle]: http://gafter.blogspot.com/2006/08/tennents-correspondence-principle-and.html
[term rewriting • arbitrary associativity]: #term-rewriting-arbitrary-associativity
[term rewriting topic style]: #term-rewriting-topic-style
[term rewriting with autogenerated variables]: #term-rewriting-with-single-dummy-variable
[term rewriting with single dummy variable]: #term-rewriting-with-single-dummy-variable
[term rewriting]: https://en.wikipedia.org/wiki/Term_rewriting
[terse function calls]: #terse-function-calls
[terse parentheses]: #terse-parentheses
[terse variables]: #terse-variables
[topic and comment]: https://en.wikipedia.org/wiki/Topic_and_comment
[topic variables in other languages]: https://rosettacode.org/wiki/Topic_variable
[topic-token bikeshedding]: https://github.com/tc39/proposal-pipeline-operator/issues/91
[Underscore.js]: http://underscorejs.org
[Unix pipe]: https://en.wikipedia.org/wiki/Pipeline_(Unix
[untangled flow]: #untangled-flow
[WHATWG-stream piping]: https://streams.spec.whatwg.org/#pipe-chains
[zero runtime cost]: #zero-runtime-cost
